{
  "version": 3,
  "sources": ["../../../node_modules/preact/src/constants.js", "../../../node_modules/preact/src/util.js", "../../../node_modules/preact/src/options.js", "../../../node_modules/preact/src/create-element.js", "../../../node_modules/preact/src/component.js", "../../../node_modules/preact/src/diff/props.js", "../../../node_modules/preact/src/create-context.js", "../../../node_modules/preact/src/diff/children.js", "../../../node_modules/preact/src/diff/index.js", "../../../node_modules/preact/src/render.js", "../../../node_modules/preact/src/clone-element.js", "../../../node_modules/preact/src/diff/catch-error.js", "../../../node_modules/preact/devtools/src/index.js", "../../../node_modules/preact/devtools/src/devtools.js", "../../../node_modules/preact/debug/src/check-props.js", "../../../node_modules/preact/debug/src/component-stack.js", "../../../node_modules/preact/debug/src/debug.js", "../../../node_modules/preact/debug/src/constants.js", "../../../node_modules/preact/debug/src/util.js", "../../../node_modules/preact/debug/src/index.js", "../../../node_modules/preact/hooks/src/index.js", "../../../src/graphs/vertex.ts", "../../../src/graphs/edge_table.ts", "../../../src/graphs/vertex_table.ts", "../../../src/graphs/graph.ts", "../../../src/util.ts", "../../../src/schemas/builders.ts", "../../../src/schemas/graph.ts", "../../../src/frontend/shared/state/plangs_context.ts", "../../../src/frontend/shared/start.tsx", "../../../src/frontend/search/search.tsx"],
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[]} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\t// @ts-expect-error olDom should be present on a DOM node\n\t\t\tif (oldDom && !oldDom.isConnected) {\n\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t}\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\n\t\t// Handle unmounting null placeholders, i.e. VNode => null in unkeyed children\n\t\tif (childVNode == null) {\n\t\t\toldVNode = oldChildren[skewedIndex];\n\t\t\tif (\n\t\t\t\toldVNode &&\n\t\t\t\toldVNode.key == null &&\n\t\t\t\toldVNode._dom &&\n\t\t\t\t(oldVNode._flags & MATCHED) === 0\n\t\t\t) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode, false);\n\n\t\t\t\t// Explicitly nullify this position in oldChildren instead of just\n\t\t\t\t// setting `_match=true` to prevent other routines (e.g.\n\t\t\t\t// `findMatchingIndex` or `getDomSibling`) from thinking VNodes or DOM\n\t\t\t\t// nodes in this position are still available to be used in diffing when\n\t\t\t\t// they have actually already been unmounted. For example, by only\n\t\t\t\t// setting `_match=true` here, the unmounting loop later would attempt\n\t\t\t\t// to unmount this VNode again seeing `_match==true`.  Further,\n\t\t\t\t// getDomSibling doesn't know about _match and so would incorrectly\n\t\t\t\t// assume DOM nodes in this subtree are mounted and usable.\n\t\t\t\toldChildren[skewedIndex] = null;\n\t\t\t\tremainingOldChildren--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\tconst matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tchildVNode._index = matchingIndex;\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > newChildrenLength - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t// match the new skew index (i + new skew)\n\t\t\tif (matchingIndex !== i + skew) {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\t// ^ could possibly be simplified to:\n\t\t\t\t// excessDomChildren.length = 0;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (i !== 'key' && !(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\ti !== 'key' &&\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any>} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { options } from 'preact';\nimport { initDevTools } from './devtools';\n\ninitDevTools();\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, name: string) => T}\n */\nexport function addHookName(value, name) {\n\tif (options._addHookName) {\n\t\toptions._addHookName(name);\n\t}\n\treturn value;\n}\n", "import { options, Fragment, Component } from 'preact';\n\nexport function initDevTools() {\n\tif (typeof window != 'undefined' && window.__PREACT_DEVTOOLS__) {\n\t\twindow.__PREACT_DEVTOOLS__.attachPreact('10.22.0', options, {\n\t\t\tFragment,\n\t\t\tComponent\n\t\t});\n\t}\n}\n", "const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\n/**\n * Reset the history of which prop type warnings have been logged.\n */\nexport function resetPropWarnings() {\n\tloggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * Adapted from https://github.com/facebook/prop-types/blob/master/checkPropTypes.js\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n */\nexport function checkPropTypes(\n\ttypeSpecs,\n\tvalues,\n\tlocation,\n\tcomponentName,\n\tgetStack\n) {\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\n\t\tlet error;\n\t\ttry {\n\t\t\terror = typeSpecs[typeSpecName](\n\t\t\t\tvalues,\n\t\t\t\ttypeSpecName,\n\t\t\t\tcomponentName,\n\t\t\t\tlocation,\n\t\t\t\tnull,\n\t\t\t\tReactPropTypesSecret\n\t\t\t);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t\tif (error && !(error.message in loggedTypeFailures)) {\n\t\t\tloggedTypeFailures[error.message] = true;\n\t\t\tconsole.error(\n\t\t\t\t`Failed ${location} type: ${error.message}${\n\t\t\t\t\t(getStack && `\\n${getStack()}`) || ''\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t});\n}\n", "import { options, Fragment } from 'preact';\n\n/**\n * Get human readable name of the component/dom node\n * @param {import('./internal').VNode} vnode\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) {\n\t\treturn 'Fragment';\n\t} else if (typeof vnode.type == 'function') {\n\t\treturn vnode.type.displayName || vnode.type.name;\n\t} else if (typeof vnode.type == 'string') {\n\t\treturn vnode.type;\n\t}\n\n\treturn '#text';\n}\n\n/**\n * Used to keep track of the currently rendered `vnode` and print it\n * in debug messages.\n */\nlet renderStack = [];\n\n/**\n * Keep track of the current owners. An owner describes a component\n * which was responsible to render a specific `vnode`. This exclude\n * children that are passed via `props.children`, because they belong\n * to the parent owner.\n *\n * ```jsx\n * const Foo = props => <div>{props.children}</div> // div's owner is Foo\n * const Bar = props => {\n *   return (\n *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar\n *   )\n * }\n * ```\n *\n * Note: A `vnode` may be hoisted to the root scope due to compiler\n * optimiztions. In these cases the `_owner` will be different.\n */\nlet ownerStack = [];\n\n/**\n * Get the currently rendered `vnode`\n * @returns {import('./internal').VNode | null}\n */\nexport function getCurrentVNode() {\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\n}\n\n/**\n * If the user doesn't have `@babel/plugin-transform-react-jsx-source`\n * somewhere in his tool chain we can't print the filename and source\n * location of a component. In that case we just omit that, but we'll\n * print a helpful message to the console, notifying the user of it.\n */\nlet showJsxSourcePluginWarning = true;\n\n/**\n * Check if a `vnode` is a possible owner.\n * @param {import('./internal').VNode} vnode\n */\nfunction isPossibleOwner(vnode) {\n\treturn typeof vnode.type == 'function' && vnode.type != Fragment;\n}\n\n/**\n * Return the component stack that was captured up to this point.\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function getOwnerStack(vnode) {\n\tconst stack = [vnode];\n\tlet next = vnode;\n\twhile (next._owner != null) {\n\t\tstack.push(next._owner);\n\t\tnext = next._owner;\n\t}\n\n\treturn stack.reduce((acc, owner) => {\n\t\tacc += `  in ${getDisplayName(owner)}`;\n\n\t\tconst source = owner.__source;\n\t\tif (source) {\n\t\t\tacc += ` (at ${source.fileName}:${source.lineNumber})`;\n\t\t} else if (showJsxSourcePluginWarning) {\n\t\t\tconsole.warn(\n\t\t\t\t'Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.'\n\t\t\t);\n\t\t}\n\t\tshowJsxSourcePluginWarning = false;\n\n\t\treturn (acc += '\\n');\n\t}, '');\n}\n\n/**\n * Setup code to capture the component trace while rendering. Note that\n * we cannot simply traverse `vnode._parent` upwards, because we have some\n * debug messages for `this.setState` where the `vnode` is `undefined`.\n */\nexport function setupComponentStack() {\n\tlet oldDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldRoot = options._root;\n\tlet oldVNode = options.vnode;\n\tlet oldRender = options._render;\n\n\toptions.diffed = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.pop();\n\t\t}\n\t\trenderStack.pop();\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\trenderStack.push(vnode);\n\t\t}\n\t\tif (oldDiff) oldDiff(vnode);\n\t};\n\n\toptions._root = (vnode, parent) => {\n\t\townerStack = [];\n\t\tif (oldRoot) oldRoot(vnode, parent);\n\t};\n\n\toptions.vnode = vnode => {\n\t\tvnode._owner =\n\t\t\townerStack.length > 0 ? ownerStack[ownerStack.length - 1] : null;\n\t\tif (oldVNode) oldVNode(vnode);\n\t};\n\n\toptions._render = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.push(vnode);\n\t\t}\n\n\t\tif (oldRender) oldRender(vnode);\n\t};\n}\n", "import { checkPropTypes } from './check-props';\nimport { options, Component } from 'preact';\nimport {\n\tELEMENT_NODE,\n\tDOCUMENT_NODE,\n\tDOCUMENT_FRAGMENT_NODE\n} from './constants';\nimport {\n\tgetOwnerStack,\n\tsetupComponentStack,\n\tgetCurrentVNode,\n\tgetDisplayName\n} from './component-stack';\nimport { assign, isNaN } from './util';\n\nconst isWeakMapSupported = typeof WeakMap == 'function';\n\n/**\n * @param {import('./internal').VNode} vnode\n * @returns {Array<string>}\n */\nfunction getDomChildren(vnode) {\n\tlet domChildren = [];\n\n\tif (!vnode._children) return domChildren;\n\n\tvnode._children.forEach(child => {\n\t\tif (child && typeof child.type === 'function') {\n\t\t\tdomChildren.push.apply(domChildren, getDomChildren(child));\n\t\t} else if (child && typeof child.type === 'string') {\n\t\t\tdomChildren.push(child.type);\n\t\t}\n\t});\n\n\treturn domChildren;\n}\n\n/**\n * @param {import('./internal').VNode} parent\n * @returns {string}\n */\nfunction getClosestDomNodeParentName(parent) {\n\tif (!parent) return '';\n\tif (typeof parent.type == 'function') {\n\t\tif (parent._parent === null) {\n\t\t\tif (parent._dom !== null && parent._dom.parentNode !== null) {\n\t\t\t\treturn parent._dom.parentNode.localName;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t\treturn getClosestDomNodeParentName(parent._parent);\n\t}\n\treturn /** @type {string} */ (parent.type);\n}\n\nexport function initDebug() {\n\tsetupComponentStack();\n\n\tlet hooksAllowed = false;\n\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\tlet oldRender = options._render;\n\tlet oldCatchError = options._catchError;\n\tlet oldRoot = options._root;\n\tlet oldHook = options._hook;\n\tconst warnedComponents = !isWeakMapSupported\n\t\t? null\n\t\t: {\n\t\t\t\tuseEffect: new WeakMap(),\n\t\t\t\tuseLayoutEffect: new WeakMap(),\n\t\t\t\tlazyPropTypes: new WeakMap()\n\t\t  };\n\tconst deprecations = [];\n\n\toptions._catchError = (error, vnode, oldVNode, errorInfo) => {\n\t\tlet component = vnode && vnode._component;\n\t\tif (component && typeof error.then == 'function') {\n\t\t\tconst promise = error;\n\t\t\terror = new Error(\n\t\t\t\t`Missing Suspense. The throwing component was: ${getDisplayName(vnode)}`\n\t\t\t);\n\n\t\t\tlet parent = vnode;\n\t\t\tfor (; parent; parent = parent._parent) {\n\t\t\t\tif (parent._component && parent._component._childDidSuspend) {\n\t\t\t\t\terror = promise;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We haven't recovered and we know at this point that there is no\n\t\t\t// Suspense component higher up in the tree\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\terrorInfo = errorInfo || {};\n\t\t\terrorInfo.componentStack = getOwnerStack(vnode);\n\t\t\toldCatchError(error, vnode, oldVNode, errorInfo);\n\n\t\t\t// when an error was handled by an ErrorBoundary we will nonetheless emit an error\n\t\t\t// event on the window object. This is to make up for react compatibility in dev mode\n\t\t\t// and thus make the Next.js dev overlay work.\n\t\t\tif (typeof error.then != 'function') {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\toptions._root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined parent passed to render(), this is the second argument.\\n' +\n\t\t\t\t\t'Check if the element is available in the DOM/has the correct id.'\n\t\t\t);\n\t\t}\n\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE:\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tisValid = false;\n\t\t}\n\n\t\tif (!isValid) {\n\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a valid HTML node as a second argument to render.\tReceived ${parentNode} instead: render(<${componentName} />, ${parentNode});`\n\t\t\t);\n\t\t}\n\n\t\tif (oldRoot) oldRoot(vnode, parentNode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tlet { type } = vnode;\n\n\t\thooksAllowed = true;\n\n\t\tif (type === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined component passed to createElement()\\n\\n' +\n\t\t\t\t\t'You likely forgot to export your component or might have mixed up default and named imports' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (type != null && typeof type == 'object') {\n\t\t\tif (type._children !== undefined && type._dom !== undefined) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid type passed to createElement(): ${type}\\n\\n` +\n\t\t\t\t\t\t'Did you accidentally pass a JSX literal as JSX twice?\\n\\n' +\n\t\t\t\t\t\t`  let My${getDisplayName(vnode)} = ${serializeVNode(type)};\\n` +\n\t\t\t\t\t\t`  let vnode = <My${getDisplayName(vnode)} />;\\n\\n` +\n\t\t\t\t\t\t'This usually happens when you export a JSX literal and not the component.' +\n\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid type passed to createElement(): ' +\n\t\t\t\t\t(Array.isArray(type) ? 'array' : type)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref !== undefined &&\n\t\t\ttypeof vnode.ref != 'function' &&\n\t\t\ttypeof vnode.ref != 'object' &&\n\t\t\t!('$$typeof' in vnode) // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type == 'string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (\n\t\t\t\t\tkey[0] === 'o' &&\n\t\t\t\t\tkey[1] === 'n' &&\n\t\t\t\t\ttypeof vnode.props[key] != 'function' &&\n\t\t\t\t\tvnode.props[key] != null\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type == 'function' && vnode.type.propTypes) {\n\t\t\tif (\n\t\t\t\tvnode.type.displayName === 'Lazy' &&\n\t\t\t\twarnedComponents &&\n\t\t\t\t!warnedComponents.lazyPropTypes.has(vnode.type)\n\t\t\t) {\n\t\t\t\tconst m =\n\t\t\t\t\t'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';\n\t\t\t\ttry {\n\t\t\t\t\tconst lazyVNode = vnode.type();\n\t\t\t\t\twarnedComponents.lazyPropTypes.set(vnode.type, true);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + `Component wrapped in lazy() is ${getDisplayName(lazyVNode)}`\n\t\t\t\t\t);\n\t\t\t\t} catch (promise) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + \"We will log the wrapped component's name once it is loaded.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet values = vnode.props;\n\t\t\tif (vnode.type._forwarded) {\n\t\t\t\tvalues = assign({}, values);\n\t\t\t\tdelete values.ref;\n\t\t\t}\n\n\t\t\tcheckPropTypes(\n\t\t\t\tvnode.type.propTypes,\n\t\t\t\tvalues,\n\t\t\t\t'prop',\n\t\t\t\tgetDisplayName(vnode),\n\t\t\t\t() => getOwnerStack(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\tlet renderCount = 0;\n\tlet currentComponent;\n\toptions._render = vnode => {\n\t\tif (oldRender) {\n\t\t\toldRender(vnode);\n\t\t}\n\t\thooksAllowed = true;\n\n\t\tconst nextComponent = vnode._component;\n\t\tif (nextComponent === currentComponent) {\n\t\t\trenderCount++;\n\t\t} else {\n\t\t\trenderCount = 1;\n\t\t}\n\n\t\tif (renderCount >= 25) {\n\t\t\tthrow new Error(\n\t\t\t\t`Too many re-renders. This is limited to prevent an infinite loop ` +\n\t\t\t\t\t`which may lock up your browser. The component causing this is: ${getDisplayName(\n\t\t\t\t\t\tvnode\n\t\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\n\t\tcurrentComponent = nextComponent;\n\t};\n\n\toptions._hook = (comp, index, type) => {\n\t\tif (!comp || !hooksAllowed) {\n\t\t\tthrow new Error('Hook can only be invoked from render methods.');\n\t\t}\n\n\t\tif (oldHook) oldHook(comp, index, type);\n\t};\n\n\t// Ideally we'd want to print a warning once per component, but we\n\t// don't have access to the vnode that triggered it here. As a\n\t// compromise and to avoid flooding the console with warnings we\n\t// print each deprecation warning only once.\n\tconst warn = (property, message) => ({\n\t\tget() {\n\t\t\tconst key = 'get' + property + message;\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\n\t\t\t\tdeprecations.push(key);\n\t\t\t\tconsole.warn(`getting vnode.${property} is deprecated, ${message}`);\n\t\t\t}\n\t\t},\n\t\tset() {\n\t\t\tconst key = 'set' + property + message;\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\n\t\t\t\tdeprecations.push(key);\n\t\t\t\tconsole.warn(`setting vnode.${property} is not allowed, ${message}`);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\tconst deprecatedProto = Object.create({}, deprecatedAttributes);\n\n\toptions.vnode = vnode => {\n\t\tconst props = vnode.props;\n\t\tif (\n\t\t\tvnode.type !== null &&\n\t\t\tprops != null &&\n\t\t\t('__source' in props || '__self' in props)\n\t\t) {\n\t\t\tconst newProps = (vnode.props = {});\n\t\t\tfor (let i in props) {\n\t\t\t\tconst v = props[i];\n\t\t\t\tif (i === '__source') vnode.__source = v;\n\t\t\t\telse if (i === '__self') vnode.__self = v;\n\t\t\t\telse newProps[i] = v;\n\t\t\t}\n\t\t}\n\n\t\t// eslint-disable-next-line\n\t\tvnode.__proto__ = deprecatedProto;\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\tconst { type, _parent: parent } = vnode;\n\t\t// Check if the user passed plain objects as children. Note that we cannot\n\t\t// move this check into `options.vnode` because components can receive\n\t\t// children in any shape they want (e.g.\n\t\t// `<MyJSONFormatter>{{ foo: 123, bar: \"abc\" }}</MyJSONFormatter>`).\n\t\t// Putting this check in `options.diffed` ensures that\n\t\t// `vnode._children` is set and that we only validate the children\n\t\t// that were actually rendered.\n\t\tif (vnode._children) {\n\t\t\tvnode._children.forEach(child => {\n\t\t\t\tif (typeof child === 'object' && child && child.type === undefined) {\n\t\t\t\t\tconst keys = Object.keys(child).join(',');\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Objects are not valid as a child. Encountered an object with the keys {${keys}}.` +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (vnode._component === currentComponent) {\n\t\t\trenderCount = 0;\n\t\t}\n\n\t\tif (\n\t\t\ttypeof type === 'string' &&\n\t\t\t(isTableElement(type) ||\n\t\t\t\ttype === 'p' ||\n\t\t\t\ttype === 'a' ||\n\t\t\t\ttype === 'button')\n\t\t) {\n\t\t\t// Avoid false positives when Preact only partially rendered the\n\t\t\t// HTML tree. Whilst we attempt to include the outer DOM in our\n\t\t\t// validation, this wouldn't work on the server for\n\t\t\t// `preact-render-to-string`. There we'd otherwise flood the terminal\n\t\t\t// with false positives, which we'd like to avoid.\n\t\t\tlet domParentName = getClosestDomNodeParentName(parent);\n\t\t\tif (domParentName !== '') {\n\t\t\t\tif (\n\t\t\t\t\ttype === 'table' &&\n\t\t\t\t\t// Tables can be nested inside each other if it's inside a cell.\n\t\t\t\t\t// See https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced#nesting_tables\n\t\t\t\t\tdomParentName !== 'td' &&\n\t\t\t\t\tisTableElement(domParentName)\n\t\t\t\t) {\n\t\t\t\t\tconsole.log(domParentName, parent._dom);\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <table> should not have a table-node parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\t(type === 'thead' || type === 'tfoot' || type === 'tbody') &&\n\t\t\t\t\tdomParentName !== 'table'\n\t\t\t\t) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\ttype === 'tr' &&\n\t\t\t\t\tdomParentName !== 'thead' &&\n\t\t\t\t\tdomParentName !== 'tfoot' &&\n\t\t\t\t\tdomParentName !== 'tbody'\n\t\t\t\t) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (type === 'td' && domParentName !== 'tr') {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <td> should have a <tr> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (type === 'th' && domParentName !== 'tr') {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <th> should have a <tr>.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (type === 'p') {\n\t\t\t\tlet illegalDomChildrenTypes = getDomChildren(vnode).filter(childType =>\n\t\t\t\t\tILLEGAL_PARAGRAPH_CHILD_ELEMENTS.test(childType)\n\t\t\t\t);\n\t\t\t\tif (illegalDomChildrenTypes.length) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of paragraph. Your <p> should not have ' +\n\t\t\t\t\t\t\tillegalDomChildrenTypes.join(', ') +\n\t\t\t\t\t\t\t'as child-elements.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (type === 'a' || type === 'button') {\n\t\t\t\tif (getDomChildren(vnode).indexOf(type) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`Improper nesting of interactive content. Your <${type}>` +\n\t\t\t\t\t\t\t` should not have other ${type === 'a' ? 'anchor' : 'button'}` +\n\t\t\t\t\t\t\t' tags as child-elements.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thooksAllowed = false;\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\n\t\tif (vnode._children != null) {\n\t\t\tconst keys = [];\n\t\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\t\tconst child = vnode._children[i];\n\t\t\t\tif (!child || child.key == null) continue;\n\n\t\t\t\tconst key = child.key;\n\t\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Break early to not spam the console\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\tif (vnode._component != null && vnode._component.__hooks != null) {\n\t\t\t// Validate that none of the hooks in this component contain arguments that are NaN.\n\t\t\t// This is a common mistake that can be hard to debug, so we want to catch it early.\n\t\t\tconst hooks = vnode._component.__hooks._list;\n\t\t\tif (hooks) {\n\t\t\t\tfor (let i = 0; i < hooks.length; i += 1) {\n\t\t\t\t\tconst hook = hooks[i];\n\t\t\t\t\tif (hook._args) {\n\t\t\t\t\t\tfor (let j = 0; j < hook._args.length; j++) {\n\t\t\t\t\t\t\tconst arg = hook._args[j];\n\t\t\t\t\t\t\tif (isNaN(arg)) {\n\t\t\t\t\t\t\t\tconst componentName = getDisplayName(vnode);\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index ${i} in component ${componentName} was called with NaN.`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst setState = Component.prototype.setState;\nComponent.prototype.setState = function (update, callback) {\n\tif (this._vnode == null) {\n\t\t// `this._vnode` will be `null` during componentWillMount. But it\n\t\t// is perfectly valid to call `setState` during cWM. So we\n\t\t// need an additional check to verify that we are dealing with a\n\t\t// call inside constructor.\n\t\tif (this.state == null) {\n\t\t\tconsole.warn(\n\t\t\t\t`Calling \"this.setState\" inside the constructor of a component is a ` +\n\t\t\t\t\t`no-op and might be a bug in your application. Instead, set ` +\n\t\t\t\t\t`\"this.state = {}\" directly.\\n\\n${getOwnerStack(getCurrentVNode())}`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn setState.call(this, update, callback);\n};\n\nfunction isTableElement(type) {\n\treturn (\n\t\ttype === 'table' ||\n\t\ttype === 'tfoot' ||\n\t\ttype === 'tbody' ||\n\t\ttype === 'thead' ||\n\t\ttype === 'td' ||\n\t\ttype === 'tr' ||\n\t\ttype === 'th'\n\t);\n}\n\nconst ILLEGAL_PARAGRAPH_CHILD_ELEMENTS =\n\t/^(address|article|aside|blockquote|details|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|main|menu|nav|ol|p|pre|search|section|table|ul)$/;\n\nconst forceUpdate = Component.prototype.forceUpdate;\nComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.forceUpdate\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application.\\n\\n${getOwnerStack(\n\t\t\t\t\tgetCurrentVNode()\n\t\t\t\t)}`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.forceUpdate\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\n\t\t);\n\t}\n\treturn forceUpdate.call(this, callback);\n};\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tfor (let prop in props) {\n\t\tif (props.hasOwnProperty(prop) && prop !== 'children') {\n\t\t\tlet value = props[prop];\n\n\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\tif (typeof value == 'function') {\n\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t}\n\n\t\t\tvalue =\n\t\t\t\tObject(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${\n\t\tchildren && children.length ? '>..</' + name + '>' : ' />'\n\t}`;\n}\n", "export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n", "/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\nexport function isNaN(value) {\n\treturn value !== value;\n}\n", "import { initDebug } from './debug';\nimport 'preact/devtools';\n\ninitDebug();\n\nexport { resetPropWarnings } from './check-props';\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet EMPTY = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingValue = EMPTY;\n\t\t\t\thookItem._nextValue = hookItem._pendingArgs = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\tif (hookItem._pendingValue !== EMPTY) {\n\t\t\t\thookItem._value = hookItem._pendingValue;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t\thookItem._pendingValue = EMPTY;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({ _pendingValue: EMPTY });\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._pendingValue = factory();\n\t\tstate._pendingArgs = args;\n\t\tstate._factory = factory;\n\t\treturn state._pendingValue;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "/**\n * A vertext id format is a string with format: `type+id`.\n *\n * Examples: `pl+python`, `person+guido`, `paradigm+oop`, etc.\n *\n * See {@link PVIDAny} for the matching pattern.\n */\nexport type VID<T extends string> = `${T}+${string}`;\n\n/**\n * An alias such that we can say: VID<Any> to match any vertex id.\n */\nexport type Any = string;\n\n/**\n * An alias for the most generic vertex id.\n */\nexport type VID_Any = VID<Any>;\n\nconst NON_PLUS_ID_CHARS = \"[a-z-0-9\\\\-\\\\(\\\\)\\\\[\\\\]_.]+$\";\nconst NON_PLUS_ID_PATTERN = new RegExp(NON_PLUS_ID_CHARS);\n\nexport function validChars(s: string): boolean {\n  return NON_PLUS_ID_PATTERN.test(s);\n}\n\nexport function isAnyVID(s: string): s is VID<Any> {\n  const parts = s.split(\"+\");\n  return parts.length === 2 && validChars(parts[0]) && validChars(parts[1]);\n}\n\nexport function vIDPattern(vtype: string): RegExp {\n  if (!validChars(vtype)) throw new Error(`'${vtype}' is not valid as a vid prefix.`);\n  return new RegExp(`^${vtype}\\\\+${NON_PLUS_ID_CHARS}`);\n}\n", "import { validChars } from \"./vertex\";\nimport type { VertexTable } from \"./vertex_table\";\n\n/** Extract the components off of an edge key. */\nexport function parseEdgeKey(eid: string): { type: string; from: string; to: string } {\n  const parts = eid.split(\"~\");\n  return { type: parts[0], from: parts[1], to: parts[2] };\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: We don't care what kind of data the vertices have.\ntype _T_Any_V_Data = any;\n\n/**\n * Stores edges between vertices.\n */\nexport class EdgeTable<VID_From extends string, VID_To extends string, T_EdgeData>\n  implements Iterable<[string, T_EdgeData]>\n{\n  readonly #edge: Map<string, T_EdgeData> = new Map();\n\n  readonly #adjFrom: Map<string, Set<string>> = new Map();\n  readonly #adjTo: Map<string, Set<string>> = new Map();\n\n  constructor(\n    public readonly type: string,\n    public readonly fromTable: VertexTable<VID_From, _T_Any_V_Data>,\n    public readonly toTable: VertexTable<VID_To, _T_Any_V_Data>,\n  ) {\n    if (!validChars(type)) throw new Error(`'${type}' is not valid as an edge type.`);\n  }\n\n  /**\n   * A single graph should not use two edge tables with the same key,\n   * otherwise there could be edges with duplicate keys.\n   */\n  get tableKey(): string {\n    const t = this.type;\n    const from = this.fromTable.vtype;\n    const to = this.toTable.vtype;\n    return `${t}~${from}~${to}`;\n  }\n\n  set(from: VID_From, to: VID_To, value: T_EdgeData): this {\n    const kft = this.#edgeKey(from, to);\n    this.#edge.set(kft, value);\n    this.#updateAdjacent(from, to, \"add\");\n    return this;\n  }\n\n  get(from: VID_From, to: VID_To): T_EdgeData | undefined {\n    if (!this.validParams(from, to)) throw new Error(`Invalid id(s) in edge: ${from} -> ${to}.`);\n    return this.#edge.get(this.#edgeKey(from, to));\n  }\n\n  has(from: VID_From, to: VID_To): boolean {\n    if (!this.validParams(from, to)) return false;\n    return this.#edge.has(this.#edgeKey(from, to));\n  }\n\n  delete(from: VID_From, to: VID_To): boolean {\n    this.#updateAdjacent(from, to, \"delete\");\n    return this.#edge.delete(this.#edgeKey(from, to));\n  }\n\n  /** Connect without setting any edge data. */\n  connect(from: VID_From, to: VID_To): Partial<T_EdgeData> {\n    const key = this.#edgeKey(from, to);\n    let edata = this.#edge.get(key);\n    if (!edata) {\n      this.#edge.set(key, (edata = {} as T_EdgeData));\n    }\n    this.#updateAdjacent(from, to, \"add\");\n    return edata as Partial<T_EdgeData>;\n  }\n\n  merge(from: VID_From, to: VID_To, value: Partial<T_EdgeData>): Partial<T_EdgeData> {\n    const key = this.#edgeKey(from, to);\n    this.#updateAdjacent(from, to, \"add\");\n\n    if (!this.#edge.has(key)) {\n      this.#edge.set(key, value as T_EdgeData);\n      return value;\n    }\n\n    const existing = this.#edge.get(key) as Partial<T_EdgeData>;\n    Object.assign(existing, value);\n    return existing;\n  }\n\n  validParams(from: VID_From, to: VID_To): boolean {\n    return this.fromTable.validParams(from) && this.toTable.validParams(to);\n  }\n\n  #edgeKey(from: string, to: string): string {\n    return `${from}~${to}`;\n  }\n\n  /** Yields keys parseable with {@link parseEdgeKey} and the data of the edge. */\n  *[Symbol.iterator](): IterableIterator<[string, T_EdgeData]> {\n    for (const [key, edge] of this.#edge) {\n      yield [`${this.type}~${key}`, edge];\n    }\n  }\n\n  #updateAdjacent(from: VID_From, to: VID_To, operation: \"add\" | \"delete\") {\n    if (!this.validParams(from, to)) throw new Error(`Invalid id(s) in edge: ${from} -> ${to}`);\n\n    if (!this.#adjFrom.has(from)) this.#adjFrom.set(from, new Set());\n    if (!this.#adjTo.has(to)) this.#adjTo.set(to, new Set());\n\n    if (operation === \"add\") {\n      this.#adjFrom.get(from)?.add(to);\n      this.#adjTo.get(to)?.add(from);\n    } else {\n      this.#adjFrom.get(from)?.delete(to);\n      this.#adjTo.get(to)?.delete(from);\n    }\n  }\n\n  /** Number of edges. */\n  public get size(): number {\n    return this.#edge.size;\n  }\n\n  adjacentFrom(from: VID_From): Set<VID_To> {\n    return (this.#adjFrom.get(from) ?? new Set()) as Set<VID_To>;\n  }\n\n  adjacentTo(to: VID_To): Set<VID_From> {\n    return (this.#adjTo.get(to) ?? new Set()) as Set<VID_From>;\n  }\n\n  toJSON(): Record<string, T_EdgeData> {\n    const result: Record<string, T_EdgeData> = {};\n    for (const [key, value] of this.#edge.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  loadJSON(edata: Record<string, T_EdgeData>) {\n    for (const [kft, value] of Object.entries(edata)) {\n      const [from, to] = kft.split(\"~\");\n      this.#updateAdjacent(from as VID_From, to as VID_To, \"add\");\n      this.#edge.set(kft, value);\n    }\n  }\n}\n", "import type { NN_Partial } from \"../util\";\nimport { vIDPattern } from \"./vertex\";\n\n/**\n * Containers for vertices.\n */\nexport class VertexTable<T_VID extends string, T_VData> implements Iterable<[T_VID, T_VData]> {\n  #vdata = new Map<T_VID, T_VData>();\n\n  public readonly vidPattern: RegExp;\n\n  constructor(readonly vtype: string) {\n    this.vidPattern = vIDPattern(vtype);\n  }\n\n  set(key: T_VID, value: T_VData): this {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key} (pattern: ${this.vidPattern})`);\n    this.#vdata.set(key, value);\n    return this;\n  }\n\n  get(key: T_VID): T_VData | undefined {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key}`);\n    return this.#vdata.get(key);\n  }\n\n  has(key: T_VID): boolean {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key}`);\n    return this.#vdata.has(key);\n  }\n\n  delete(key: T_VID): boolean {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key}`);\n    return this.#vdata.delete(key);\n  }\n\n  /**\n   * Declares there's an entry for the key:\n   * - If the key is already in store, it will be left unchanged.\n   * - If the key is not in store, it will be set to an empty object.\n   * - Returns the data for the key.\n   */\n  declare(key: T_VID): NN_Partial<T_VData> {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key}`);\n    let v_data = this.#vdata.get(key);\n    if (v_data === undefined) {\n      v_data = {} as T_VData;\n      this.#vdata.set(key, v_data);\n    }\n    return v_data as NN_Partial<T_VData>;\n  }\n\n  merge(key: T_VID, value: T_VData): NN_Partial<T_VData> {\n    if (!this.validParams(key)) throw new Error(`invalid key: ${key}`);\n\n    if (!this.#vdata.has(key)) {\n      this.#vdata.set(key, {} as T_VData);\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: it is ok.\n    const vdata = Object.assign(this.#vdata.get(key) as any, value);\n\n    return vdata as NN_Partial<T_VData>;\n  }\n\n  validParams(vid: string): boolean {\n    return this.vidPattern.test(vid);\n  }\n\n  keys(): IterableIterator<T_VID> {\n    return this.#vdata.keys();\n  }\n\n  [Symbol.iterator](): IterableIterator<[T_VID, T_VData]> {\n    return this.#vdata.entries();\n  }\n\n  toJSON(): Record<string, T_VData> {\n    const vdata: Record<string, T_VData> = {};\n    for (const [vid, data] of this.#vdata) {\n      vdata[vid] = data;\n    }\n    return vdata;\n  }\n\n  loadJSON(vdata: Record<string, T_VData>) {\n    for (const [vid, data] of Object.entries(vdata).sort()) {\n      this.set(vid as T_VID, data);\n    }\n  }\n\n  /** Number of vertices. */\n  public get size(): number {\n    return this.#vdata.size;\n  }\n}\n", "import { EdgeTable } from \"./edge_table\";\nimport { VertexTable } from \"./vertex_table\";\n\n// biome-ignore lint/suspicious/noExplicitAny: We need to store any kind vertex or edge.\ntype _Any = any;\n\ntype SerializedGraph = {\n  vtables: Record<string, _Any>;\n  etables: Record<string, _Any>;\n};\n\n/**\n * A Graph consists of set of Vertices and Edges.\n */\nexport class Graph {\n  readonly vtables: Map<string, VertexTable<_Any, _Any>> = new Map();\n  readonly etables: Map<string, EdgeTable<_Any, _Any, _Any>> = new Map();\n\n  protected v_table<T_VData, T_VId extends string>(type: string): VertexTable<T_VId, T_VData> {\n    const table = new VertexTable<T_VId, T_VData>(type);\n    if (this.vtables.has(type)) throw new Error(`Table already defined: ${table.vtype}`);\n    this.vtables.set(table.vtype, table);\n    return table;\n  }\n\n  protected e_table<T_EdgeData, T_VId_From extends string, T_VId_To extends string>(\n    type: string,\n    from: VertexTable<T_VId_From, _Any>,\n    to: VertexTable<T_VId_To, _Any>,\n  ): EdgeTable<T_VId_From, T_VId_To, T_EdgeData> {\n    if (type.length === 0) throw new Error(\"Type cannot be empty.\");\n    const table = new EdgeTable<T_VId_From, T_VId_To, _Any>(type, from, to);\n    if (this.etables.has(table.tableKey)) throw new Error(`Table already defined: ${table.tableKey}`);\n    this.etables.set(table.tableKey, table);\n    return table;\n  }\n\n  get numEdges(): number {\n    let count = 0;\n    for (const et of this.etables.values()) {\n      count += et.size;\n    }\n    return count;\n  }\n\n  get numVertices(): number {\n    let count = 0;\n    for (const vt of this.vtables.values()) {\n      count += vt.size;\n    }\n    return count;\n  }\n\n  *allVertices(): IterableIterator<[string, _Any]> {\n    for (const vt of this.vtables.values()) {\n      yield* vt;\n    }\n  }\n\n  *allEdges(): IterableIterator<[string, _Any]> {\n    for (const et of this.etables.values()) {\n      yield* et;\n    }\n  }\n\n  toJSON(): SerializedGraph {\n    const graph = { vtables: {}, etables: {} };\n\n    for (const [key, val] of this.vtables) {\n      console.log(\"Serializing vertex table:\", key);\n      graph.vtables[key] = val.toJSON();\n    }\n\n    for (const [key, val] of this.etables) {\n      console.log(\"Serializing edge table:\", key);\n      graph.etables[key] = val.toJSON();\n    }\n\n    return graph;\n  }\n\n  loadJSON(data: SerializedGraph) {\n    for (const [vtype, vdata] of Object.entries(data.vtables)) {\n      const vt = this.vtables.get(vtype);\n      if (!vt) throw new Error(`Vertex table not found: ${vtype}`);\n      vt.loadJSON(vdata);\n    }\n\n    for (const [etype, edata] of Object.entries(data.etables)) {\n      const et = this.etables.get(etype);\n      if (!et) throw new Error(`Edge table not found: ${etype}`);\n      et.loadJSON(edata);\n    }\n  }\n}\n", "/**\n * Type assertion for {@link RegExp}\n */\nexport function isRegExp(val: unknown): val is RegExp {\n  return Object.prototype.toString.call(val) === \"[object RegExp]\";\n}\n\n/**\n * Convert the string to something usable as vertex id.\n */\nexport function toAlphaNum(s: string) {\n  // biome-ignore format: it's artisanally formatted :-p.\n  let result = s\n    .trim()\n    .toLowerCase()\n    .normalize(\"NFD\")\n    // biome-ignore lint/suspicious/noMisleadingCharacterClass: removes accents/diacritics.\n    .replaceAll(/[\\u0300-\\u036f]/g, \"\");\n\n  if (result.startsWith(\"*\")) result = `star-${result.slice(1)}`;\n  if (result.startsWith(\"+\")) result = `p${result.slice(1)}`;\n\n  result = result\n    .replaceAll(\" \", \"-\")\n    .replaceAll(/\\s+/g, \" \")\n    .replaceAll(/_/g, \"-\")\n    .replaceAll(/\\-\\-+/g, \"-\")\n\n    .split(/[\\*]/g)\n    .join(\"-star\")\n    .split(/\\#/g)\n    .join(\"-sharp\")\n    .split(/\\+/g)\n    .join(\"p\")\n    .split(/\\//g)\n    .join(\"-slash\")\n    .split(/\\\\/g)\n    .join(\"-backslash\")\n\n    .replaceAll(/[\\/\\:]/g, \"-\")\n    .replaceAll(/[^a-zA-Z0-9\\.\\(\\)\\[\\]_\\-]/g, \"-\");\n\n  return result;\n}\n\n/**\n * Return a caller `line:no` for debugging.\n * @param match find the first line in the backtrace that contains this string.\n * @param dontMatch if given, the line in the backtrace must not contain this string.\n */\nexport function caller(match: string, dontMatch = \"\"): string {\n  // https://stackoverflow.com/a/3806596/855105\n  function getErrorObject() {\n    try {\n      throw Error(\"\");\n    } catch (err) {\n      return err;\n    }\n  }\n  const err = getErrorObject();\n\n  const caller_line = err.stack\n    .split(\"\\n\")\n    .find((line: string) => line.includes(match) && (!dontMatch || !line.includes(dontMatch)));\n\n  if (!caller_line) return \"unknown\";\n  const index = caller_line.indexOf(\"at \");\n  const clean = caller_line.slice(index + 2, caller_line.length);\n  return clean.trim();\n}\n\n/**\n * True if obj:\n * - is number\n * - is non blank string\n * - is non empty array\n * - obj has any key where obj[key] is truthy.\n */\n// biome-ignore lint/suspicious/noExplicitAny: Can test any object.\nexport function blank(obj: any): boolean {\n  if (typeof obj === \"number\") return false;\n  if (typeof obj === \"string\") return !obj.trim();\n  if (Array.isArray(obj)) return obj.length === 0;\n\n  for (const key of Object.getOwnPropertyNames(obj)) {\n    if (!blank(obj[key])) return false;\n  }\n\n  return true;\n}\n\n/** (Shallow) Remove keys from object which are blank or empty arrays, sorts arrays. */\n// biome-ignore lint/suspicious/noExplicitAny: Can tidy any object.\nexport function tidy(data: any): any {\n  for (const [key, val] of Object.entries(data)) {\n    if (Array.isArray(val)) {\n      if (val.length === 0) delete data[key];\n      else val.sort();\n    } else if (blank(val)) delete data[key];\n  }\n  return data;\n}\n\n/**\n * We use arrays as we want plain old JS data in vertices,\n * but sometimes we want the arrays to act like sets.\n */\nexport function arrayMerge<T>(\n  target: T[],\n  newData: T[],\n  similar: (l1: T, l2: T) => boolean,\n  onDuplicate: (prevElem: T, newElem: T) => void,\n) {\n  for (const newElem of newData) {\n    const prevElem = target.find((elem: T) => similar(elem, newElem));\n    if (prevElem) {\n      onDuplicate(prevElem, newElem);\n    } else {\n      target.push(newElem);\n    }\n  }\n}\n\nexport function toggle<T>(target: Set<T>, item: T): Set<T> {\n  target.has(item) ? target.delete(item) : target.add(item);\n  return target;\n}\n\nexport function addAll<T>(target: { add(elem: T): void }, values: Iterable<T>): typeof target {\n  for (const elem of values) target.add(elem);\n  return target;\n}\n\nexport function hasAll<T>(container: { has(elem: T): boolean }, values: Iterable<T>): boolean {\n  for (const v of values) if (!container.has(v)) return false;\n  return true;\n}\n\nexport function hasAny<T>(container: { has(elem: T): boolean }, values: Iterable<T>): boolean {\n  for (const v of values) if (container.has(v)) return true;\n  return false;\n}\n", "import { arrayMerge, caller } from \"../util\";\nimport type { PlangsGraph } from \"./graph\";\nimport type {\n  E_DialectOf,\n  E_HasLicense,\n  E_Implements,\n  E_LInfluencedL,\n  E_PersonPlang,\n  E_PlangPara,\n  E_PlangTsys,\n  E_SupportsPlatf,\n  Image,\n  Link,\n  Release,\n  Scoping,\n  VID_License,\n  VID_Paradigm,\n  VID_Person,\n  VID_Plang,\n  VID_Platform,\n  VID_TypeSystem,\n  V_Base,\n  V_License,\n  V_Paradigm,\n  V_Person,\n  V_Plang,\n  V_Platform,\n  V_TypeSystem,\n} from \"./entities\";\n\nexport class PlangBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_Plang,\n  ) {\n    g.v_plang.declare(vid);\n  }\n\n  merge(data: Partial<V_Plang>): this {\n    const prev = { ...this.g.v_plang.get(this.vid) }; // Save a _copy_ before merging.\n    const upd = this.g.v_plang.merge(this.vid, data);\n\n    mergeExtensions(upd, prev);\n    mergeImages(upd, prev);\n    mergeReleases(upd, prev);\n    mergeScoping(upd, prev);\n    mergeWebsites(upd, prev);\n\n    return this;\n  }\n\n  addDialect(other: VID_Plang, data: Partial<E_DialectOf>): this {\n    this.g.e_dialect_of.merge(other, this.vid, data);\n    return this;\n  }\n\n  addDialects(others: VID_Plang[]): this {\n    for (const other of others) this.g.e_dialect_of.connect(other, this.vid);\n    return this;\n  }\n\n  addImplementation(other: VID_Plang, data: Partial<E_Implements>): this {\n    this.g.e_implements.merge(other, this.vid, data);\n    return this;\n  }\n\n  addImplementations(others: VID_Plang[]): this {\n    for (const other of others) this.g.e_implements.connect(other, this.vid);\n    return this;\n  }\n\n  addInfluence(other: VID_Plang, data: Partial<E_LInfluencedL>): this {\n    this.g.e_l_influenced_l.merge(other, this.vid, data);\n    return this;\n  }\n\n  addInfluences(others: VID_Plang[]): this {\n    for (const other of others) this.g.e_l_influenced_l.connect(other, this.vid);\n    return this;\n  }\n\n  addLicense(other: VID_License, data: Partial<E_HasLicense>): this {\n    this.g.e_has_license.merge(this.vid, other, data);\n    return this;\n  }\n\n  addLicenses(others: VID_License[]): this {\n    for (const other of others ?? []) this.g.e_has_license.connect(this.vid, other);\n    return this;\n  }\n\n  addParadigm(other: VID_Paradigm, data: Partial<E_PlangPara>): this {\n    this.g.e_plang_para.merge(this.vid, other, data);\n    return this;\n  }\n\n  addParadigms(others: VID_Paradigm[]): this {\n    for (const otherVid of others ?? []) this.g.e_plang_para.connect(this.vid, otherVid);\n    return this;\n  }\n\n  addPerson(other: VID_Person, data: Partial<E_PersonPlang>): this {\n    this.g.e_person_plang.merge(other, this.vid, data);\n    return this;\n  }\n\n  addPeople(others: VID_Person[]): this {\n    for (const other of others ?? []) this.g.e_person_plang.connect(other, this.vid);\n    return this;\n  }\n\n  addPlatform(other: VID_Platform, data: Partial<E_SupportsPlatf>): this {\n    this.g.e_supports_platf.merge(this.vid, other, data);\n    return this;\n  }\n\n  addPlatforms(others: VID_Platform[]): this {\n    for (const other of others) this.g.e_supports_platf.connect(this.vid, other);\n    return this;\n  }\n\n  addTypeSystem(other: VID_TypeSystem, data: Partial<E_PlangTsys>): this {\n    this.g.e_plang_tsys.merge(this.vid, other, data);\n    return this;\n  }\n\n  addTypeSystems(others: VID_TypeSystem[]): this {\n    for (const other of others ?? []) this.g.e_plang_tsys.connect(this.vid, other);\n    return this;\n  }\n}\n\nexport class LicenseBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_License,\n  ) {\n    g.v_license.declare(this.vid);\n  }\n\n  merge(data: Partial<V_License>): this {\n    const prev = { ...this.g.v_license.get(this.vid) };\n    const upd = this.g.v_license.merge(this.vid, data);\n    mergeWebsites(upd, prev);\n    return this;\n  }\n}\n\nexport class ParadigmBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_Paradigm,\n  ) {\n    g.v_paradigm.declare(this.vid);\n  }\n\n  merge(data: Partial<V_Paradigm>): this {\n    const prev = { ...this.g.v_paradigm.get(this.vid) };\n    const upd = this.g.v_paradigm.merge(this.vid, data);\n    mergeWebsites(upd, prev);\n    return this;\n  }\n}\n\nexport class PersonBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_Person,\n  ) {\n    g.v_person.declare(this.vid);\n  }\n\n  merge(data: Partial<V_Person>): this {\n    const prev = { ...this.g.v_person.get(this.vid) };\n    const upd = this.g.v_person.merge(this.vid, data);\n    mergeWebsites(upd, prev);\n    return this;\n  }\n}\n\nexport class PlatformBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_Platform,\n  ) {\n    g.v_platform.declare(this.vid);\n  }\n\n  merge(data: Partial<V_Platform>): this {\n    const prev = { ...this.g.v_platform.get(this.vid) };\n    const upd = this.g.v_platform.merge(this.vid, data);\n    mergeWebsites(upd, prev);\n    return this;\n  }\n}\n\nexport class TypeSysBuilder {\n  constructor(\n    readonly g: PlangsGraph,\n    readonly vid: VID_TypeSystem,\n  ) {\n    g.v_tsystem.declare(this.vid);\n  }\n\n  merge(data: Partial<V_TypeSystem>): this {\n    const prev = { ...this.g.v_tsystem.get(this.vid) };\n    const upd = this.g.v_tsystem.merge(this.vid, data);\n    mergeWebsites(upd, prev);\n    return this;\n  }\n}\n\n//--------------------------------------------------------------------------------\n\nconst _CALLER_PATTERN = \"definitions\";\n\ntype Attr<T, Key extends keyof T> = Partial<Pick<T, Key>>;\n\nfunction mergeWebsites(target: Attr<V_Base, \"websites\">, newData: Attr<V_Base, \"websites\">) {\n  if (newData.websites === undefined) return;\n  arrayMerge(\n    (target.websites ??= []),\n    newData.websites,\n    (l1: Link, l2: Link) => l1.href === l2.href,\n    (prevLink: Link, newLink: Link) => {\n      console.warn(`${caller(_CALLER_PATTERN)}: Duplicate Link: ${JSON.stringify({ prevLink, newLink })}`);\n    },\n  );\n}\n\nfunction mergeImages(target: Attr<V_Plang, \"images\">, newData: Attr<V_Plang, \"images\">) {\n  if (newData.images === undefined) return;\n  arrayMerge(\n    (target.images ??= []),\n    newData.images,\n    (img1: Image, img2: Image) => img1.url === img2.url,\n    (prevImage: Image, newImage: Image) => {\n      console.warn(`${caller(_CALLER_PATTERN)}: Duplicate Image: ${JSON.stringify({ prevImage, newImage })}`);\n      prevImage.width ??= newImage.width;\n      prevImage.height ??= newImage.height;\n    },\n  );\n}\n\nfunction mergeReleases(target: Attr<V_Plang, \"releases\">, newData: Attr<V_Plang, \"releases\">) {\n  if (!newData.releases) return;\n  arrayMerge(\n    (target.releases ??= []),\n    newData.releases,\n    (rel1: Release, rel2: Release) => rel1.version === rel2.version && rel1.date === rel2.date,\n    (prevRel: Release, newRel: Release) => {\n      console.warn(`${caller(_CALLER_PATTERN)}: Duplicate Release: ${JSON.stringify({ prevRel, newRel })}`);\n    },\n  );\n}\n\nfunction mergeScoping(target: Attr<V_Plang, \"scoping\">, newData: Attr<V_Plang, \"scoping\">) {\n  if (!newData.scoping) return;\n  arrayMerge(\n    (target.scoping ??= []),\n    newData.scoping,\n    (scope1: Scoping, scope2: Scoping) => scope1 === scope2,\n    (prevScope, newScope) => {\n      console.warn(`${caller(_CALLER_PATTERN)}: Duplicate Scope: ${newScope}`);\n    },\n  );\n}\n\nfunction mergeExtensions(target: Attr<V_Plang, \"extensions\">, newData: Attr<V_Plang, \"extensions\">) {\n  if (newData.extensions === undefined) return;\n  arrayMerge(\n    (target.extensions ??= []),\n    newData.extensions,\n    (ext1, ext2) => ext1 === ext2,\n    (prevExt, newExt) => {\n      console.warn(`${caller(_CALLER_PATTERN)}: Duplicate Extension: ${newExt}`);\n    },\n  );\n}\n", "import { Graph } from \"../graphs/graph\";\nimport {\n  LicenseBuilder,\n  ParadigmBuilder,\n  PersonBuilder,\n  PlangBuilder,\n  PlatformBuilder,\n  TypeSysBuilder,\n} from \"./builders\";\nimport type {\n  E_DialectOf,\n  E_HasLicense,\n  E_Implements,\n  E_LInfluencedL,\n  E_PersonPlang,\n  E_PlangPara,\n  E_PlangTsys,\n  E_SupportsPlatf,\n  VID_License,\n  VID_Paradigm,\n  VID_Person,\n  VID_Plang,\n  VID_Platform,\n  VID_TypeSystem,\n  V_License,\n  V_Paradigm,\n  V_Person,\n  V_Plang,\n  V_Platform,\n  V_TypeSystem,\n} from \"./entities\";\n\n/**\n * Collection of related edge and vertex tables.\n *\n * These repetitive definitions follow some simple conventions,\n * are tightly coupled with the schemas in `schemas.ts`,\n * and could potentially be auto-generated in the future.\n */\n// biome-ignore format: it's artisanally formatted :-p.\nexport class PlangsGraph extends Graph {\n  // Vertex tables.\n  readonly v_license = this.v_table<Partial<V_License>, VID_License>(\"lic\",);\n  readonly v_paradigm = this.v_table<Partial<V_Paradigm>, VID_Paradigm>(\"para\",);\n  readonly v_person = this.v_table<Partial<V_Person>, VID_Person>(\"person\");\n  readonly v_plang = this.v_table<Partial<V_Plang>, VID_Plang>(\"pl\");\n  readonly v_platform = this.v_table<Partial<V_Platform>, VID_Platform>(\"platf\");\n  readonly v_tsystem = this.v_table<Partial<V_TypeSystem>, VID_TypeSystem>(\"tsys\");\n\n  // Edge Tables.\n  readonly e_dialect_of = this.e_table<E_DialectOf, VID_Plang, VID_Plang>(\"dialect-of\", this.v_plang, this.v_plang,);\n  readonly e_has_license = this.e_table<E_HasLicense, VID_Plang, VID_License>(\"has-license\", this.v_plang, this.v_license,);\n  readonly e_implements = this.e_table<E_Implements, VID_Plang, VID_Plang>(\"implements\", this.v_plang, this.v_plang,);\n  readonly e_l_influenced_l = this.e_table<E_LInfluencedL, VID_Plang, VID_Plang>(\"influenced\", this.v_plang, this.v_plang,);\n  readonly e_person_plang = this.e_table<E_PersonPlang, VID_Person, VID_Plang>(\"had-role\", this.v_person, this.v_plang);\n  readonly e_plang_para = this.e_table<E_PlangPara, VID_Plang, VID_Paradigm>(\"paradigm\", this.v_plang, this.v_paradigm,);\n  readonly e_plang_tsys = this.e_table<E_PlangTsys, VID_Plang, VID_TypeSystem>(\"type-system\", this.v_plang, this.v_tsystem);\n  readonly e_supports_platf = this.e_table<E_SupportsPlatf, VID_Plang, VID_Platform>(\"supports-platf\", this.v_plang, this.v_platform);\n\n  // Builders.\n\n  buildLicense(vid: VID_License) { return new LicenseBuilder(this, vid); }\n  buildParadigm(vid: VID_Paradigm) { return new ParadigmBuilder(this, vid); }\n  buildPerson(vid: VID_Person) { return new PersonBuilder(this, vid); }\n  buildPlang(vid: VID_Plang) { return new PlangBuilder(this, vid); }\n  buildPlatform(vid: VID_Platform) { return new PlatformBuilder(this, vid); }\n  buildTypeSystem(vid: VID_TypeSystem) { return new TypeSysBuilder(this, vid); }\n}\n", "import { createContext } from \"preact\";\nimport { PlangsGraph } from \"../../../schemas/graph\";\n\n/**\n * The result of loading a plangs graph: undefined while the graph has not been loaded.\n */\nexport type PlangsContext = PlangsGraph | undefined | \"error\";\n\nexport const Plangs = createContext<PlangsContext>(undefined);\n\nexport async function loadPlangs(): Promise<PlangsContext> {\n  try {\n    const req = await fetch(\"/plangs.json\");\n    const plangData = await req.json();\n\n    const pg = new PlangsGraph();\n\n    pg.loadJSON(plangData);\n    console.log(\"Loaded PlangsGraph:\", pg.numVertices, \"vertices\", pg.numEdges, \"edges\");\n\n    return pg;\n  } catch (e) {\n    console.error(\"Failed to load plangs:\", e);\n    return \"error\";\n  }\n}\n", "import { h, render } from \"preact\";\nimport { useEffect, useState } from \"preact/hooks\";\n\nimport { Plangs, loadPlangs, type PlangsContext } from \"./state/plangs_context\";\n\nfunction ContextWrapper({ children }) {\n  const [pg, setPg] = useState<PlangsContext>();\n  useEffect(() => {\n    if (pg) return;\n    loadPlangs().then((pg) => setPg(pg));\n  });\n  return <Plangs.Provider value={pg}>{children}</Plangs.Provider>;\n}\n\nexport function start(cssId: string, app: h.JSX.Element) {\n  const elem = document.getElementById(cssId);\n  if (!elem) throw new Error(`Element not found: ${cssId}`);\n  render(<ContextWrapper>{app}</ContextWrapper>, elem);\n}\n", "import \"preact/debug\";\n\nimport { Fragment, h } from \"preact\";\n\nimport { start } from \"../shared/start\";\n\nimport \"./search.css\";\n\nfunction Search() {\n  return (\n    <>\n      <label class=\"search-label\">\n        Search:\n        <input type=\"query\" id=\"search-input\" placeholder=\"Search...\" />\n      </label>\n      <div id=\"search-results\">Search results...</div>\n    </>\n  );\n}\n\nstart(\"search\", <Search />);\n"],
  "mappings": ";;AACaA,MC2BAC;AD3BAD,MEUPE;AFVOF,MGETG;AHFSH,MGkGAI;AHlGAJ,MIiLTK;AJjLSL,MI4LTM;AJ5LSN,MI8LPO;AJ9LOP,MIwNPQ;AJxNOR,MKyBTS;ALzBST,MK2KPU;AL3KOV,MK4KPW;AL5KOX,MMCFY;ANDEZ,MAWAa,IAAgC,CAAA;AAXhCb,MAYAc,IAAY,CAAA;AAZZd,MAaAe,IACZ;AAdYf,MCCAgB,IAAUC,MAAMD;AAStB,WAASE,EAAOC,IAAKC,IAAAA;AAE3B,aAASR,MAAKQ;AAAOD,MAAAA,GAAIP,EAAAA,IAAKQ,GAAMR,EAAAA;AACpC,WAA6BO;EAC7B;AAAA,WAQeE,EAAWC,IAAAA;AAC1B,QAAIC,KAAaD,GAAKC;AAClBA,IAAAA,MAAYA,GAAWC,YAAYF,EAAAA;EACvC;AEZM,WAASG,EAAcC,IAAMN,IAAOO,IAAAA;AAC1C,QACCC,IACAC,IACAjB,IAHGkB,KAAkB,CAAA;AAItB,SAAKlB,MAAKQ;AACA,eAALR,KAAYgB,KAAMR,GAAMR,EAAAA,IACd,SAALA,KAAYiB,KAAMT,GAAMR,EAAAA,IAC5BkB,GAAgBlB,EAAAA,IAAKQ,GAAMR,EAAAA;AAUjC,QAPImB,UAAUC,SAAS,MACtBF,GAAgBH,WACfI,UAAUC,SAAS,IAAI/B,EAAMgC,KAAKF,WAAW,CAAA,IAAKJ,KAKjC,cAAA,OAARD,MAA2C,QAArBA,GAAKQ;AACrC,WAAKtB,MAAKc,GAAKQ;AAAAA,mBACVJ,GAAgBlB,EAAAA,MACnBkB,GAAgBlB,EAAAA,IAAKc,GAAKQ,aAAatB,EAAAA;AAK1C,WAAOuB,EAAYT,IAAMI,IAAiBF,IAAKC,IAAK,IAAA;EACpD;AAceM,WAAAA,EAAYT,IAAMN,IAAOQ,IAAKC,IAAKO,IAAAA;AAIlD,QAAMC,KAAQ,EACbX,MAAAA,IACAN,OAAAA,IACAQ,KAAAA,IACAC,KAAAA,IACAS,KAAW,MACXC,IAAS,MACTC,KAAQ,GACRC,KAAM,MAKNC,KAAAA,QACAC,KAAY,MACZC,aAAAA,QACAC,KAAuB,QAAZT,KAAAA,EAAqBjC,IAAUiC,IAC1CU,KAAAA,IACAC,KAAQ,EAAA;AAMT,WAFgB,QAAZX,MAAqC,QAAjBlC,EAAQmC,SAAenC,EAAQmC,MAAMA,EAAAA,GAEtDA;EACP;AAMeW,WAAAA,EAASC,IAAAA;AACxB,WAAOA,GAAMC;EACb;AC/EeC,WAAAA,EAAcF,IAAOG,IAAAA;AACpCC,SAAKJ,QAAQA,IACbI,KAAKD,UAAUA;EACf;AA0EM,WAASE,EAAcC,IAAOC,IAAAA;AACpC,QAAkB,QAAdA;AAEH,aAAOD,GAAAE,KACJH,EAAcC,GAAeA,IAAAA,GAAAA,MAAe,CAAA,IAC5C;AAIJ,aADIG,IACGF,KAAaD,GAAAI,IAAgBC,QAAQJ;AAG3C,UAAe,SAFfE,KAAUH,GAAAI,IAAgBH,EAAAA,MAEa,QAAhBE,GAAAG;AAItB,eAAOH,GACPG;AAQF,WAA4B,cAAA,OAAdN,GAAMO,OAAqBR,EAAcC,EAAAA,IAAS;EAChE;AA2CD,WAASQ,EAAwBR,IAAAA;AAAjC,QAGWS,IACJC;AAHN,QAA+B,SAA1BV,KAAQA,GAAHE,OAAiD,QAApBF,GAAKW,KAAqB;AAEhE,WADAX,GAAKM,MAAQN,GAAKW,IAAYC,OAAO,MAC5BH,KAAI,GAAGA,KAAIT,GAAKI,IAAWC,QAAQI;AAE3C,YAAa,SADTC,KAAQV,GAAAI,IAAgBK,EAAAA,MACO,QAAdC,GAAAJ,KAAoB;AACxCN,UAAAA,GAAKM,MAAQN,GAAKW,IAAYC,OAAOF,GAArCJ;AACA;QACA;AAGF,aAAOE,EAAwBR,EAAAA;IAC/B;EACD;AAAA,WA4Bea,EAAcC,IAAAA;AAAAA,KAAAA,CAE1BA,GAADC,QACCD,GAAAC,MAAAA,SACDC,EAAcC,KAAKH,EAAAA,KAAAA,CAClBI,EAAAA,SACFC,MAAiBC,EAAQC,wBAEzBF,IAAeC,EAAQC,sBACNC,GAAOJ,CAAAA;EAEzB;AASD,WAASA,IAAAA;AAAT,QACKJ,IAMES,IAzGkBC,IAOjBC,IANHC,IACHC,IACAC,IACAC;AAmGD,SAHAb,EAAcc,KAAKC,CAAAA,GAGXjB,KAAIE,EAAcgB,MAAAA;AACrBlB,MAAAA,GAAAA,QACCS,KAAoBP,EAAcX,QAlGjCoB,KAAAA,QALNE,MADGD,MADoBF,KA0GNV,IAAAA,KAxGXR,KACNsB,KAAc,CAAA,GACdC,KAAW,CAAA,GAERL,GAAAA,SACGC,KAAWQ,EAAO,CAAA,GAAIP,EAAAA,GAC5BQ,MAAqBR,GAAAQ,MAAqB,GACtCd,EAAQpB,SAAOoB,EAAQpB,MAAMyB,EAAAA,GAEjCU,EACCX,GADGY,KAEHX,IACAC,IACAF,GACAA,KAAAA,GAAAA,IAAqBa,cJzII,KI0IzBX,GAAAA,MAAiC,CAACC,EAAAA,IAAU,MAC5CC,IACU,QAAVD,KAAiB5B,EAAc2B,EAAAA,IAAYC,IAAAA,CAAAA,EJ5IlB,KI6ItBD,GAAAY,MACHT,EAAAA,GAGDJ,GAAQS,MAAaR,GAArBQ,KACAT,GAAAvB,GAAAE,IAA2BqB,GAA3Bc,GAAAA,IAA8Cd,IAC9Ce,EAAWZ,IAAaH,IAAUI,EAAAA,GAE9BJ,GAAQnB,OAASqB,MACpBnB,EAAwBiB,EAAAA,IA8EpBT,EAAcX,SAASkB,MAI1BP,EAAcc,KAAKC,CAAAA;AAItBb,MAAAA,MAAyB;EACzB;AAAA,WGlNeuB,EACfC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACApB,IACAD,IACAsB,IACApB,IAAAA;AAAAA,QAEIpB,IAEHiB,IAEAwB,IAEAC,IAEAC,IAKGC,KAAeR,MAAkBA,GAAnBzC,OAAgDkD,GAE9DC,KAAoBZ,GAAatC;AAMrC,SAJAuC,GAAA7B,MAA0BY,IAC1B6B,EAA0BZ,IAAgBD,IAAcU,EAAAA,GACxD1B,KAASiB,GAAT7B,KAEKN,KAAI,GAAGA,KAAI8C,IAAmB9C;AAGnB,eAFfyC,KAAaN,GAAAxC,IAAyBK,EAAAA,MAGhB,aAAA,OAAdyC,MACc,cAAA,OAAdA,OAQPxB,KAAAA,OADGwB,GAAAX,MACQkB,IAEAJ,GAAYH,GAADX,GAAAA,KAAuBkB,GAI9CP,GAAUX,MAAU9B,IAGpB0B,EACCO,IACAQ,IACAxB,IACAoB,IACAC,IACAC,IACApB,IACAD,IACAsB,IACApB,EAAAA,GAIDsB,KAASD,GAAH5C,KACF4C,GAAWQ,OAAOhC,GAASgC,OAAOR,GAAWQ,QAC5ChC,GAASgC,OACZC,EAASjC,GAASgC,KAAK,MAAMR,EAAAA,GAE9BrB,GAASZ,KACRiC,GAAWQ,KACXR,GAAAvC,OAAyBwC,IACzBD,EAAAA,IAImB,QAAjBE,MAAmC,QAAVD,OAC5BC,KAAgBD,KP1GS,QO8GzBD,GAAAZ,OACAZ,GAAAtB,QAAuB8C,GAFxB9C,OAKKuB,MAAAA,CAAWA,GAAOiC,gBACrBjC,KAAS5B,EAAc2B,EAAAA,IAExBC,KAASkC,EAAOX,IAAYvB,IAAQe,EAAAA,KAEV,cAAA,OAAnBQ,GAAW3C,QAAAA,WAClB2C,GAAUnC,MAKVY,KAASuB,GAAHnC,MACIoC,OACVxB,KAASwB,GAAOW,cAQjBZ,GAAAA,MAAAA,QAGAA,GAAAA,OAAAA;AAaDN,IAAAA,GAAA7B,MAA0BY,IAC1BiB,GAAAtC,MAAsB8C;EACtB;AAOD,WAASI,EAA0BZ,IAAgBD,IAAcU,IAAAA;AAAjE,QAEK5C,IAEAyC,IAEAxB,IA8DGqC,IAmCAC,IA/FDT,KAAoBZ,GAAatC,QACnC4D,KAAoBZ,GAAYhD,QACnC6D,KAAuBD,IAEpBE,KAAO;AAGX,SADAvB,GAAAxC,MAA2B,CAAA,GACtBK,KAAI,GAAGA,KAAI8C,IAAmB9C;AAqD5BsD,MAAAA,KAActD,KAAI0D,IAGN,SA9CjBjB,KAAaN,GAAAxC,IAAyBK,EAAAA,IAJxB,SAHfyC,KAAaP,GAAalC,EAAAA,MAIJ,aAAA,OAAdyC,MACc,cAAA,OAAdA,KAEoC,OAMtB,YAAA,OAAdA,MACc,YAAA,OAAdA,MAEc,YAAA,OAAdA,MACPA,GAAWkB,eAAeC,SAEiBC,EAC1C,MACApB,IACA,MACA,MACA,IAAA,IAESqB,EAAQrB,EAAAA,IACyBoB,EAC1C7E,GACA,EAAEE,UAAUuD,GAAAA,GACZ,MACA,MACA,IAAA,IAAA,WAESA,GAAWkB,eAA6BlB,GAAAA,MAAoB,IAK3BoB,EAC1CpB,GAAW3C,MACX2C,GAAWxD,OACXwD,GAAWsB,KACXtB,GAAWQ,MAAMR,GAAWQ,MAAM,MAClCR,GALqDhB,GAAAA,IAQXgB,OAmC5CA,GAAAA,KAAqBN,IACrBM,GAAAA,MAAoBN,GAAAA,MAAwB,GAEtCoB,KAAgBS,EACrBvB,IACAG,IACAU,IACAG,EAAAA,GAMDhB,GAAUX,MAAUyB,IAEpBtC,KAAW,MAAA,OACPsC,OAEHE,OADAxC,KAAW2B,GAAYW,EAAAA,OAGtBtC,GAAQY,OPtRW,UO6RU,QAAZZ,MAA2C,SAAvBA,GAAQQ,OAAAA,MAG1C8B,MACHG,MAI6B,cAAA,OAAnBjB,GAAW3C,SACrB2C,GAAUZ,OPxSc,UO0Sf0B,OAAkBD,OACxBC,OAAkBD,KAAc,IACnCI,OACUH,KAAgBD,KACtBG,KAAuBX,KAAoBQ,KAC9CI,MAAQH,KAAgBD,KAExBI,OAESH,KAAgBD,KACtBC,MAAiBD,KAAc,MAClCI,KAAOH,KAAgBD,MAGxBI,KAAO,GAKJH,OAAkBvD,KAAI0D,OACzBjB,GAAAZ,OP9TwB,YOwOzBZ,KAAW2B,GAAYU,EAAAA,MAGN,QAAhBrC,GAAS8C,OACT9C,GAAAA,OACgC,MP3Ob,SO2OlBA,GAAAY,SAEGZ,GAAQpB,OAASsC,GAAjB7B,QACH6B,GAAA7B,MAA0BhB,EAAc2B,EAAAA,IAGzCgD,EAAQhD,IAAUA,IAAAA,KAAU,GAW5B2B,GAAYU,EAAAA,IAAe,MAC3BG;AAwEH,QAAIA;AACH,WAAKzD,KAAI,GAAGA,KAAIwD,IAAmBxD;AAElB,iBADhBiB,KAAW2B,GAAY5C,EAAAA,MACiC,MPxUpC,SOwUKiB,GAAAY,SACpBZ,GAAQpB,OAASsC,GAAjB7B,QACH6B,GAAA7B,MAA0BhB,EAAc2B,EAAAA,IAGzCgD,EAAQhD,IAAUA,EAAAA;EAIrB;AAQD,WAASmC,EAAOc,IAAahD,IAAQe,IAAAA;AAArC,QAIM/C,IACKc;AAFV,QAA+B,cAAA,OAApBkE,GAAYpE,MAAoB;AAE1C,WADIZ,KAAWgF,GAAHvE,KACHK,KAAI,GAAGd,MAAYc,KAAId,GAASU,QAAQI;AAC5Cd,QAAAA,GAASc,EAAAA,MAKZd,GAASc,EAAAA,EAATP,KAAsByE,IACtBhD,KAASkC,EAAOlE,GAASc,EAAAA,GAAIkB,IAAQe,EAAAA;AAIvC,aAAOf;IACP;AAAUgD,IAAAA,GAAAA,OAAoBhD,OAC9Be,GAAUkC,aAAaD,GAAvBrE,KAAyCqB,MAAU,IAAA,GACnDA,KAASgD,GAAHrE;AAGP,OAAA;AACCqB,MAAAA,KAASA,MAAUA,GAAOmC;IAAAA,SACR,QAAVnC,MAAsC,MAApBA,GAAOkD;AAElC,WAAOlD;EACP;AA4BD,WAASmD,EACRC,IACAC,IACAC,IACAC,IAAAA;AAJD,QAMOC,KAAMJ,GAAWI,KACjBC,KAAOL,GAAWK,MACpBC,KAAIJ,KAAc,GAClBK,KAAIL,KAAc,GAClBM,KAAWP,GAAYC,EAAAA;AAc3B,QACc,SAAbM,MACCA,MACAJ,MAAOI,GAASJ,OAChBC,OAASG,GAASH,QACc,MP7aZ,SO6anBG,GAAAC;AAEF,aAAOP;AACD,QAXNC,MACa,QAAZK,MAAoD,MPtahC,SOsaCA,GAAAA,OAAmC,IAAI;AAW7D,aAAOF,MAAK,KAAKC,KAAIN,GAAYS,UAAQ;AACxC,YAAIJ,MAAK,GAAG;AAEX,eADAE,KAAWP,GAAYK,EAAAA,MAGU,MPtbd,SOsbjBE,GAAAC,QACDL,MAAOI,GAASJ,OAChBC,OAASG,GAASH;AAElB,mBAAOC;AAERA,UAAAA;QACA;AAED,YAAIC,KAAIN,GAAYS,QAAQ;AAE3B,eADAF,KAAWP,GAAYM,EAAAA,MAGU,MPncd,SOmcjBC,GAAQC,QACTL,MAAOI,GAASJ,OAChBC,OAASG,GAASH;AAElB,mBAAOE;AAERA,UAAAA;QACA;MACD;AAGF,WAAA;EACA;AFndD,WAASI,EAASC,IAAOR,IAAKS,IAAAA;AACd,YAAXT,GAAI,CAAA,IACPQ,GAAME,YAAYV,IAAc,QAATS,KAAgB,KAAKA,EAAAA,IAE5CD,GAAMR,EAAAA,IADa,QAATS,KACG,KACa,YAAA,OAATA,MAAqBE,EAAmBC,KAAKZ,EAAAA,IACjDS,KAEAA,KAAQ;EAEtB;AAuBeC,WAAAA,EAAYG,IAAKC,IAAML,IAAOM,IAAUC,IAAAA;AACvD,QAAIC;AAEJC;AAAG,UAAa,YAATJ;AACN,YAAoB,YAAA,OAATL;AACVI,UAAAA,GAAIL,MAAMW,UAAUV;aACd;AAKN,cAJuB,YAAA,OAAZM,OACVF,GAAIL,MAAMW,UAAUJ,KAAW,KAG5BA;AACH,iBAAKD,MAAQC;AACNN,cAAAA,MAASK,MAAQL,MACtBF,EAASM,GAAIL,OAAOM,IAAM,EAAA;AAK7B,cAAIL;AACH,iBAAKK,MAAQL;AACPM,cAAAA,MAAYN,GAAMK,EAAAA,MAAUC,GAASD,EAAAA,KACzCP,EAASM,GAAIL,OAAOM,IAAML,GAAMK,EAAAA,CAAAA;QAInC;eAGmB,QAAZA,GAAK,CAAA,KAA0B,QAAZA,GAAK,CAAA;AAChCG,QAAAA,KACCH,QAAUA,KAAOA,GAAKM,QAAQ,+BAA+B,IAAA,IAQ7DN,KAJAA,GAAKO,YAAAA,KAAiBR,MACb,iBAATC,MACS,gBAATA,KAEOA,GAAKO,YAAAA,EAAcC,MAAM,CAAA,IACrBR,GAAKQ,MAAM,CAAA,GAElBT,GAALU,MAAqBV,GAAGU,IAAc,CAAjB,IACrBV,GAAGU,EAAYT,KAAOG,EAAAA,IAAcR,IAEhCA,KACEM,KAQJN,GAAMe,IAAYT,GAASS,KAP3Bf,GAAMe,IAAYC,GAClBZ,GAAIa,iBACHZ,IACAG,KAAaU,IAAoBC,GACjCX,EAAAA,KAMFJ,GAAIgB,oBACHf,IACAG,KAAaU,IAAoBC,GACjCX,EAAAA;WAGI;AACN,YAAiB,gCAAbD;AAIHF,UAAAA,KAAOA,GAAKM,QAAQ,eAAe,GAAA,EAAKA,QAAQ,UAAU,GAAA;iBAElD,WAARN,MACQ,YAARA,MACQ,UAARA,MACQ,UAARA,MACQ,UAARA,MAGQ,cAARA,MACQ,cAARA,MACQ,aAARA,MACQ,aAARA,MACQ,UAARA,MACAA,MAAQD;AAER,cAAA;AACCA,YAAAA,GAAIC,EAAAA,IAAiB,QAATL,KAAgB,KAAKA;AAEjC,kBAAMS;UAAAA,SACEY,IAAAA;UAAAA;AAUU,sBAAA,OAATrB,OAES,QAATA,MAAAA,UAAkBA,MAA+B,QAAZK,GAAK,CAAA,IAGpDD,GAAIkB,gBAAgBjB,EAAAA,IAFpBD,GAAImB,aAAalB,IAAML,EAAAA;MAIxB;EACD;AAOD,WAASwB,EAAiBhB,IAAAA;AAMzB,WAAO,SAAUa,IAAAA;AAChB,UAAII,KAAiBX,GAAA;AACpB,YAAMY,KAAeD,KAAAX,EAAgBO,GAAE7B,OAAOgB,EAAAA;AAC9C,YAAqB,QAAjBa,GAAEM;AACLN,UAAAA,GAAEM,IAAcX;iBAKNK,GAAEM,IAAcD,GAAaX;AACvC;AAED,eAAOW,GAAaE,EAAQC,QAAQD,EAAQC,MAAMR,EAAAA,IAAKA,EAAAA;MACvD;IACD;EACD;AG3IM,WAASS,EACfC,IACAC,IACArC,IACAsC,IACA1B,IACA2B,IACAC,IACAC,IACAC,IACAC,IAAAA;AAVM,QAaFC,IAkBEC,IAAGC,IAAOC,IAAUC,IAAUC,IAAUC,IACxCC,IAKAC,IACAC,IAuGOC,IA4BPC,IACHC,IASSF,IA6BNG,GAlMLC,KAAUrB,GAASxC;AAIpB,QAAA,WAAIwC,GAASsB;AAA2B,aAAA;AR9CX,UQiDzB3D,GAAAC,QACHyC,KAAAA,CAAAA,ERpD0B,KQoDT1C,GAAQC,MAEzBsC,KAAoB,CADpBE,KAASJ,GAAQuB,MAAQ5D,GAAhB4D,GAAAA,KAILhB,KAAMX,EAAX4B,QAA2BjB,GAAIP,EAAAA;AAE/ByB;AAAO,UAAsB,cAAA,OAAXJ;AACjB,YAAA;AAgEC,cA9DIP,KAAWd,GAAS0B,OAKpBX,MADJR,KAAMc,GAAQM,gBACQ1B,GAAcM,GAApCqB,GAAAA,GACIZ,KAAmBT,KACpBQ,KACCA,GAASW,MAAM1D,QACfuC,GAAAA,KACDN,IAGCtC,GAAJiE,MAECf,MADAL,KAAIR,GAAA4B,MAAsBjE,GAAtBiE,KACwBC,KAAwBrB,GACpDsB,OAEI,eAAeT,MAAWA,GAAQU,UAAUC,SAE/ChC,GAAQ4B,MAAcpB,KAAI,IAAIa,GAAQP,IAAUE,EAAAA,KAGhDhB,GAAA4B,MAAsBpB,KAAI,IAAIyB,EAC7BnB,IACAE,EAAAA,GAEDR,GAAEc,cAAcD,IAChBb,GAAEwB,SAASE,IAERnB,MAAUA,GAASoB,IAAI3B,EAAAA,GAE3BA,GAAEkB,QAAQZ,IACLN,GAAE4B,UAAO5B,GAAE4B,QAAQ,CAAV,IACd5B,GAAE6B,UAAUrB,IACZR,GAAC8B,MAAkBrC,IACnBQ,KAAQD,GAAAA,MAAAA,MACRA,GAAA+B,MAAqB,CAAA,GACrB/B,GAAAgC,MAAoB,CAAA,IAID,QAAhBhC,GAAAiC,QACHjC,GAACiC,MAAcjC,GAAE4B,QAGsB,QAApCf,GAAQqB,6BACPlC,GAAAiC,OAAgBjC,GAAE4B,UACrB5B,GAACiC,MAAcE,EAAO,CAAA,GAAInC,GAAAA,GAAAA,IAG3BmC,EACCnC,GACAa,KAAAA,GAAQqB,yBAAyB5B,IAAUN,GAFtCiC,GAAAA,CAAAA,IAMP/B,KAAWF,GAAEkB,OACbf,KAAWH,GAAE4B,OACb5B,GAAAoC,MAAW5C,IAGPS;AAEkC,oBAApCY,GAAQqB,4BACgB,QAAxBlC,GAAEqC,sBAEFrC,GAAEqC,mBAAAA,GAGwB,QAAvBrC,GAAEsC,qBACLtC,GAAC+B,IAAkBQ,KAAKvC,GAAEsC,iBAAAA;eAErB;AASN,gBAPqC,QAApCzB,GAAQqB,4BACR5B,OAAaJ,MACkB,QAA/BF,GAAEwC,6BAEFxC,GAAEwC,0BAA0BlC,IAAUE,EAAAA,GAAAA,CAIrCR,GAADe,QAC6B,QAA3Bf,GAAEyC,yBAAAA,UACHzC,GAAEyC,sBACDnC,IACAN,GAFDiC,KAGCzB,EAAAA,KAEDhB,GAAA4C,QAAuBjF,GAAvBiF,MACA;AAkBD,mBAhBI5C,GAAA4C,QAAuBjF,GAAvBiF,QAKHpC,GAAEkB,QAAQZ,IACVN,GAAE4B,QAAQ5B,GACVA,KAAAA,GAAA0C,MAAAA,QAGDlD,GAAAuB,MAAgB5D,GAAhB4D,KACAvB,GAAQmD,MAAaxF,GAArBwF,KACAnD,GAAQmD,IAAWC,QAAQ,SAAAC,IAAAA;AACtBA,gBAAAA,OAAOA,GAAAxB,KAAgB7B;cAC3B,CAAA,GAEQiB,KAAI,GAAGA,KAAIT,GAAAgC,IAAkB3E,QAAQoD;AAC7CT,gBAAAA,GAAC+B,IAAkBQ,KAAKvC,GAACgC,IAAiBvB,EAAAA,CAAAA;AAE3CT,cAAAA,GAAAgC,MAAoB,CAAA,GAEhBhC,GAAA+B,IAAmB1E,UACtBsC,GAAY4C,KAAKvC,EAAAA;AAGlB,oBAAMiB;YACN;AAE4B,oBAAzBjB,GAAE8C,uBACL9C,GAAE8C,oBAAoBxC,IAAUN,GAAcQ,KAAAA,EAAAA,GAGnB,QAAxBR,GAAE+C,sBACL/C,GAAA+B,IAAmBQ,KAAK,WAAA;AACvBvC,cAAAA,GAAE+C,mBAAmB7C,IAAUC,IAAUC,EAAAA;YACzC,CAAA;UAEF;AASD,cAPAJ,GAAE6B,UAAUrB,IACZR,GAAEkB,QAAQZ,IACVN,GAAAgD,MAAezD,IACfS,GAAAe,MAAAA,OAEIL,KAAatB,EAAjB6D,KACCtC,KAAQ,GACL,eAAeE,MAAWA,GAAQU,UAAUC,QAAQ;AAQvD,iBAPAxB,GAAE4B,QAAQ5B,GACVA,KAAAA,GAAAA,MAAAA,OAEIU,MAAYA,GAAWlB,EAAAA,GAE3BO,KAAMC,GAAEwB,OAAOxB,GAAEkB,OAAOlB,GAAE4B,OAAO5B,GAAE6B,OAAAA,GAE1BpB,KAAI,GAAGA,KAAIT,GAACgC,IAAiB3E,QAAQoD;AAC7CT,cAAAA,GAAC+B,IAAkBQ,KAAKvC,GAAAgC,IAAkBvB,EAAAA,CAAAA;AAE3CT,YAAAA,GAAAgC,MAAoB,CAAA;UACpB;AACA,eAAA;AACChC,cAAAA,GAAA0C,MAAAA,OACIhC,MAAYA,GAAWlB,EAAAA,GAE3BO,KAAMC,GAAEwB,OAAOxB,GAAEkB,OAAOlB,GAAE4B,OAAO5B,GAAE6B,OAAAA,GAGnC7B,GAAE4B,QAAQ5B,GAAViC;YAAAA,SACQjC,GAAC0C,OAAAA,EAAa/B,KAAQ;AAIhCX,UAAAA,GAAE4B,QAAQ5B,GAAViC,KAEyB,QAArBjC,GAAEkD,oBACLzD,KAAgB0C,EAAOA,EAAO,CAAD,GAAK1C,EAAAA,GAAgBO,GAAEkD,gBAAAA,CAAAA,IAGhDjD,MAAsC,QAA7BD,GAAEmD,4BACf/C,KAAWJ,GAAEmD,wBAAwBjD,IAAUC,EAAAA,IAOhDiD,EACC7D,IACA8D,EAJGzC,IADI,QAAPb,MAAeA,GAAI/C,SAASsG,KAAuB,QAAXvD,GAAIhD,MACLgD,GAAImB,MAAMqC,WAAWxD,EAAAA,IAIpCa,IAAe,CAACA,CAAAA,GACxCpB,IACArC,IACAsC,IACA1B,IACA2B,IACAC,IACAC,IACAC,IACAC,EAAAA,GAGDE,GAAEwD,OAAOhE,GAGTA,KAAAA,GAAApC,OAAAA,MAEI4C,GAAAA,IAAmB3C,UACtBsC,GAAY4C,KAAKvC,EAAAA,GAGdK,OACHL,GAAAA,MAAkBA,GAAAqB,KAAyB;QAkB5C,SAhBQxC,IAAAA;AACRW,UAAAA,GAAQ4C,MAAa,MAEjBvC,MAAoC,QAArBH,MAClBF,GAAQuB,MAAQnB,IAChBJ,GAAApC,OAAmByC,KAChB4D,MRhRqB,IQkRxB/D,GAAkBA,GAAkBgE,QAAQ9D,EAAAA,CAAAA,IAAW,SAIvDJ,GAAAuB,MAAgB5D,GAAhB4D,KACAvB,GAAQmD,MAAaxF,GACrBwF,MACDvD,EAAO2B,IAAalC,IAAGW,IAAUrC,EAAAA;QACjC;;AAEoB,gBAArBuC,MACAF,GAAA4C,QAAuBjF,GAAvBiF,OAEA5C,GAAAmD,MAAqBxF,GAArBwF,KACAnD,GAAQuB,MAAQ5D,GAChB4D,OACAvB,GAAQuB,MAAQ4C,EACfxG,GAD+B4D,KAE/BvB,IACArC,IACAsC,IACA1B,IACA2B,IACAC,IACAE,IACAC,EAAAA;AAAAA,KAIGC,KAAMX,EAAQwE,WAAS7D,GAAIP,EAAAA;EAChC;AAAA,WAOeqE,EAAWlE,IAAamE,IAAMhE,IAAAA;AAC7CgE,IAAAA,GAAIpB,MAAAA;AAEJ,aAASjC,KAAI,GAAGA,KAAIX,GAASzC,QAAQoD;AACpCsD,QAASjE,GAASW,EAAAA,GAAIX,GAAAA,EAAWW,EAAAA,GAAIX,GAAAA,EAAWW,EAAAA,CAAAA;AAG7CrB,MAAiBA,OAAAA,EAAAgC,IAAgB0C,IAAMnE,EAAAA,GAE3CA,GAAYqE,KAAK,SAAAhE,IAAAA;AAChB,UAAA;AAECL,QAAAA,KAAcK,GAAd+B,KACA/B,GAAA+B,MAAqB,CAAA,GACrBpC,GAAYqE,KAAK,SAAAC,IAAAA;AAEhBA,UAAAA,GAAGC,KAAKlE,EAAAA;QACR,CAAA;MAGD,SAFQnB,IAAAA;AACRO,UAAA2B,IAAoBlC,IAAGmB,GAAvBoC,GAAAA;MACA;IACD,CAAA;EACD;AAiBD,WAASuB,EACR/F,IACA4B,IACArC,IACAsC,IACA1B,IACA2B,IACAC,IACAE,IACAC,IAAAA;AATD,QAeKW,IAEA0D,IAEAC,IAEAC,IACA7G,IACA8G,IACAC,IAbArE,KAAW/C,GAAS+D,OACpBZ,KAAWd,GAAS0B,OACpBsD,KAAkChF,GAASxC;AAmB/C,QALiB,UAAbwH,KAAoBzG,KAAY,+BACd,WAAbyG,KACRzG,KAAY,uCACHA,OAAWA,KAAY,iCAER,QAArB2B;AACH,WAAKe,KAAI,GAAGA,KAAIf,GAAkBrC,QAAQoD;AAMzC,aALAjD,KAAQkC,GAAkBe,EAAAA,MAOzB,kBAAkBjD,MAAAA,CAAAA,CAAYgH,OAC7BA,KAAWhH,GAAMiH,cAAcD,KAA8B,MAAnBhH,GAAMgH,WAChD;AACD5G,UAAAA,KAAMJ,IACNkC,GAAkBe,EAAAA,IAAK;AACvB;QACA;;AAIH,QAAW,QAAP7C,IAAa;AAChB,UAAiB,SAAb4G;AACH,eAAOE,SAASC,eAAerE,EAAAA;AAGhC1C,MAAAA,KAAM8G,SAASE,gBACd7G,IACAyG,IACAlE,GAASuE,MAAMvE,EAAAA,GAIhBZ,KAAoB,MAGpBG,KAAAA;IACA;AAED,QAAiB,SAAb2E;AAECtE,MAAAA,OAAaI,MAAcT,MAAejC,GAAIkH,SAASxE,OAC1D1C,GAAIkH,OAAOxE;SAEN;AASN,UAPAZ,KAAoBA,MAAqBrB,EAAM6F,KAAKtG,GAAImH,UAAAA,GAExD7E,KAAW/C,GAAS+D,SAAS8D,GAAAA,CAKxBnF,MAAoC,QAArBH;AAEnB,aADAQ,KAAW,CAAX,GACKO,KAAI,GAAGA,KAAI7C,GAAIqH,WAAW5H,QAAQoD;AAEtCP,UAAAA,IADA1C,KAAQI,GAAIqH,WAAWxE,EAAAA,GACR5C,IAAAA,IAAQL,GAAMA;AAI/B,WAAKiD,MAAKP;AAET,YADA1C,KAAQ0C,GAASO,EAAAA,GACR,cAALA;AAAAA;iBACY,6BAALA;AACV2D,UAAAA,KAAU5G;iBACM,UAANiD,MAAAA,EAAiBA,MAAKH,KAAW;AAC3C,cACO,WAALG,MAAgB,kBAAkBH,MAC7B,aAALG,MAAkB,oBAAoBH;AAEvC;AAED7C,YAAYG,IAAK6C,IAAG,MAAMjD,IAAOO,EAAAA;QACjC;AAKF,WAAK0C,MAAKH;AACT9C,QAAAA,KAAQ8C,GAASG,EAAAA,GACR,cAALA,KACH4D,KAAc7G,KACC,6BAALiD,KACV0D,KAAU3G,KACK,WAALiD,KACV6D,KAAa9G,KACE,aAALiD,KACV8D,KAAU/G,KAEJ,UAANiD,MACEZ,MAA+B,cAAA,OAATrC,MACxB0C,GAASO,EAAAA,MAAOjD,MAEhBC,EAAYG,IAAK6C,IAAGjD,IAAO0C,GAASO,EAAAA,GAAI1C,EAAAA;AAK1C,UAAIoG;AAGDtE,QAAAA,MACCuE,OACAD,GAAAA,WAAmBC,GACnBD,UAAAA,GAAAe,WAAmBtH,GAAIuH,eAEzBvH,GAAIuH,YAAYhB,GAAAA,SAGjB3E,GAAAmD,MAAqB,CAAA;eAEjByB,OAASxG,GAAIuH,YAAY,KAE7B/B,EACCxF,IACAyF,EAAQgB,EAAAA,IAAeA,KAAc,CAACA,EAAAA,GACtC7E,IACArC,IACAsC,IACa,oBAAb+E,KACG,iCACAzG,IACH2B,IACAC,IACAD,KACGA,GAAkB,CAAA,IAClBvC,GAAAwF,OAAsByC,EAAcjI,IAAU,CAAA,GACjD0C,IACAC,EAAAA,GAIwB,QAArBJ;AACH,aAAKe,KAAIf,GAAkBrC,QAAQoD;AACN,kBAAxBf,GAAkBe,EAAAA,KAAY4E,EAAW3F,GAAkBe,EAAAA,CAAAA;AAM7DZ,MAAAA,OACJY,KAAI,SAAA,WAEH6D,OAKCA,OAAe1G,GAAI6C,EAAAA,KACL,eAAb+D,MAAAA,CAA4BF,MAIf,aAAbE,MAAyBF,OAAepE,GAASO,EAAAA,MAEnDhD,EAAYG,IAAK6C,IAAG6D,IAAYpE,GAASO,EAAAA,GAAI1C,EAAAA,GAG9C0C,KAAI,WAAA,WACA8D,MAAyBA,OAAY3G,GAAI6C,EAAAA,KAC5ChD,EAAYG,IAAK6C,IAAG8D,IAASrE,GAASO,EAAAA,GAAI1C,EAAAA;IAG5C;AAED,WAAOH;EACP;AAQemG,WAAAA,EAASuB,IAAK9H,IAAOqF,IAAAA;AACpC,QAAA;AACmB,oBAAA,OAAPyC,KAAmBA,GAAI9H,EAAAA,IAC7B8H,GAAIC,UAAU/H;IAGnB,SAFQqB,IAAAA;AACRO,QAAO2B,IAAalC,IAAGgE,EAAAA;IACvB;EACD;AASM,WAAS2C,EAAQ3C,IAAO4C,IAAaC,IAAAA;AAArC,QACFC,IAsBMlF;AAbV,QARIrB,EAAQoG,WAASpG,EAAQoG,QAAQ3C,EAAAA,IAEhC8C,KAAI9C,GAAMyC,SACTK,GAAEJ,WAAWI,GAAEJ,YAAY1C,GAAhC9B,OACCgD,EAAS4B,IAAG,MAAMF,EAAAA,IAIU,SAAzBE,KAAI9C,GAALzB,MAAgC;AACnC,UAAIuE,GAAEC;AACL,YAAA;AACCD,UAAAA,GAAEC,qBAAAA;QAGF,SAFQ/G,IAAAA;AACRO,YAAA2B,IAAoBlC,IAAG4G,EAAAA;QACvB;AAGFE,MAAAA,GAAEnC,OAAOmC,GAAC3C,MAAc;IACxB;AAED,QAAK2C,KAAI9C,GAAHF;AACL,WAASlC,KAAI,GAAGA,KAAIkF,GAAEtI,QAAQoD;AACzBkF,QAAAA,GAAElF,EAAAA,KACL+E,EACCG,GAAElF,EAAAA,GACFgF,IACAC,MAAmC,cAAA,OAAd7C,GAAM7F,IAAAA;AAM1B0I,IAAAA,MAA4B,QAAd7C,GAAA9B,OAClBsE,EAAWxC,GAAD9B,GAAAA,GAKX8B,GAAAzB,MAAmByB,GAAKxB,KAAWwB,GAAA9B,MAAa8B,GAAKH,MAAAA;EACrD;AAGD,WAAShB,EAASR,IAAOU,IAAOC,IAAAA;AAC/B,WAAO5C,KAAK6B,YAAYI,IAAOW,EAAAA;EAC/B;AC7lBeL,WAAAA,EAAOqB,IAAOtD,IAAWsG,IAAAA;AAAzBrE,QAMX3B,IAOA1C,IAQAwC,IACHG;AArBGV,MAAeA,MAAAA,EAAAiC,GAAcwB,IAAOtD,EAAAA,GAYpCpC,MAPA0C,KAAoC,cAAA,OAAfgG,MAQtB,OACCA,MAAeA,GAAhBlD,OAA0CpD,GAF7CoD,KAQIhD,KAAc,CAAA,GACjBG,KAAW,CAAA,GACZR,EACCC,IAPDsD,MAAAA,CAAWhD,MAAegG,MAAgBtG,IAAlCoD,MACPmD,EAAcxC,GAAU,MAAM,CAACT,EAAAA,CAAAA,GAU/B1F,MAAY6H,GACZA,GACAzF,GAAUwG,cAAAA,CACTlG,MAAegG,KACb,CAACA,EAAAA,IACD1I,KACA,OACAoC,GAAUyG,aACV3H,EAAM6F,KAAK3E,GAAUwF,UAAAA,IACrB,MACHpF,IAAAA,CACCE,MAAegG,KACbA,KACA1I,KACAA,GACAoC,MAAAA,GAAUyG,YACbnG,IACAC,EAAAA,GAID+D,EAAWlE,IAAakD,IAAO/C,EAAAA;EAC/B;AH3DemG,WAAAA,EAAcC,IAAcC,IAAAA;AAG3C,QAAMC,KAAU,EACfC,KAHDF,KAAY,SAASG,KAIpBC,IAAeL,IAEfM,UAJe,SAINC,IAAOC,IAAAA;AAIf,aAAOD,GAAME,SAASD,EAAAA;IACtB,GAEDE,UAAAA,SAASH,IAAAA;AAAAA,UAGHI,IACAC;AAsCL,aAzCKC,KAAKC,oBAELH,KAAO,CAAA,IACPC,KAAM,CAAV,GACIX,EAAAA,IAAaY,MAEjBA,KAAKC,kBAAkB,WAAA;AAAA,eAAMF;MAAN,GAEvBC,KAAKE,wBAAwB,SAAUC,IAAAA;AAClCH,aAAKN,MAAMU,UAAUD,GAAOC,SAe/BN,GAAKO,KAAK,SAAAC,IAAAA;AACTA,UAAAA,GAACC,MAAAA,MACDC,EAAcF,EAAAA;QACd,CAAA;MAEF,GAEDN,KAAKS,MAAM,SAAAH,IAAAA;AACVR,QAAAA,GAAKY,KAAKJ,EAAAA;AACV,YAAIK,KAAML,GAAEM;AACZN,QAAAA,GAAEM,uBAAuB,WAAA;AACxBd,UAAAA,GAAKe,OAAOf,GAAKgB,QAAQR,EAAAA,GAAI,CAAA,GACzBK,MAAKA,GAAII,KAAKT,EAAAA;QAClB;MACD,IAGKZ,GAAME;IACb,EAAA;AASF,WAAQP,GAAQQ,SAAuBR,KAAAA,GAAQI,SAASuB,cACvD3B;EACD;AL5CY4B,MAAQC,EAAUD,OCjBzBE,IAAU,EACfZ,KSHM,SAAqBa,IAAOC,IAAOC,IAAUC,IAAAA;AAQnD,aANIC,IAEHC,IAEAC,IAEOL,KAAQA,GAAhB7B;AACC,WAAKgC,KAAYH,GAAH/B,QAAAA,CAAyBkC,GAADhC;AACrC,YAAA;AAcC,eAbAiC,KAAOD,GAAUG,gBAE4B,QAAjCF,GAAKG,6BAChBJ,GAAUK,SAASJ,GAAKG,yBAAyBR,EAAAA,CAAAA,GACjDM,KAAUF,GAAHM,MAG2B,QAA/BN,GAAUO,sBACbP,GAAUO,kBAAkBX,IAAOG,MAAa,CAAhD,CAAA,GACAG,KAAUF,GACVM,MAGGJ;AACH,mBAAQF,GAASQ,MAAiBR;QAInC,SAFQS,IAAAA;AACRb,UAAAA,KAAQa;QACR;AAIH,UAAMb;EACN,EAAA,GRxCGc,IAAU,GAgGDC,IAAiB,SAAAd,IAAAA;AAC7BA,WAAS,QAATA,MAAsCe,QAArBf,GAAMM;EADW,GCxEnCU,EAAcC,UAAUT,WAAW,SAAUU,IAAQC,IAAAA;AAEpD,QAAIC;AAEHA,IAAAA,KADsB,QAAnBzC,KAAA0C,OAA2B1C,KAAA0C,QAAoB1C,KAAK2C,QACnD3C,KAAH0C,MAEG1C,KAAA0C,MAAkBE,EAAO,CAAD,GAAK5C,KAAK2C,KAAAA,GAGlB,cAAA,OAAVJ,OAGVA,KAASA,GAAOK,EAAO,CAAA,GAAIH,EAAAA,GAAIzC,KAAKN,KAAAA,IAGjC6C,MACHK,EAAOH,IAAGF,EAAAA,GAIG,QAAVA,MAEAvC,KAAJ6C,QACKL,MACHxC,KAAA8C,IAAqBpC,KAAK8B,EAAAA,GAE3BhC,EAAcR,IAAAA;EAEf,GAQDqC,EAAcC,UAAUS,cAAc,SAAUP,IAAAA;AAC3CxC,SAAAA,QAIHA,KAAAO,MAAAA,MACIiC,MAAUxC,KAAAgD,IAAsBtC,KAAK8B,EAAAA,GACzChC,EAAcR,IAAAA;EAEf,GAYDqC,EAAcC,UAAUW,SAASC,GA8F7BC,IAAgB,CAAA,GAadC,IACa,cAAA,OAAXC,UACJA,QAAQf,UAAUgB,KAAKC,KAAKF,QAAQG,QAAAA,CAAAA,IACpCC,YAuBEC,IAAY,SAACC,IAAGC,IAAAA;AAAMD,WAAAA,GAAAd,IAAAgB,MAAkBD,GAA5Bf,IAAAgB;EAAA,GAuBlBC,EAAOC,MAAkB,GCtNrBC,IAAa,GAkJXC,IAAaC,EAAAA,KAAiB,GAC9BC,IAAoBD,EAAAA,IAAiB,GC3KhC3E,IAAI;;;AOCO,iBAAA,OAAV6E,UAAyBA,OAAOC,uBAC1CD,OAAOC,oBAAoBC,aAAa,WAAWC,GAAS,EAC3DC,UAAAA,GACAC,WAAAA,EAAAA,CAAAA;;;ACNH,MAEIC,KAAqB,CAAA;ACMTC,WAAAA,GAAeC,IAAAA;AAC9B,WAAIA,GAAMC,SAASC,IACX,aACwB,cAAA,OAAdF,GAAMC,OAChBD,GAAMC,KAAKE,eAAeH,GAAMC,KAAKG,OACb,YAAA,OAAdJ,GAAMC,OAChBD,GAAMC,OAGP;EACP;AAMD,MAAII,KAAc,CAAA;AAAlB,MAoBIC,KAAa,CAAA;AAMDC,WAAAA,KAAAA;AACf,WAAOF,GAAYG,SAAS,IAAIH,GAAYA,GAAYG,SAAS,CAAA,IAAK;EACtE;AAQD,MAAIC,KAAAA;AAMJ,WAASC,GAAgBV,IAAAA;AACxB,WAA4B,cAAA,OAAdA,GAAMC,QAAsBD,GAAMC,QAAQC;EACxD;AAOeS,WAAAA,GAAcX,IAAAA;AAG7B,aAFMY,KAAQ,CAACZ,EAAAA,GACXa,KAAOb,IACW,QAAfa,GAAAC;AACNF,MAAAA,GAAMG,KAAKF,GAAXC,GAAAA,GACAD,KAAOA,GACPC;AAED,WAAOF,GAAMI,OAAO,SAACC,IAAKC,IAAAA;AACzBD,MAAAA,MAAG,UAAYlB,GAAemB,EAAAA;AAE9B,UAAMC,KAASD,GAAME;AAUrB,aATID,KACHF,MAAG,UAAYE,GAAOE,WAAnB,MAA+BF,GAAOG,aACzC,MAAUb,MACVc,QAAQC,KACP,gLAAA,GAGFf,KAAAA,OAEQQ,KAAO;IACf,GAAE,EAAA;EACH;ACnFD,MAAMQ,KAAuC,cAAA,OAAXC;AAMlC,WAASC,GAAe3B,IAAAA;AACvB,QAAI4B,KAAc,CAAA;AAElB,WAAK5B,GAAD6B,OAEJ7B,GAAK6B,IAAWC,QAAQ,SAAAC,IAAAA;AACnBA,MAAAA,MAA+B,cAAA,OAAfA,GAAM9B,OACzB2B,GAAYb,KAAKiB,MAAMJ,IAAaD,GAAeI,EAAAA,CAAAA,IACzCA,MAA+B,YAAA,OAAfA,GAAM9B,QAChC2B,GAAYb,KAAKgB,GAAM9B,IAAAA;IAExB,CAAA,GAEM2B,MAVsBA;EAW7B;AAMD,WAASK,GAA4BC,IAAAA;AACpC,WAAKA,KACqB,cAAA,OAAfA,GAAOjC,OACM,SAAnBiC,GAAMC,KACW,SAAhBD,GAAAA,OAAmD,SAA3BA,GAAAE,IAAYC,aAChCH,GAAME,IAAMC,WAAWC,YAExB,KAEDL,GAA4BC,GAADC,EAAAA,IAELD,GAAOjC,OAVjB;EAWpB;AA4bD,MAAMsC,KAAWC,EAAUC,UAAUF;AAmBrC,WAASG,GAAezC,IAAAA;AACvB,WACU,YAATA,MACS,YAATA,MACS,YAATA,MACS,YAATA,MACS,SAATA,MACS,SAATA,MACS,SAATA;EAED;AA5BDuC,IAAUC,UAAUF,WAAW,SAAUI,IAAQC,IAAAA;AAehD,WAdmB,QAAfC,KAAAA,OAKe,QAAdA,KAAKC,SACRvB,QAAQC,KACP,kKAEmCb,GAAcJ,GAAAA,CAAAA,CAAAA,GAK7CgC,GAASQ,KAAKF,MAAMF,IAAQC,EAAAA;EACnC;AAcD,MAAMI,IACL;AADD,MAGMC,KAAcT,EAAUC,UAAUQ;AAyBxBC,WAAAA,GAAelD,IAAAA;AAC9B,QAAMmD,KAAUnD,GAAVmD,OACF/C,KAAOL,GAAeC,EAAAA,GAEtBoD,KAAQ;AACZ,aAASC,MAAQF;AAChB,UAAIA,GAAMG,eAAeD,EAAAA,KAAkB,eAATA,IAAqB;AACtD,YAAIE,KAAQJ,GAAME,EAAAA;AAGE,sBAAA,OAATE,OACVA,KAAoBA,eAAAA,GAAMpD,eAAeoD,GAAMnD,QAA1C,UAGNmD,KACCC,OAAOD,EAAAA,MAAWA,MAAUA,GAAME,WAE/BF,KAAQ,KADRC,OAAOf,UAAUgB,SAASV,KAAKQ,EAAAA,GAGnCH,MAAK,MAAQC,KAAR,MAAgBK,KAAKC,UAAUJ,EAAAA;MACpC;AAGF,QAAIK,KAAWT,GAAMS;AACrB,WAAWxD,MAAAA,KAAOgD,MACjBQ,MAAYA,GAASpD,SAAS,UAAUJ,KAAO,MAAM;EAEtD;AAnDDoC,IAAUC,UAAUQ,cAAc,SAAUL,IAAAA;AAgB3C,WAfmB,QAAfC,KAAAgB,MACHtC,QAAQC,KACP,4HACqDb,GACnDJ,GAAAA,CAAAA,CAAAA,IAG0B,QAAnBsC,KAAAA,OACVtB,QAAQC,KACP;;IAGQb,GAAckC,KAHtBgB,GAAAA,CAAAA,GAMKZ,GAAYF,KAAKF,MAAMD,EAAAA;EAC9B,GA9eM,WAAA;AAAA,KDkDSkB,WAAAA;AACf,UAAIC,KAAUC,EAAdC,KACIC,KAAYF,EAAQG,QACpBC,KAAUJ,EAAH7B,IACPkC,KAAWL,EAAQhE,OACnBsE,KAAYN,EAAHO;AAEbP,QAAQG,SAAS,SAAAnE,IAAAA;AACZU,QAAAA,GAAgBV,EAAAA,KACnBM,GAAWkE,IAAAA,GAEZnE,GAAYmE,IAAAA,GACRN,MAAWA,GAAUlE,EAAAA;MACzB,GAEDgE,EAAAC,MAAgB,SAAAjE,IAAAA;AACXU,QAAAA,GAAgBV,EAAAA,KACnBK,GAAYU,KAAKf,EAAAA,GAEd+D,MAASA,GAAQ/D,EAAAA;MACrB,GAEDgE,EAAA7B,KAAgB,SAACnC,IAAOkC,IAAAA;AACvB5B,QAAAA,KAAa,CAAA,GACT8D,MAASA,GAAQpE,IAAOkC,EAAAA;MAC5B,GAED8B,EAAQhE,QAAQ,SAAAA,IAAAA;AACfA,QAAAA,GAAAc,MACCR,GAAWE,SAAS,IAAIF,GAAWA,GAAWE,SAAS,CAAA,IAAK,MACzD6D,MAAUA,GAASrE,EAAAA;MACvB,GAEDgE,EAAOO,MAAW,SAAAvE,IAAAA;AACbU,QAAAA,GAAgBV,EAAAA,KACnBM,GAAWS,KAAKf,EAAAA,GAGbsE,MAAWA,GAAUtE,EAAAA;MACzB;IACD,ECzFA8D;AAEA,QAAIW,KAAAA,OAGAC,KAAgBV,EAAHC,KACbC,KAAYF,EAAQG,QACpBQ,KAAWX,EAAQhE,OACnBsE,KAAYN,EAAhBO,KACIK,KAAgBZ,EAApB5B,KACIgC,KAAUJ,EAAd7B,IACI0C,KAAUb,EAAdc,KACMC,IAAoBtD,KAEvB,EACAuD,WAAW,oBAAItD,WACfuD,iBAAiB,oBAAIvD,WACrBwD,eAAe,oBAAIxD,UAAAA,IAJnB,MAMGyD,KAAe,CAAA;AAErBnB,MAAO5B,MAAe,SAACgD,IAAOpF,IAAOqE,IAAUgB,IAAAA;AAE9C,UADgBrF,MAASA,GAAzBsF,OACsC,cAAA,OAAdF,GAAMG,MAAoB;AACjD,YAAMC,KAAUJ;AAChBA,QAAAA,KAAQ,IAAIK,MACsC1F,mDAAAA,GAAeC,EAAAA,CAAAA;AAIjE,iBADIkC,KAASlC,IACNkC,IAAQA,KAASA,GAAHC;AACpB,cAAID,GAAAoD,OAAqBpD,GAAzBoD,IAAAA,KAA6D;AAC5DF,YAAAA,KAAQI;AACR;UACA;AAKF,YAAIJ,cAAiBK;AACpB,gBAAML;MAEP;AAED,UAAA;AAAA,SACCC,KAAYA,MAAa,CAAzB,GACUK,iBAAiB/E,GAAcX,EAAAA,GACzC4E,GAAcQ,IAAOpF,IAAOqE,IAAUgB,EAAAA,GAKb,cAAA,OAAdD,GAAMG,QAChBI,WAAW,WAAA;AACV,gBAAMP;QACN,CAAA;MAIF,SAFQQ,IAAAA;AACR,cAAMA;MACN;IACD,GAED5B,EAAA7B,KAAgB,SAACnC,IAAOqC,IAAAA;AACvB,UAAA,CAAKA;AACJ,cAAM,IAAIoD,MACT,qIAAA;AAKF,UAAII;AACJ,cAAQxD,GAAWyD,UAAAA;QAClB,KChIyB;QDiIzB,KC/HmC;QDgInC,KCjI0B;ADkIzBD,UAAAA,KAAAA;AACA;QACD;AACCA,UAAAA,KAAAA;MAAU;AAGZ,UAAA,CAAKA,IAAS;AACb,YAAIE,KAAgBhG,GAAeC,EAAAA;AACnC,cAAUyF,IAAAA,MAC8DpD,yEAAAA,KAA+B0D,uBAAAA,KAAqB1D,UAAAA,KAE5H,IAAA;MAAA;AAEG+B,MAAAA,MAASA,GAAQpE,IAAOqC,EAAAA;IAC5B,GAED2B,EAAAC,MAAgB,SAAAjE,IAAAA;AACf,UAAMC,KAASD,GAATC;AAIN,UAFAwE,KAAAA,MAAe,WAEXxE;AACH,cAAA,IAAUwF,MACT,iJAECvC,GAAelD,EAAAA,IAFhB,SAGQW,GAAcX,EAAAA,CAAAA;AAEjB,UAAY,QAARC,MAA+B,YAAA,OAARA,IAAkB;AACnD,YAAA,WAAIA,GAAA4B,OAAAA,WAAgC5B,GAAAmC;AACnC,gBAAA,IAAUqD,MACT,6CAA2CxF,KAA3C,0EAEYF,GAAeC,EAAAA,IAF3B,QAEuCkD,GAAejD,EAAAA,IAFtD,yBAGqBF,GAAeC,EAAAA,IAHpC,0FAKQW,GAAcX,EAAAA,CAAAA;AAIxB,cAAUyF,IAAAA,MACT,8CACEO,MAAMC,QAAQhG,EAAAA,IAAQ,UAAUA,GAAAA;MAEnC;AAED,UAAA,WACCD,GAAMkG,OACc,cAAA,OAAblG,GAAMkG,OACO,YAAA,OAAblG,GAAMkG,OAAAA,EACX,cAAclG;AAEhB,cAAUyF,IAAAA,MACT,oGAAA,OACoCzF,GAAMkG,MAD1C,gBAEChD,GAAelD,EAAAA,IAFhB,SAGQW,GAAcX,EAAAA,CAAAA;AAIxB,UAAyB,YAAA,OAAdA,GAAMC;AAChB,iBAAWkG,MAAOnG,GAAMmD;AACvB,cACY,QAAXgD,GAAI,CAAA,KACO,QAAXA,GAAI,CAAA,KACuB,cAAA,OAApBnG,GAAMmD,MAAMgD,EAAAA,KACC,QAApBnG,GAAMmD,MAAMgD,EAAAA;AAEZ,kBAAM,IAAIV,MACT,kBAAgBU,KAAhB,+CAAA,OACoBnG,GAAMmD,MAAMgD,EAAAA,IAC/BjD,gBAAAA,GAAelD,EAAAA,IACRW,SAAAA,GAAcX,EAAAA,CAAAA;;AAO1B,UAAyB,cAAA,OAAdA,GAAMC,QAAsBD,GAAMC,KAAKmG,WAAW;AAC5D,YAC4B,WAA3BpG,GAAMC,KAAKE,eACX4E,KAAAA,CACCA,EAAiBG,cAAcmB,IAAIrG,GAAMC,IAAAA,GACzC;AACD,cAAMqG,KACL;AACD,cAAA;AACC,gBAAMC,KAAYvG,GAAMC,KAAAA;AACxB8E,cAAiBG,cAAcsB,IAAIxG,GAAMC,MAAAA,IAAM,GAC/CsB,QAAQC,KACP8E,KAAsCvG,oCAAAA,GAAewG,EAAAA,CAAAA;UAMtD,SAJQf,IAAAA;AACRjE,oBAAQC,KACP8E,KAAI,6DAAA;UAEL;QACD;AAED,YAAIG,KAASzG,GAAMmD;AACfnD,QAAAA,GAAMC,KAAiByG,OAAAA,QAC1BD,KAAAA,SElOmBE,IAAKxD,IAAAA;AAC3B,mBAASyD,MAAKzD;AAAOwD,YAAAA,GAAIC,EAAAA,IAAKzD,GAAMyD,EAAAA;AACpC,iBAA6BD;QAC7B,EF+NmB,CAAA,GAAIF,EAAAA,GACNP,KFnNFW,SACfC,IACAL,IACAM,IACAhB,IACAiB,IAAAA;AAEAxD,iBAAOyD,KAAKH,EAAAA,EAAWhF,QAAQ,SAAAoF,IAAAA;AAC9B,gBAAI9B;AACJ,gBAAA;AACCA,cAAAA,KAAQ0B,GAAUI,EAAAA,EACjBT,IACAS,IACAnB,IE4MA,QF1MA,MAtCyB,8CAAA;YA2C1B,SAFQH,IAAAA;AACRR,cAAAA,KAAQQ;YACR;AACGR,YAAAA,MAAAA,EAAWA,GAAM+B,WAAWC,QAC/BA,GAAmBhC,GAAM+B,OAAAA,IAAAA,MACzB5F,QAAQ6D,MACG2B,uBAAkB3B,GAAM+B,WAChCH,MAAiBA,OAAAA,GAAAA,KAAiB,GAAA;UAItC,CAAA;QACD,EEyLGhH,GAAMC,KAAKmG,WACXK,IACA,GACA1G,GAAeC,EAAAA,GACf,WAAA;AAAA,iBAAMW,GAAcX,EAAAA;QAApB,CAAA;MAED;AAEG0E,MAAAA,MAAeA,GAAc1E,EAAAA;IACjC;AAED,QACIqH,IADAC,KAAc;AAElBtD,MAAAO,MAAkB,SAAAvE,IAAAA;AACbsE,MAAAA,MACHA,GAAUtE,EAAAA,GAEXyE,KAAAA;AAEA,UAAM8C,KAAgBvH,GAAHsF;AAOnB,UANIiC,OAAkBF,KACrBC,OAEAA,KAAc,GAGXA,MAAe;AAClB,cAAU7B,IAAAA,MACT,qIACmE1F,GACjEC,EAAAA,CAAAA;AAKJqH,MAAAA,KAAmBE;IACnB,GAEDvD,EAAAc,MAAgB,SAAC0C,IAAMC,IAAOxH,IAAAA;AAC7B,UAAA,CAAKuH,MAAAA,CAAS/C;AACb,cAAM,IAAIgB,MAAM,+CAAA;AAGbZ,MAAAA,MAASA,GAAQ2C,IAAMC,IAAOxH,EAAAA;IAClC;AAMD,QAAMuB,KAAO,SAACkG,IAAUP,IAAAA;AAAX,aAAwB,EACpCQ,KADoC,WAAA;AAEnC,YAAMxB,KAAM,QAAQuB,KAAWP;AAC3BhC,QAAAA,MAAgBA,GAAayC,QAAQzB,EAAAA,IAAO,MAC/ChB,GAAapE,KAAKoF,EAAAA,GAClB5E,QAAQC,KAAsBkG,mBAAAA,KAAAA,qBAA2BP,EAAAA;MAE1D,GACDX,KAAM,WAAA;AACL,YAAML,KAAM,QAAQuB,KAAWP;AAC3BhC,QAAAA,MAAgBA,GAAayC,QAAQzB,EAAAA,IAAO,MAC/ChB,GAAapE,KAAKoF,EAAAA,GAClB5E,QAAQC,KAAR,mBAA8BkG,KAA9B,sBAA0DP,EAAAA;MAE3D,EAAA;IAdW,GAiBPU,KAAuB,EAC5BC,UAAUtG,GAAK,YAAY,gBAAA,GAC3BuG,YAAYvG,GAAK,cAAc,iBAAA,GAC/BoC,UAAUpC,GAAK,YAAY,0BAAA,EAAA,GAGtBwG,KAAkBxE,OAAOyE,OAAO,CAAd,GAAkBJ,EAAAA;AAE1C7D,MAAQhE,QAAQ,SAAAA,IAAAA;AACf,UAAMmD,KAAQnD,GAAMmD;AACpB,UACgB,SAAfnD,GAAMC,QACG,QAATkD,OACC,cAAcA,MAAS,YAAYA,KACnC;AACD,YAAM+E,KAAYlI,GAAMmD,QAAQ,CAAhC;AACA,iBAASyD,MAAKzD,IAAO;AACpB,cAAMgF,KAAIhF,GAAMyD,EAAAA;AACN,yBAANA,KAAkB5G,GAAMoB,WAAW+G,KACxB,aAANvB,KAAgB5G,GAAMoI,SAASD,KACnCD,GAAStB,EAAAA,IAAKuB;QACnB;MACD;AAGDnI,MAAAA,GAAMqI,YAAYL,IACdrD,MAAUA,GAAS3E,EAAAA;IACvB,GAEDgE,EAAQG,SAAS,SAAAnE,IAAAA;AAChB,UEnUoBuD,IFmUZtD,KAA0BD,GAA1BC,MAAeiC,KAAWlC,GAQlCmC;AAgBA,UAhBInC,GAAJ6B,OACC7B,GAAA6B,IAAgBC,QAAQ,SAAAC,IAAAA;AACvB,YAAqB,YAAA,OAAVA,MAAsBA,MAAAA,WAASA,GAAM9B,MAAoB;AACnE,cAAMgH,KAAOzD,OAAOyD,KAAKlF,EAAAA,EAAOuG,KAAK,GAAA;AACrC,gBAAM,IAAI7C,MACT,4EAA0EwB,KAA1E,WACQtG,GAAcX,EAAAA,CAAAA;QAEvB;MACD,CAAA,GAGEA,GAAAsF,QAAqB+B,OACxBC,KAAc,IAIE,YAAA,OAATrH,OACNyC,GAAezC,EAAAA,KACN,QAATA,MACS,QAATA,MACS,aAATA,KACA;AAMD,YAAIsI,KAAgBtG,GAA4BC,EAAAA;AAChD,YAAsB,OAAlBqG;AAEO,sBAATtI,MAGkB,SAAlBsI,MACA7F,GAAe6F,EAAAA,KAEfhH,QAAQiH,IAAID,IAAerG,GAA3BE,GAAAA,GACAb,QAAQ6D,MACP,iFACClC,GAAelD,EAAAA,IACRW,SAAAA,GAAcX,EAAAA,CAAAA,KAGb,YAATC,MAA6B,YAATA,MAA6B,YAATA,MACvB,YAAlBsI,KAQS,SAATtI,MACkB,YAAlBsI,MACkB,YAAlBA,MACkB,YAAlBA,KAEAhH,QAAQ6D,MACP,mFACClC,GAAelD,EAAAA,IADhB,SAEQW,GAAcX,EAAAA,CAAAA,IAEJ,SAATC,MAAmC,SAAlBsI,KAC3BhH,QAAQ6D,MACP,oEACClC,GAAelD,EAAAA,IADhB,SAEQW,GAAcX,EAAAA,CAAAA,IAEJ,SAATC,MAAmC,SAAlBsI,MAC3BhH,QAAQ6D,MACP,6DACClC,GAAelD,EAAAA,IACRW,SAAAA,GAAcX,EAAAA,CAAAA,IA1BvBuB,QAAQ6D,MACP,sFACClC,GAAelD,EAAAA,IADhB,SAEQW,GAAcX,EAAAA,CAAAA;iBA0BL,QAATC,IAAc;AACxB,cAAIwI,KAA0B9G,GAAe3B,EAAAA,EAAO0I,OAAO,SAAAC,IAAAA;AAC1D3F,mBAAAA,EAAiC4F,KAAKD,EAAAA;UAD6B,CAAA;AAGhEF,UAAAA,GAAwBjI,UAC3Be,QAAQ6D,MACP,6DACCqD,GAAwBH,KAAK,IAAA,IAC7B,uBACApF,GAAelD,EAAAA,IAHhB,SAIQW,GAAcX,EAAAA,CAAAA;QAGxB;AAAmB,kBAATC,MAAyB,aAATA,MAAAA,OACtB0B,GAAe3B,EAAAA,EAAO4H,QAAQ3H,EAAAA,KACjCsB,QAAQ6D,MACP,oDAAkDnF,KAAlD,8BACoC,QAATA,KAAe,WAAW,YACpD,6BACAiD,GAAelD,EAAAA,IAHhB,SAIQW,GAAcX,EAAAA,CAAAA;MAIzB;AAMD,UAJAyE,KAAAA,OAEIP,MAAWA,GAAUlE,EAAAA,GAEF,QAAnBA,GAAA6B;AAEH,iBADMoF,KAAO,CAAA,GACJL,KAAI,GAAGA,KAAI5G,GAAK6B,IAAWrB,QAAQoG,MAAK;AAChD,cAAM7E,KAAQ/B,GAAA6B,IAAgB+E,EAAAA;AAC9B,cAAK7E,MAAsB,QAAbA,GAAMoE,KAApB;AAEA,gBAAMA,KAAMpE,GAAMoE;AAClB,gBAAA,OAAIc,GAAKW,QAAQzB,EAAAA,GAAa;AAC7B5E,sBAAQ6D,MACP,gFACyBe,KADzB,qFAGCjD,GAAelD,EAAAA,IAHhB,SAIQW,GAAcX,EAAAA,CAAAA;AAIvB;YACA;AAEDiH,YAAAA,GAAKlG,KAAKoF,EAAAA;UAdV;QAeA;AAGF,UAAwB,QAApBnG,GAAKsF,OAAmD,QAA5BtF,GAAAA,IAA4B6I,KAAM;AAGjE,YAAMC,KAAQ9I,GAAdsF,IAAAuD,IAAA1G;AACA,YAAI2G;AACH,mBAASlC,KAAI,GAAGA,KAAIkC,GAAMtI,QAAQoG,MAAK,GAAG;AACzC,gBAAMmC,KAAOD,GAAMlC,EAAAA;AACnB,gBAAImC,GAAAA;AACH,uBAASC,KAAI,GAAGA,KAAID,GAAAF,IAAWrI,QAAQwI;AAEtC,qBEvdezF,KFsdHwF,GAAAF,IAAWG,EAAAA,MErdZzF,IFsdK;AACf,sBAAMwC,KAAgBhG,GAAeC,EAAAA;AACrC,wBAAM,IAAIyF,MACmGmB,8GAAAA,KAAkBb,mBAAAA,KAAAA,uBAAAA;gBAE/H;;UAGH;MAEF;IACD;EACD,EG5eDkD;;;ACAA,MAAIC;AAAJ,MAGIC;AAHJ,MAMIC;AANJ,MA2BIC;AA3BJ,MASIC,KAAc;AATlB,MAYIC,KAAoB,CAAA;AAZxB,MAcIC,KAAQ,CAAA;AAdZ,MAiBMC,KAAuDC;AAjB7D,MAmBIC,KAAgBF,GAApBG;AAnBA,MAoBIC,KAAkBJ,GAAHK;AApBnB,MAqBIC,KAAeN,GAAQO;AArB3B,MAsBIC,KAAYR,GAAHS;AAtBb,MAuBIC,KAAmBV,GAAQW;AAvB/B,MAwBIC,KAAUZ,GAAHa;AAmHX,WAASC,GAAaC,IAAOC,IAAAA;AACxBhB,IAAAA,GAAeiB,OAClBjB,GAAOiB,IAAOvB,IAAkBqB,IAAOlB,MAAemB,EAAAA,GAEvDnB,KAAc;AAOd,QAAMqB,KACLxB,GAAAyB,QACCzB,GAAgByB,MAAW,EAC3BN,IAAO,CAAA,GACPI,KAAiB,CAAA,EAAA;AAOnB,WAJIF,MAASG,GAAKL,GAAOO,UACxBF,GAAAL,GAAYQ,KAAK,EAAEC,KAAevB,GAAAA,CAAAA,GAG5BmB,GAAAL,GAAYE,EAAAA;EACnB;AAOeQ,WAAAA,GAASC,IAAAA;AAExB,WADA3B,KAAc,GACP4B,GAAWC,GAAgBF,EAAAA;EAClC;AAAA,WAUeC,GAAWE,IAASH,IAAcI,IAAAA;AAEjD,QAAMC,KAAYf,GAAarB,MAAgB,CAAA;AAE/C,QADAoC,GAAUC,IAAWH,IAAAA,CAChBE,GAADpB,QACHoB,GAAShB,KAAU,CACjBe,KAAiDA,GAAKJ,EAAAA,IAA/CE,EAAAA,QAA0BF,EAAAA,GAElC,SAAAO,IAAAA;AACC,UAAMC,KAAeH,GAAAI,MAClBJ,GAASI,IAAY,CAAA,IACrBJ,GAAShB,GAAQ,CAAA,GACdqB,KAAYL,GAAUC,EAASE,IAAcD,EAAAA;AAE/CC,MAAAA,OAAiBE,OACpBL,GAAAI,MAAuB,CAACC,IAAWL,GAAAhB,GAAiB,CAAA,CAAA,GACpDgB,GAAApB,IAAqB0B,SAAS,CAA9B,CAAA;IAED,CAAA,GAGFN,GAAApB,MAAuBf,IAAAA,CAElBA,GAAiB0C,IAAkB;AAgC9BC,UAAAA,KAAT,SAAyBC,IAAGC,IAAGC,IAAAA;AAC9B,YAAA,CAAKX,GAADpB,IAAAU;AAA+B,iBAAA;AAGnC,YACMsB,KACLZ,GAASpB,IAA0BiC,IAAAA,GAAAA,OAFhB,SAAAC,IAAAA;AAAK,iBAAA,CAAA,CAAEA,GAADlC;QAAL,CAAA;AAOrB,YAHsBgC,GAAWG,MAAM,SAAAD,IAAAA;AAAC,iBAAA,CAAKA,GAAAA;QAAL,CAAA;AAIvC,iBAAA,CAAOE,MAAUA,GAAQC,KAAKC,MAAMT,IAAGC,IAAGC,EAAAA;AAM3C,YAAIQ,KAAAA;AAUJ,eATAP,GAAWQ,QAAQ,SAAAC,IAAAA;AAClB,cAAIA,GAAqBjB,KAAA;AACxB,gBAAMD,KAAekB,GAAArC,GAAgB,CAAA;AACrCqC,YAAAA,GAAArC,KAAkBqC,GAAlBjB,KACAiB,GAAAjB,MAAAA,QACID,OAAiBkB,GAAArC,GAAgB,CAAA,MAAImC,KAAAA;UACzC;QACD,CAAA,GAAA,EAAA,CAEMA,MAAgBnB,GAASpB,IAAY0C,UAAUb,QAAAA,CACnDO,MACCA,GAAQC,KAAKC,MAAMT,IAAGC,IAAGC,EAAAA;MAG7B;AAhED9C,MAAAA,GAAiB0C,IAAAA;AACjB,UAAIS,KAAUnD,GAAiB0D,uBACzBC,KAAU3D,GAAiB4D;AAKjC5D,MAAAA,GAAiB4D,sBAAsB,SAAUhB,IAAGC,IAAGC,IAAAA;AACtD,YAAIO,KAAaQ,KAAA;AAChB,cAAIC,KAAMX;AAEVA,UAAAA,KAAAA,QACAR,GAAgBC,IAAGC,IAAGC,EAAAA,GACtBK,KAAUW;QACV;AAEGH,QAAAA,MAASA,GAAQP,KAAKC,MAAMT,IAAGC,IAAGC,EAAAA;MACtC,GAiDD9C,GAAiB0D,wBAAwBf;IACzC;AAGF,WAAOR,GAAAI,OAAwBJ,GAAxBhB;EACP;AAOe4C,WAAAA,GAAUC,IAAUC,IAAAA;AAEnC,QAAMC,KAAQ9C,GAAarB,MAAgB,CAAA;AAAA,KACtCO,GAAwB6D,OAAAA,GAAYD,GAAaD,KAAAA,EAAAA,MACrDC,GAAA/C,KAAe6C,IACfE,GAAME,IAAeH,IAErBjE,GAAAyB,IAAAF,IAAyCI,KAAKuC,EAAAA;EAE/C;AA2JD,WAASG,KAAAA;AAER,aADIC,IACIA,KAAYC,GAAkBC,MAAAA;AACrC,UAAKF,GAAwBG,OAACH,GAADI;AAC7B,YAAA;AACCJ,UAAAA,GAAAI,IAAAC,IAAkCC,QAAQC,EAAAA,GAC1CP,GAASI,IAAyBE,IAAAA,QAAQE,EAAAA,GAC1CR,GAAAA,IAAoCK,MAAA,CAAA;QAIpC,SAHQI,IAAAA;AACRT,UAAAA,GAAAI,IAAAC,MAAoC,CAAA,GACpCK,GAAOC,IAAaF,IAAGT,GAAvBY,GAAAA;QACA;EAEF;AA/aDF,EAAAA,GAAOG,MAAS,SAAAC,IAAAA;AACfC,IAAAA,KAAmB,MACfC,MAAeA,GAAcF,EAAAA;EACjC,GAEDJ,GAAAA,KAAgB,SAACI,IAAOG,IAAAA;AACnBH,IAAAA,MAASG,GAAJC,OAA2BD,GAAAA,IAAAA,QACnCH,GAAKK,MAASF,GACdC,IAAAC,MAEGC,MAASA,GAAQN,IAAOG,EAAAA;EAC5B,GAGDP,GAAOW,MAAW,SAAAP,IAAAA;AACbQ,IAAAA,MAAiBA,GAAgBR,EAAAA,GAGrCS,KAAe;AAEf,QAAMC,MAHNT,KAAmBD,GAAHW,KAGLrB;AACPoB,IAAAA,OACCE,OAAsBX,MACzBS,GAAKnB,MAAmB,CAAA,GACxBU,GAAAV,MAAoC,CAAA,GACpCmB,GAAKG,GAAOrB,QAAQ,SAAAsB,IAAAA;AACfA,MAAAA,GAAqBC,QACxBD,GAAQD,KAAUC,GAClBC,MACDD,GAAAE,MAAyBC,IACzBH,GAAQC,MAAcD,GAASI,IAAAA;IAC/B,CAAA,MAEDR,GAAKnB,IAAiBC,QAAQC,EAAAA,GAC9BiB,GAAAnB,IAAsBC,QAAQE,EAAAA,GAC9BgB,GAAAnB,MAAwB,CAAA,GACxBkB,KAAe,KAGjBG,KAAoBX;EACpB,GAGDL,GAAQuB,SAAS,SAAAnB,IAAAA;AACZoB,IAAAA,MAAcA,GAAapB,EAAAA;AAE/B,QAAMqB,KAAIrB,GAAHW;AACHU,IAAAA,MAAKA,GAAJ/B,QACA+B,GAAC/B,IAAyBgC,IAAAA,WAoaR,MApa2BnC,GAAkBoC,KAAKF,EAAAA,KAoa7CG,OAAY5B,GAAQ6B,2BAC/CD,KAAU5B,GAAQ6B,0BACNC,IAAgBzC,EAAAA,IAra5BoC,GAAC/B,IAAeE,GAAAA,QAAQ,SAAAsB,IAAAA;AACnBA,MAAAA,GAASI,MACZJ,GAAQxB,MAASwB,GAASI,IAEvBJ,GAAQE,QAAmBC,OAC9BH,GAAAD,KAAkBC,GAAlBE,MAEDF,GAASI,IAAAA,QACTJ,GAAAA,MAAyBG;IACzB,CAAA,IAEFL,KAAoBX,KAAmB;EACvC,GAIDL,GAAOe,MAAW,SAACX,IAAO2B,IAAAA;AACzBA,IAAAA,GAAYC,KAAK,SAAA1C,IAAAA;AAChB,UAAA;AACCA,QAAAA,GAAAK,IAA2BC,QAAQC,EAAAA,GACnCP,GAASK,MAAoBL,GAAAK,IAA2BsC,OAAO,SAAAC,IAAAA;AAAE,iBAAA,CAChEA,GAAAjB,MAAYnB,GAAaoC,EAAAA;QADuC,CAAA;MASjE,SANQnC,IAAAA;AACRgC,QAAAA,GAAYC,KAAK,SAAAP,IAAAA;AACZA,UAAAA,GAAJ9B,QAAwB8B,GAAC9B,MAAoB,CAAA;QAC7C,CAAA,GACDoC,KAAc,CAAA,GACd/B,GAAOC,IAAaF,IAAGT,GAAvBY,GAAAA;MACA;IACD,CAAA,GAEGiC,MAAWA,GAAU/B,IAAO2B,EAAAA;EAChC,GAGD/B,GAAQoC,UAAU,SAAAhC,IAAAA;AACbiC,IAAAA,MAAkBA,GAAiBjC,EAAAA;AAEvC,QAEKkC,IAFCb,KAAIrB,GAAHW;AACHU,IAAAA,MAAKA,GAAT/B,QAEC+B,GAAA/B,IAAAuB,GAAgBrB,QAAQ,SAAA2C,IAAAA;AACvB,UAAA;AACC1C,QAAAA,GAAc0C,EAAAA;MAGd,SAFQxC,IAAAA;AACRuC,QAAAA,KAAavC;MACb;IACD,CAAA,GACD0B,GAAA/B,MAAAA,QACI4C,MAAYtC,GAAAC,IAAoBqC,IAAYb,GAChDvB,GAAAA;EACD;AA4UD,MAAIsC,KAA0C,cAAA,OAAzBX;AAYrB,WAASC,GAAeW,IAAAA;AACvB,QAOIC,IAPEC,KAAO,WAAA;AACZC,mBAAaC,EAAAA,GACTL,MAASM,qBAAqBJ,EAAAA,GAClCK,WAAWN,EAAAA;IACX,GACKI,KAAUE,WAAWJ,IAvcR,GAAA;AA0cfH,IAAAA,OACHE,KAAMb,sBAAsBc,EAAAA;EAE7B;AAqBD,WAAS9C,GAAcmD,IAAAA;AAGtB,QAAMC,KAAO5C,IACT6C,KAAUF,GAAHjC;AACW,kBAAA,OAAXmC,OACVF,GAAIjC,MAAAA,QACJmC,GAAAA,IAGD7C,KAAmB4C;EACnB;AAOD,WAASnD,GAAakD,IAAAA;AAGrB,QAAMC,KAAO5C;AACb2C,IAAAA,GAAAjC,MAAgBiC,GAAI/B,GAAAA,GACpBZ,KAAmB4C;EACnB;AAOD,WAASE,GAAYC,IAASC,IAAAA;AAC7B,WAAA,CACED,MACDA,GAAQ1B,WAAW2B,GAAQ3B,UAC3B2B,GAAQrB,KAAK,SAACsB,IAAKC,IAAAA;AAAN,aAAgBD,OAAQF,GAAQG,EAAAA;IAAhC,CAAA;EAEd;AAQD,WAASC,EAAeF,IAAKG,IAAAA;AAC5B,WAAmB,cAAA,OAALA,KAAkBA,GAAEH,EAAAA,IAAOG;EACzC;;;AC3hBD,MAAM,oBAAoB;AAC1B,MAAM,sBAAsB,IAAI,OAAO,iBAAiB;AAEjD,WAAS,WAAWC,IAAoB;AAC7C,WAAO,oBAAoB,KAAKA,EAAC;AAAA,EACnC;AAOO,WAAS,WAAW,OAAuB;AAChD,QAAI,CAAC,WAAW,KAAK;AAAG,YAAM,IAAI,MAAM,IAAI,KAAK,iCAAiC;AAClF,WAAO,IAAI,OAAO,IAAI,KAAK,MAAM,iBAAiB,EAAE;AAAA,EACtD;;;ACnBO,MAAM,YAAN,MAEP;AAAA,IAME,YACkB,MACA,WACA,SAChB;AAHgB;AACA;AACA;AAEhB,UAAI,CAAC,WAAW,IAAI;AAAG,cAAM,IAAI,MAAM,IAAI,IAAI,iCAAiC;AAAA,IAClF;AAAA,IAXS,QAAiC,oBAAI,IAAI;AAAA,IAEzC,WAAqC,oBAAI,IAAI;AAAA,IAC7C,SAAmC,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,IAcpD,IAAI,WAAmB;AACrB,YAAMC,KAAI,KAAK;AACf,YAAM,OAAO,KAAK,UAAU;AAC5B,YAAM,KAAK,KAAK,QAAQ;AACxB,aAAO,GAAGA,EAAC,IAAI,IAAI,IAAI,EAAE;AAAA,IAC3B;AAAA,IAEA,IAAI,MAAgB,IAAY,OAAyB;AACvD,YAAM,MAAM,KAAK,SAAS,MAAM,EAAE;AAClC,WAAK,MAAM,IAAI,KAAK,KAAK;AACzB,WAAK,gBAAgB,MAAM,IAAI,KAAK;AACpC,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,MAAgB,IAAoC;AACtD,UAAI,CAAC,KAAK,YAAY,MAAM,EAAE;AAAG,cAAM,IAAI,MAAM,0BAA0B,IAAI,OAAO,EAAE,GAAG;AAC3F,aAAO,KAAK,MAAM,IAAI,KAAK,SAAS,MAAM,EAAE,CAAC;AAAA,IAC/C;AAAA,IAEA,IAAI,MAAgB,IAAqB;AACvC,UAAI,CAAC,KAAK,YAAY,MAAM,EAAE;AAAG,eAAO;AACxC,aAAO,KAAK,MAAM,IAAI,KAAK,SAAS,MAAM,EAAE,CAAC;AAAA,IAC/C;AAAA,IAEA,OAAO,MAAgB,IAAqB;AAC1C,WAAK,gBAAgB,MAAM,IAAI,QAAQ;AACvC,aAAO,KAAK,MAAM,OAAO,KAAK,SAAS,MAAM,EAAE,CAAC;AAAA,IAClD;AAAA;AAAA,IAGA,QAAQ,MAAgB,IAAiC;AACvD,YAAM,MAAM,KAAK,SAAS,MAAM,EAAE;AAClC,UAAI,QAAQ,KAAK,MAAM,IAAI,GAAG;AAC9B,UAAI,CAAC,OAAO;AACV,aAAK,MAAM,IAAI,KAAM,QAAQ,CAAC,CAAgB;AAAA,MAChD;AACA,WAAK,gBAAgB,MAAM,IAAI,KAAK;AACpC,aAAO;AAAA,IACT;AAAA,IAEA,MAAM,MAAgB,IAAY,OAAiD;AACjF,YAAM,MAAM,KAAK,SAAS,MAAM,EAAE;AAClC,WAAK,gBAAgB,MAAM,IAAI,KAAK;AAEpC,UAAI,CAAC,KAAK,MAAM,IAAI,GAAG,GAAG;AACxB,aAAK,MAAM,IAAI,KAAK,KAAmB;AACvC,eAAO;AAAA,MACT;AAEA,YAAM,WAAW,KAAK,MAAM,IAAI,GAAG;AACnC,aAAO,OAAO,UAAU,KAAK;AAC7B,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,MAAgB,IAAqB;AAC/C,aAAO,KAAK,UAAU,YAAY,IAAI,KAAK,KAAK,QAAQ,YAAY,EAAE;AAAA,IACxE;AAAA,IAEA,SAAS,MAAc,IAAoB;AACzC,aAAO,GAAG,IAAI,IAAI,EAAE;AAAA,IACtB;AAAA;AAAA,IAGA,EAAE,OAAO,QAAQ,IAA4C;AAC3D,iBAAW,CAAC,KAAK,IAAI,KAAK,KAAK,OAAO;AACpC,cAAM,CAAC,GAAG,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI;AAAA,MACpC;AAAA,IACF;AAAA,IAEA,gBAAgB,MAAgB,IAAY,WAA6B;AACvE,UAAI,CAAC,KAAK,YAAY,MAAM,EAAE;AAAG,cAAM,IAAI,MAAM,0BAA0B,IAAI,OAAO,EAAE,EAAE;AAE1F,UAAI,CAAC,KAAK,SAAS,IAAI,IAAI;AAAG,aAAK,SAAS,IAAI,MAAM,oBAAI,IAAI,CAAC;AAC/D,UAAI,CAAC,KAAK,OAAO,IAAI,EAAE;AAAG,aAAK,OAAO,IAAI,IAAI,oBAAI,IAAI,CAAC;AAEvD,UAAI,cAAc,OAAO;AACvB,aAAK,SAAS,IAAI,IAAI,GAAG,IAAI,EAAE;AAC/B,aAAK,OAAO,IAAI,EAAE,GAAG,IAAI,IAAI;AAAA,MAC/B,OAAO;AACL,aAAK,SAAS,IAAI,IAAI,GAAG,OAAO,EAAE;AAClC,aAAK,OAAO,IAAI,EAAE,GAAG,OAAO,IAAI;AAAA,MAClC;AAAA,IACF;AAAA;AAAA,IAGA,IAAW,OAAe;AACxB,aAAO,KAAK,MAAM;AAAA,IACpB;AAAA,IAEA,aAAa,MAA6B;AACxC,aAAQ,KAAK,SAAS,IAAI,IAAI,KAAK,oBAAI,IAAI;AAAA,IAC7C;AAAA,IAEA,WAAW,IAA2B;AACpC,aAAQ,KAAK,OAAO,IAAI,EAAE,KAAK,oBAAI,IAAI;AAAA,IACzC;AAAA,IAEA,SAAqC;AACnC,YAAM,SAAqC,CAAC;AAC5C,iBAAW,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM,QAAQ,GAAG;AAC/C,eAAO,GAAG,IAAI;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AAAA,IAEA,SAAS,OAAmC;AAC1C,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAChD,cAAM,CAAC,MAAM,EAAE,IAAI,IAAI,MAAM,GAAG;AAChC,aAAK,gBAAgB,MAAkB,IAAc,KAAK;AAC1D,aAAK,MAAM,IAAI,KAAK,KAAK;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;;;AC7IO,MAAM,cAAN,MAAuF;AAAA,IAK5F,YAAqB,OAAe;AAAf;AAJrB,oBAAS,oBAAI,IAAoB;AAK/B,WAAK,aAAa,WAAW,KAAK;AAAA,IACpC;AAAA,IANA;AAAA,IAQA,IAAI,KAAY,OAAsB;AACpC,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,cAAc,KAAK,UAAU,GAAG;AAC/F,WAAK,OAAO,IAAI,KAAK,KAAK;AAC1B,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,KAAiC;AACnC,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,EAAE;AACjE,aAAO,KAAK,OAAO,IAAI,GAAG;AAAA,IAC5B;AAAA,IAEA,IAAI,KAAqB;AACvB,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,EAAE;AACjE,aAAO,KAAK,OAAO,IAAI,GAAG;AAAA,IAC5B;AAAA,IAEA,OAAO,KAAqB;AAC1B,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,EAAE;AACjE,aAAO,KAAK,OAAO,OAAO,GAAG;AAAA,IAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,QAAQ,KAAiC;AACvC,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,EAAE;AACjE,UAAI,SAAS,KAAK,OAAO,IAAI,GAAG;AAChC,UAAI,WAAW,QAAW;AACxB,iBAAS,CAAC;AACV,aAAK,OAAO,IAAI,KAAK,MAAM;AAAA,MAC7B;AACA,aAAO;AAAA,IACT;AAAA,IAEA,MAAM,KAAY,OAAqC;AACrD,UAAI,CAAC,KAAK,YAAY,GAAG;AAAG,cAAM,IAAI,MAAM,gBAAgB,GAAG,EAAE;AAEjE,UAAI,CAAC,KAAK,OAAO,IAAI,GAAG,GAAG;AACzB,aAAK,OAAO,IAAI,KAAK,CAAC,CAAY;AAAA,MACpC;AAEA,YAAM,QAAQ,OAAO,OAAO,KAAK,OAAO,IAAI,GAAG,GAAU,KAAK;AAE9D,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,KAAsB;AAChC,aAAO,KAAK,WAAW,KAAK,GAAG;AAAA,IACjC;AAAA,IAEA,OAAgC;AAC9B,aAAO,KAAK,OAAO,KAAK;AAAA,IAC1B;AAAA,IAEA,CAAC,OAAO,QAAQ,IAAwC;AACtD,aAAO,KAAK,OAAO,QAAQ;AAAA,IAC7B;AAAA,IAEA,SAAkC;AAChC,YAAM,QAAiC,CAAC;AACxC,iBAAW,CAAC,KAAK,IAAI,KAAK,KAAK,QAAQ;AACrC,cAAM,GAAG,IAAI;AAAA,MACf;AACA,aAAO;AAAA,IACT;AAAA,IAEA,SAAS,OAAgC;AACvC,iBAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,KAAK,EAAE,KAAK,GAAG;AACtD,aAAK,IAAI,KAAc,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA;AAAA,IAGA,IAAW,OAAe;AACxB,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,EACF;;;AChFO,MAAM,QAAN,MAAY;AAAA,IAAZ;AACL,WAAS,UAAgD,oBAAI,IAAI;AACjE,WAAS,UAAoD,oBAAI,IAAI;AAAA;AAAA,IAE3D,QAAuC,MAA2C;AAC1F,YAAM,QAAQ,IAAI,YAA4B,IAAI;AAClD,UAAI,KAAK,QAAQ,IAAI,IAAI;AAAG,cAAM,IAAI,MAAM,0BAA0B,MAAM,KAAK,EAAE;AACnF,WAAK,QAAQ,IAAI,MAAM,OAAO,KAAK;AACnC,aAAO;AAAA,IACT;AAAA,IAEU,QACR,MACA,MACA,IAC6C;AAC7C,UAAI,KAAK,WAAW;AAAG,cAAM,IAAI,MAAM,uBAAuB;AAC9D,YAAM,QAAQ,IAAI,UAAsC,MAAM,MAAM,EAAE;AACtE,UAAI,KAAK,QAAQ,IAAI,MAAM,QAAQ;AAAG,cAAM,IAAI,MAAM,0BAA0B,MAAM,QAAQ,EAAE;AAChG,WAAK,QAAQ,IAAI,MAAM,UAAU,KAAK;AACtC,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,WAAmB;AACrB,UAAI,QAAQ;AACZ,iBAAW,MAAM,KAAK,QAAQ,OAAO,GAAG;AACtC,iBAAS,GAAG;AAAA,MACd;AACA,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,cAAsB;AACxB,UAAI,QAAQ;AACZ,iBAAW,MAAM,KAAK,QAAQ,OAAO,GAAG;AACtC,iBAAS,GAAG;AAAA,MACd;AACA,aAAO;AAAA,IACT;AAAA,IAEA,CAAC,cAAgD;AAC/C,iBAAW,MAAM,KAAK,QAAQ,OAAO,GAAG;AACtC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IAEA,CAAC,WAA6C;AAC5C,iBAAW,MAAM,KAAK,QAAQ,OAAO,GAAG;AACtC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IAEA,SAA0B;AACxB,YAAM,QAAQ,EAAE,SAAS,CAAC,GAAG,SAAS,CAAC,EAAE;AAEzC,iBAAW,CAAC,KAAK,GAAG,KAAK,KAAK,SAAS;AACrC,gBAAQ,IAAI,6BAA6B,GAAG;AAC5C,cAAM,QAAQ,GAAG,IAAI,IAAI,OAAO;AAAA,MAClC;AAEA,iBAAW,CAAC,KAAK,GAAG,KAAK,KAAK,SAAS;AACrC,gBAAQ,IAAI,2BAA2B,GAAG;AAC1C,cAAM,QAAQ,GAAG,IAAI,IAAI,OAAO;AAAA,MAClC;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,SAAS,MAAuB;AAC9B,iBAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,KAAK,OAAO,GAAG;AACzD,cAAM,KAAK,KAAK,QAAQ,IAAI,KAAK;AACjC,YAAI,CAAC;AAAI,gBAAM,IAAI,MAAM,2BAA2B,KAAK,EAAE;AAC3D,WAAG,SAAS,KAAK;AAAA,MACnB;AAEA,iBAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,KAAK,OAAO,GAAG;AACzD,cAAM,KAAK,KAAK,QAAQ,IAAI,KAAK;AACjC,YAAI,CAAC;AAAI,gBAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AACzD,WAAG,SAAS,KAAK;AAAA,MACnB;AAAA,IACF;AAAA,EACF;;;AC5CO,WAAS,OAAO,OAAe,YAAY,IAAY;AAE5D,aAAS,iBAAiB;AACxB,UAAI;AACF,cAAM,MAAM,EAAE;AAAA,MAChB,SAASC,MAAK;AACZ,eAAOA;AAAA,MACT;AAAA,IACF;AACA,UAAM,MAAM,eAAe;AAE3B,UAAM,cAAc,IAAI,MACrB,MAAM,IAAI,EACV,KAAK,CAAC,SAAiB,KAAK,SAAS,KAAK,MAAM,CAAC,aAAa,CAAC,KAAK,SAAS,SAAS,EAAE;AAE3F,QAAI,CAAC;AAAa,aAAO;AACzB,UAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,UAAM,QAAQ,YAAY,MAAM,QAAQ,GAAG,YAAY,MAAM;AAC7D,WAAO,MAAM,KAAK;AAAA,EACpB;AAsCO,WAAS,WACd,QACA,SACA,SACA,aACA;AACA,eAAW,WAAW,SAAS;AAC7B,YAAM,WAAW,OAAO,KAAK,CAAC,SAAY,QAAQ,MAAM,OAAO,CAAC;AAChE,UAAI,UAAU;AACZ,oBAAY,UAAU,OAAO;AAAA,MAC/B,OAAO;AACL,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA,IACF;AAAA,EACF;;;AC3FO,MAAM,eAAN,MAAmB;AAAA,IACxB,YACWC,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,QAAQ,QAAQ,GAAG;AAAA,IACvB;AAAA,IAEA,MAAM,MAA8B;AAClC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,QAAQ,IAAI,KAAK,GAAG,EAAE;AAC/C,YAAM,MAAM,KAAK,EAAE,QAAQ,MAAM,KAAK,KAAK,IAAI;AAE/C,sBAAgB,KAAK,IAAI;AACzB,kBAAY,KAAK,IAAI;AACrB,oBAAc,KAAK,IAAI;AACvB,mBAAa,KAAK,IAAI;AACtB,oBAAc,KAAK,IAAI;AAEvB,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,OAAkB,MAAkC;AAC7D,WAAK,EAAE,aAAa,MAAM,OAAO,KAAK,KAAK,IAAI;AAC/C,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,QAA2B;AACrC,iBAAW,SAAS;AAAQ,aAAK,EAAE,aAAa,QAAQ,OAAO,KAAK,GAAG;AACvE,aAAO;AAAA,IACT;AAAA,IAEA,kBAAkB,OAAkB,MAAmC;AACrE,WAAK,EAAE,aAAa,MAAM,OAAO,KAAK,KAAK,IAAI;AAC/C,aAAO;AAAA,IACT;AAAA,IAEA,mBAAmB,QAA2B;AAC5C,iBAAW,SAAS;AAAQ,aAAK,EAAE,aAAa,QAAQ,OAAO,KAAK,GAAG;AACvE,aAAO;AAAA,IACT;AAAA,IAEA,aAAa,OAAkB,MAAqC;AAClE,WAAK,EAAE,iBAAiB,MAAM,OAAO,KAAK,KAAK,IAAI;AACnD,aAAO;AAAA,IACT;AAAA,IAEA,cAAc,QAA2B;AACvC,iBAAW,SAAS;AAAQ,aAAK,EAAE,iBAAiB,QAAQ,OAAO,KAAK,GAAG;AAC3E,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,OAAoB,MAAmC;AAChE,WAAK,EAAE,cAAc,MAAM,KAAK,KAAK,OAAO,IAAI;AAChD,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,QAA6B;AACvC,iBAAW,SAAS,UAAU,CAAC;AAAG,aAAK,EAAE,cAAc,QAAQ,KAAK,KAAK,KAAK;AAC9E,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,OAAqB,MAAkC;AACjE,WAAK,EAAE,aAAa,MAAM,KAAK,KAAK,OAAO,IAAI;AAC/C,aAAO;AAAA,IACT;AAAA,IAEA,aAAa,QAA8B;AACzC,iBAAW,YAAY,UAAU,CAAC;AAAG,aAAK,EAAE,aAAa,QAAQ,KAAK,KAAK,QAAQ;AACnF,aAAO;AAAA,IACT;AAAA,IAEA,UAAU,OAAmB,MAAoC;AAC/D,WAAK,EAAE,eAAe,MAAM,OAAO,KAAK,KAAK,IAAI;AACjD,aAAO;AAAA,IACT;AAAA,IAEA,UAAU,QAA4B;AACpC,iBAAW,SAAS,UAAU,CAAC;AAAG,aAAK,EAAE,eAAe,QAAQ,OAAO,KAAK,GAAG;AAC/E,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,OAAqB,MAAsC;AACrE,WAAK,EAAE,iBAAiB,MAAM,KAAK,KAAK,OAAO,IAAI;AACnD,aAAO;AAAA,IACT;AAAA,IAEA,aAAa,QAA8B;AACzC,iBAAW,SAAS;AAAQ,aAAK,EAAE,iBAAiB,QAAQ,KAAK,KAAK,KAAK;AAC3E,aAAO;AAAA,IACT;AAAA,IAEA,cAAc,OAAuB,MAAkC;AACrE,WAAK,EAAE,aAAa,MAAM,KAAK,KAAK,OAAO,IAAI;AAC/C,aAAO;AAAA,IACT;AAAA,IAEA,eAAe,QAAgC;AAC7C,iBAAW,SAAS,UAAU,CAAC;AAAG,aAAK,EAAE,aAAa,QAAQ,KAAK,KAAK,KAAK;AAC7E,aAAO;AAAA,IACT;AAAA,EACF;AAEO,MAAM,iBAAN,MAAqB;AAAA,IAC1B,YACWA,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,UAAU,QAAQ,KAAK,GAAG;AAAA,IAC9B;AAAA,IAEA,MAAM,MAAgC;AACpC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,UAAU,IAAI,KAAK,GAAG,EAAE;AACjD,YAAM,MAAM,KAAK,EAAE,UAAU,MAAM,KAAK,KAAK,IAAI;AACjD,oBAAc,KAAK,IAAI;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAEO,MAAM,kBAAN,MAAsB;AAAA,IAC3B,YACWA,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,WAAW,QAAQ,KAAK,GAAG;AAAA,IAC/B;AAAA,IAEA,MAAM,MAAiC;AACrC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,WAAW,IAAI,KAAK,GAAG,EAAE;AAClD,YAAM,MAAM,KAAK,EAAE,WAAW,MAAM,KAAK,KAAK,IAAI;AAClD,oBAAc,KAAK,IAAI;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAEO,MAAM,gBAAN,MAAoB;AAAA,IACzB,YACWA,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,SAAS,QAAQ,KAAK,GAAG;AAAA,IAC7B;AAAA,IAEA,MAAM,MAA+B;AACnC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,SAAS,IAAI,KAAK,GAAG,EAAE;AAChD,YAAM,MAAM,KAAK,EAAE,SAAS,MAAM,KAAK,KAAK,IAAI;AAChD,oBAAc,KAAK,IAAI;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAEO,MAAM,kBAAN,MAAsB;AAAA,IAC3B,YACWA,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,WAAW,QAAQ,KAAK,GAAG;AAAA,IAC/B;AAAA,IAEA,MAAM,MAAiC;AACrC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,WAAW,IAAI,KAAK,GAAG,EAAE;AAClD,YAAM,MAAM,KAAK,EAAE,WAAW,MAAM,KAAK,KAAK,IAAI;AAClD,oBAAc,KAAK,IAAI;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAEO,MAAM,iBAAN,MAAqB;AAAA,IAC1B,YACWA,IACA,KACT;AAFS,eAAAA;AACA;AAET,MAAAA,GAAE,UAAU,QAAQ,KAAK,GAAG;AAAA,IAC9B;AAAA,IAEA,MAAM,MAAmC;AACvC,YAAM,OAAO,EAAE,GAAG,KAAK,EAAE,UAAU,IAAI,KAAK,GAAG,EAAE;AACjD,YAAM,MAAM,KAAK,EAAE,UAAU,MAAM,KAAK,KAAK,IAAI;AACjD,oBAAc,KAAK,IAAI;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAIA,MAAM,kBAAkB;AAIxB,WAAS,cAAc,QAAkC,SAAmC;AAC1F,QAAI,QAAQ,aAAa;AAAW;AACpC;AAAA,MACG,OAAO,aAAa,CAAC;AAAA,MACtB,QAAQ;AAAA,MACR,CAAC,IAAUC,QAAa,GAAG,SAASA,IAAG;AAAA,MACvC,CAAC,UAAgB,YAAkB;AACjC,gBAAQ,KAAK,GAAG,OAAO,eAAe,CAAC,qBAAqB,KAAK,UAAU,EAAE,UAAU,QAAQ,CAAC,CAAC,EAAE;AAAA,MACrG;AAAA,IACF;AAAA,EACF;AAEA,WAAS,YAAY,QAAiC,SAAkC;AACtF,QAAI,QAAQ,WAAW;AAAW;AAClC;AAAA,MACG,OAAO,WAAW,CAAC;AAAA,MACpB,QAAQ;AAAA,MACR,CAAC,MAAa,SAAgB,KAAK,QAAQ,KAAK;AAAA,MAChD,CAAC,WAAkB,aAAoB;AACrC,gBAAQ,KAAK,GAAG,OAAO,eAAe,CAAC,sBAAsB,KAAK,UAAU,EAAE,WAAW,SAAS,CAAC,CAAC,EAAE;AACtG,kBAAU,UAAU,SAAS;AAC7B,kBAAU,WAAW,SAAS;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAEA,WAAS,cAAc,QAAmC,SAAoC;AAC5F,QAAI,CAAC,QAAQ;AAAU;AACvB;AAAA,MACG,OAAO,aAAa,CAAC;AAAA,MACtB,QAAQ;AAAA,MACR,CAAC,MAAe,SAAkB,KAAK,YAAY,KAAK,WAAW,KAAK,SAAS,KAAK;AAAA,MACtF,CAAC,SAAkB,WAAoB;AACrC,gBAAQ,KAAK,GAAG,OAAO,eAAe,CAAC,wBAAwB,KAAK,UAAU,EAAE,SAAS,OAAO,CAAC,CAAC,EAAE;AAAA,MACtG;AAAA,IACF;AAAA,EACF;AAEA,WAAS,aAAa,QAAkC,SAAmC;AACzF,QAAI,CAAC,QAAQ;AAAS;AACtB;AAAA,MACG,OAAO,YAAY,CAAC;AAAA,MACrB,QAAQ;AAAA,MACR,CAAC,QAAiB,WAAoB,WAAW;AAAA,MACjD,CAAC,WAAW,aAAa;AACvB,gBAAQ,KAAK,GAAG,OAAO,eAAe,CAAC,sBAAsB,QAAQ,EAAE;AAAA,MACzE;AAAA,IACF;AAAA,EACF;AAEA,WAAS,gBAAgB,QAAqC,SAAsC;AAClG,QAAI,QAAQ,eAAe;AAAW;AACtC;AAAA,MACG,OAAO,eAAe,CAAC;AAAA,MACxB,QAAQ;AAAA,MACR,CAAC,MAAM,SAAS,SAAS;AAAA,MACzB,CAAC,SAAS,WAAW;AACnB,gBAAQ,KAAK,GAAG,OAAO,eAAe,CAAC,0BAA0B,MAAM,EAAE;AAAA,MAC3E;AAAA,IACF;AAAA,EACF;;;AC9OO,MAAM,cAAN,cAA0B,MAAM;AAAA,IAAhC;AAAA;AAEL;AAAA,WAAS,YAAY,KAAK,QAAyC,KAAM;AACzE,WAAS,aAAa,KAAK,QAA2C,MAAO;AAC7E,WAAS,WAAW,KAAK,QAAuC,QAAQ;AACxE,WAAS,UAAU,KAAK,QAAqC,IAAI;AACjE,WAAS,aAAa,KAAK,QAA2C,OAAO;AAC7E,WAAS,YAAY,KAAK,QAA+C,MAAM;AAG/E;AAAA,WAAS,eAAe,KAAK,QAA2C,cAAc,KAAK,SAAS,KAAK,OAAQ;AACjH,WAAS,gBAAgB,KAAK,QAA8C,eAAe,KAAK,SAAS,KAAK,SAAU;AACxH,WAAS,eAAe,KAAK,QAA4C,cAAc,KAAK,SAAS,KAAK,OAAQ;AAClH,WAAS,mBAAmB,KAAK,QAA8C,cAAc,KAAK,SAAS,KAAK,OAAQ;AACxH,WAAS,iBAAiB,KAAK,QAA8C,YAAY,KAAK,UAAU,KAAK,OAAO;AACpH,WAAS,eAAe,KAAK,QAA8C,YAAY,KAAK,SAAS,KAAK,UAAW;AACrH,WAAS,eAAe,KAAK,QAAgD,eAAe,KAAK,SAAS,KAAK,SAAS;AACxH,WAAS,mBAAmB,KAAK,QAAkD,kBAAkB,KAAK,SAAS,KAAK,UAAU;AAAA;AAAA;AAAA,IAIlI,aAAa,KAAkB;AAAE,aAAO,IAAI,eAAe,MAAM,GAAG;AAAA,IAAG;AAAA,IACvE,cAAc,KAAmB;AAAE,aAAO,IAAI,gBAAgB,MAAM,GAAG;AAAA,IAAG;AAAA,IAC1E,YAAY,KAAiB;AAAE,aAAO,IAAI,cAAc,MAAM,GAAG;AAAA,IAAG;AAAA,IACpE,WAAW,KAAgB;AAAE,aAAO,IAAI,aAAa,MAAM,GAAG;AAAA,IAAG;AAAA,IACjE,cAAc,KAAmB;AAAE,aAAO,IAAI,gBAAgB,MAAM,GAAG;AAAA,IAAG;AAAA,IAC1E,gBAAgB,KAAqB;AAAE,aAAO,IAAI,eAAe,MAAM,GAAG;AAAA,IAAG;AAAA,EAC/E;;;AC3DO,MAAM,SAAS,EAA6B,MAAS;AAE5D,iBAAsB,aAAqC;AACzD,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,cAAc;AACtC,YAAM,YAAY,MAAM,IAAI,KAAK;AAEjC,YAAM,KAAK,IAAI,YAAY;AAE3B,SAAG,SAAS,SAAS;AACrB,cAAQ,IAAI,uBAAuB,GAAG,aAAa,YAAY,GAAG,UAAU,OAAO;AAEnF,aAAO;AAAA,IACT,SAASC,IAAG;AACV,cAAQ,MAAM,0BAA0BA,EAAC;AACzC,aAAO;AAAA,IACT;AAAA,EACF;;;ACpBA,WAAS,eAAe,EAAE,SAAS,GAAG;AACpC,UAAM,CAAC,IAAI,KAAK,IAAIC,GAAwB;AAC5C,IAAAC,GAAU,MAAM;AACd,UAAI;AAAI;AACR,iBAAW,EAAE,KAAK,CAACC,QAAO,MAAMA,GAAE,CAAC;AAAA,IACrC,CAAC;AACD,WAAO,kBAAC,OAAO,UAAP,EAAgB,OAAO,MAAK,QAAS;AAAA,EAC/C;AAEO,WAAS,MAAM,OAAe,KAAoB;AACvD,UAAM,OAAO,SAAS,eAAe,KAAK;AAC1C,QAAI,CAAC;AAAM,YAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;AACxD,MAAO,kBAAC,sBAAgB,GAAI,GAAmB,IAAI;AAAA,EACrD;;;ACVA,WAAS,SAAS;AAChB,WACE,2BACE,kBAAC,WAAM,OAAM,kBAAe,WAE1B,kBAAC,WAAM,MAAK,SAAQ,IAAG,gBAAe,aAAY,aAAY,CAChE,GACA,kBAAC,SAAI,IAAG,oBAAiB,mBAAiB,CAC5C;AAAA,EAEJ;AAEA,QAAM,UAAU,kBAAC,YAAO,CAAE;",
  "names": ["MODE_HYDRATE", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__d", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "prevDebounce", "options", "debounceRendering", "defer", "renderQueueLength", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "sort", "depthSort", "shift", "assign", "__v", "diff", "__P", "namespaceURI", "__u", "__i", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "isConnected", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "constructor", "String", "createVNode", "isArray", "key", "findMatchingIndex", "unmount", "parentVNode", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "key", "type", "x", "y", "oldVNode", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "o", "cssText", "replace", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "__e", "__b", "outer", "props", "contextType", "__c", "__", "__E", "prototype", "render", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__d", "__k", "forEach", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "diffChildren", "isArray", "Fragment", "children", "base", "MODE_HYDRATE", "indexOf", "diffElementNodes", "diffed", "commitRoot", "root", "applyRef", "some", "cb", "call", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "nodeType", "localName", "document", "createTextNode", "createElementNS", "is", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "getDomSibling", "removeNode", "ref", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "createElement", "namespaceURI", "firstChild", "createContext", "defaultValue", "contextId", "context", "__c", "i", "__", "Consumer", "props", "contextValue", "children", "Provider", "subs", "ctx", "this", "getChildContext", "shouldComponentUpdate", "_props", "value", "some", "c", "__e", "enqueueRender", "sub", "push", "old", "componentWillUnmount", "splice", "indexOf", "call", "contextType", "slice", "EMPTY_ARR", "options", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "__s", "state", "assign", "__v", "_sb", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "window", "__PREACT_DEVTOOLS__", "attachPreact", "options", "Fragment", "Component", "loggedTypeFailures", "getDisplayName", "vnode", "type", "Fragment", "displayName", "name", "renderStack", "ownerStack", "getCurrentVNode", "length", "showJsxSourcePluginWarning", "isPossibleOwner", "getOwnerStack", "stack", "next", "__o", "push", "reduce", "acc", "owner", "source", "__source", "fileName", "lineNumber", "console", "warn", "isWeakMapSupported", "WeakMap", "getDomChildren", "domChildren", "__k", "forEach", "child", "apply", "getClosestDomNodeParentName", "parent", "__", "__e", "parentNode", "localName", "setState", "Component", "prototype", "isTableElement", "update", "callback", "this", "state", "call", "ILLEGAL_PARAGRAPH_CHILD_ELEMENTS", "forceUpdate", "serializeVNode", "props", "attrs", "prop", "hasOwnProperty", "value", "Object", "toString", "JSON", "stringify", "children", "__v", "setupComponentStack", "oldDiff", "options", "__b", "oldDiffed", "diffed", "oldRoot", "oldVNode", "oldRender", "__r", "pop", "hooksAllowed", "oldBeforeDiff", "oldVnode", "oldCatchError", "oldHook", "__h", "warnedComponents", "useEffect", "useLayoutEffect", "lazyPropTypes", "deprecations", "error", "errorInfo", "__c", "then", "promise", "Error", "componentStack", "setTimeout", "e", "isValid", "nodeType", "componentName", "Array", "isArray", "ref", "key", "propTypes", "has", "m", "lazyVNode", "set", "values", "__f", "obj", "i", "checkPropTypes", "typeSpecs", "location", "getStack", "keys", "typeSpecName", "message", "loggedTypeFailures", "currentComponent", "renderCount", "nextComponent", "comp", "index", "property", "get", "indexOf", "deprecatedAttributes", "nodeName", "attributes", "deprecatedProto", "create", "newProps", "v", "__self", "__proto__", "join", "domParentName", "log", "illegalDomChildrenTypes", "filter", "childType", "test", "__H", "hooks", "hook", "j", "initDebug", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "EMPTY", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "__V", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "_hasScuFromHooks", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "forEach", "hookItem", "props", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "argsChanged", "_pendingArgs", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "__", "hookItem", "__N", "__V", "EMPTY", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "s", "t", "err", "g", "l2", "e", "p", "_", "pg"]
}
