/**  Do not modify manually! Generated by graphgen on 2024-11-26T13:25:13.494Z. */

import { Edges, Vertices, RelFrom, RelTo } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  readonly app = new Vertices<VApp>(key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>(key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>(key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>(key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>(key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>(key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>(key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>(key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>(key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>(key => new VPost(this, key));
  readonly tag = new Vertices<VTag>(key => new VTag(this, key));
  readonly tool = new Vertices<VTool>(key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>(key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly nodes = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    appPlang: new Edges<`app+${string}`, `pl+${string}`>(),
    appPlatform: new Edges<`app+${string}`, `plat+${string}`>(),
    appTag: new Edges<`app+${string}`, `tag+${string}`>(),
    bundleTool: new Edges<`bun+${string}`, `tool+${string}`>(),
    communityPlang: new Edges<`comm+${string}`, `pl+${string}`>(),
    communityTag: new Edges<`comm+${string}`, `tag+${string}`>(),
    learningCommunity: new Edges<`learn+${string}`, `comm+${string}`>(),
    learningPlang: new Edges<`learn+${string}`, `pl+${string}`>(),
    learningTag: new Edges<`learn+${string}`, `tag+${string}`>(),
    libraryUsedOnPlang: new Edges<`lib+${string}`, `pl+${string}`>(),
    libraryLibWrittenInPlang: new Edges<`lib+${string}`, `pl+${string}`>(),
    libraryPlatform: new Edges<`lib+${string}`, `plat+${string}`>(),
    libraryTag: new Edges<`lib+${string}`, `tag+${string}`>(),
    licenseApp: new Edges<`lic+${string}`, `app+${string}`>(),
    licenseLibrary: new Edges<`lic+${string}`, `lib+${string}`>(),
    licensePlang: new Edges<`lic+${string}`, `pl+${string}`>(),
    licenseTool: new Edges<`lic+${string}`, `tool+${string}`>(),
    plangParadigm: new Edges<`pl+${string}`, `para+${string}`>(),
    plangCompilesToPlang: new Edges<`pl+${string}`, `pl+${string}`>(),
    plangDialectPlang: new Edges<`pl+${string}`, `pl+${string}`>(),
    plangImplementPlang: new Edges<`pl+${string}`, `pl+${string}`>(),
    plangInfluencePlang: new Edges<`pl+${string}`, `pl+${string}`>(),
    plangWrittenInPlangPlang: new Edges<`pl+${string}`, `pl+${string}`>(),
    plangPlatform: new Edges<`pl+${string}`, `plat+${string}`>(),
    plangTag: new Edges<`pl+${string}`, `tag+${string}`>(),
    plangTool: new Edges<`pl+${string}`, `tool+${string}`>(),
    plangTypeSystem: new Edges<`pl+${string}`, `tsys+${string}`>(),
    postPlang: new Edges<`post+${string}`, `pl+${string}`>(),
    toolToolWrittenInPlang: new Edges<`tool+${string}`, `pl+${string}`>(),
    toolPlatform: new Edges<`tool+${string}`, `plat+${string}`>(),
    toolTag: new Edges<`tool+${string}`, `tag+${string}`>(),
  } as const;
}

/** Software application. */
export class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly kind = "app" as const;
  static readonly desc = "Software application.";
  override kind = VAppBase.kind;

  /** **this -> plang**: Plangs used to write the App. */
  get relPlang() {
    return new RelFrom(this, this.graph.edges.appPlang, this.graph.plang);
  }

  /** **this -> platform**: Platforms supported by the App. */
  get relPlatform() {
    return new RelFrom(this, this.graph.edges.appPlatform, this.graph.platform);
  }

  /** **this -> tag**: Tags for this App. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.appTag, this.graph.tag);
  }

  /** **license -> this**: Licenses for an App. */
  get relLicense() {
    return new RelTo(this, this.graph.edges.licenseApp, this.graph.license);
  }
}

/** Bundle of Tools. */
export class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly kind = "bun" as const;
  static readonly desc = "Bundle of Tools.";
  override kind = VBundleBase.kind;

  /** **this -> tool**: Tools in a Bundle. */
  get relTool() {
    return new RelFrom(this, this.graph.edges.bundleTool, this.graph.tool);
  }
}

/** Community. */
export class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly kind = "comm" as const;
  static readonly desc = "Community.";
  override kind = VCommunityBase.kind;

  /** **this -> plang**: Plangs the Community is interested in. */
  get relPlang() {
    return new RelFrom(this, this.graph.edges.communityPlang, this.graph.plang);
  }

  /** **this -> tag**: Tags for this Community. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.communityTag, this.graph.tag);
  }

  /** **learning -> this**: Communities helpful when using the Learning resource. */
  get relLearning() {
    return new RelTo(this, this.graph.edges.learningCommunity, this.graph.learning);
  }
}

/** Learning resources. */
export class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly kind = "learn" as const;
  static readonly desc = "Learning resources.";
  override kind = VLearningBase.kind;

  /** **this -> community**: Communities helpful when using the Learning resource. */
  get relCommunity() {
    return new RelFrom(this, this.graph.edges.learningCommunity, this.graph.community);
  }

  /** **this -> plang**: Plangs covered by the Learning resource. */
  get relPlang() {
    return new RelFrom(this, this.graph.edges.learningPlang, this.graph.plang);
  }

  /** **this -> tag**: Tags for this Learning resource. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.learningTag, this.graph.tag);
  }
}

/** Software Libraries. */
export class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly kind = "lib" as const;
  static readonly desc = "Software Libraries.";
  override kind = VLibraryBase.kind;

  /** **this -> plang**: Plangs that can use this Library. */
  get relUsedOn() {
    return new RelFrom(this, this.graph.edges.libraryUsedOnPlang, this.graph.plang);
  }

  /** **this -> plang**: Plangs used in the Library implementation. */
  get relLibWrittenIn() {
    return new RelFrom(this, this.graph.edges.libraryLibWrittenInPlang, this.graph.plang);
  }

  /** **this -> platform**: Platforms supported by this Library. */
  get relPlatform() {
    return new RelFrom(this, this.graph.edges.libraryPlatform, this.graph.platform);
  }

  /** **this -> tag**: Tags for this Library. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.libraryTag, this.graph.tag);
  }

  /** **license -> this**: Licenses for a Library. */
  get relLicense() {
    return new RelTo(this, this.graph.edges.licenseLibrary, this.graph.license);
  }
}

/** Software Licenses. */
export class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly kind = "lic" as const;
  static readonly desc = "Software Licenses.";
  override kind = VLicenseBase.kind;

  /** **this -> app**: Licenses for an App. */
  get relApp() {
    return new RelFrom(this, this.graph.edges.licenseApp, this.graph.app);
  }

  /** **this -> library**: Licenses for a Library. */
  get relLibrary() {
    return new RelFrom(this, this.graph.edges.licenseLibrary, this.graph.library);
  }

  /** **this -> plang**: Licenses for a Plang. */
  get relPlang() {
    return new RelFrom(this, this.graph.edges.licensePlang, this.graph.plang);
  }

  /** **this -> tool**: Licenses for a Tool. */
  get relTool() {
    return new RelFrom(this, this.graph.edges.licenseTool, this.graph.tool);
  }
}

/** Programming Language Paradigms. */
export class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly kind = "para" as const;
  static readonly desc = "Programming Language Paradigms.";
  override kind = VParadigmBase.kind;

  /** **plang -> this**: Paradigms implemented by the Plang. */
  get relPlang() {
    return new RelTo(this, this.graph.edges.plangParadigm, this.graph.plang);
  }
}

/** Programming languages. */
export class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly kind = "pl" as const;
  static readonly desc = "Programming languages.";
  override kind = VPlangBase.kind;

  /** **app -> this**: Plangs used to write the App. */
  get relApp() {
    return new RelTo(this, this.graph.edges.appPlang, this.graph.app);
  }

  /** **community -> this**: Plangs the Community is interested in. */
  get relCommunity() {
    return new RelTo(this, this.graph.edges.communityPlang, this.graph.community);
  }

  /** **learning -> this**: Plangs covered by the Learning resource. */
  get relLearning() {
    return new RelTo(this, this.graph.edges.learningPlang, this.graph.learning);
  }

  /** **library -> this**: Plangs that can use this Library. */
  get relUsedOn() {
    return new RelTo(this, this.graph.edges.libraryUsedOnPlang, this.graph.library);
  }

  /** **library -> this**: Plangs used in the Library implementation. */
  get relLibWrittenIn() {
    return new RelTo(this, this.graph.edges.libraryLibWrittenInPlang, this.graph.library);
  }

  /** **license -> this**: Licenses for a Plang. */
  get relLicense() {
    return new RelTo(this, this.graph.edges.licensePlang, this.graph.license);
  }

  /** **this -> paradigm**: Paradigms implemented by the Plang. */
  get relParadigm() {
    return new RelFrom(this, this.graph.edges.plangParadigm, this.graph.paradigm);
  }

  /** **this -> plang**: Plangs target when transpiling. */
  get relCompilesTo() {
    return new RelFrom(this, this.graph.edges.plangCompilesToPlang, this.graph.plang);
  }

  /** **plang -> this**: Plangs target when transpiling. */
  get relCompilesToRev() {
    return new RelTo(this, this.graph.edges.plangCompilesToPlang, this.graph.plang);
  }

  /** **this -> plang**: Plangs is a Dialect of another. */
  get relDialect() {
    return new RelFrom(this, this.graph.edges.plangDialectPlang, this.graph.plang);
  }

  /** **plang -> this**: Plangs is a Dialect of another. */
  get relDialectRev() {
    return new RelTo(this, this.graph.edges.plangDialectPlang, this.graph.plang);
  }

  /** **this -> plang**: Plangs is an implementation of another. */
  get relImplement() {
    return new RelFrom(this, this.graph.edges.plangImplementPlang, this.graph.plang);
  }

  /** **plang -> this**: Plangs is an implementation of another. */
  get relImplementRev() {
    return new RelTo(this, this.graph.edges.plangImplementPlang, this.graph.plang);
  }

  /** **this -> plang**: Plangs that influenced this Plang. */
  get relInfluence() {
    return new RelFrom(this, this.graph.edges.plangInfluencePlang, this.graph.plang);
  }

  /** **plang -> this**: Plangs that influenced this Plang. */
  get relInfluenceRev() {
    return new RelTo(this, this.graph.edges.plangInfluencePlang, this.graph.plang);
  }

  /** **this -> plang**: Plangs used to create this Plang. */
  get relWrittenInPlang() {
    return new RelFrom(this, this.graph.edges.plangWrittenInPlangPlang, this.graph.plang);
  }

  /** **plang -> this**: Plangs used to create this Plang. */
  get relWrittenInPlangRev() {
    return new RelTo(this, this.graph.edges.plangWrittenInPlangPlang, this.graph.plang);
  }

  /** **this -> platform**: Platforms supported by the Plang. */
  get relPlatform() {
    return new RelFrom(this, this.graph.edges.plangPlatform, this.graph.platform);
  }

  /** **this -> tag**: Tags associated with the Plang. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.plangTag, this.graph.tag);
  }

  /** **this -> tool**: Plangs that benefits from this tool. */
  get relTool() {
    return new RelFrom(this, this.graph.edges.plangTool, this.graph.tool);
  }

  /** **this -> typeSystem**: Type systems used by the Plang. */
  get relTypeSystem() {
    return new RelFrom(this, this.graph.edges.plangTypeSystem, this.graph.typeSystem);
  }

  /** **post -> this**: Plangs covered by the Post. */
  get relPost() {
    return new RelTo(this, this.graph.edges.postPlang, this.graph.post);
  }

  /** **tool -> this**: Plangs used to write the tool. */
  get relToolWrittenIn() {
    return new RelTo(this, this.graph.edges.toolToolWrittenInPlang, this.graph.tool);
  }
}

/** Platforms where software runs. */
export class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly kind = "plat" as const;
  static readonly desc = "Platforms where software runs.";
  override kind = VPlatformBase.kind;

  /** **app -> this**: Platforms supported by the App. */
  get relApp() {
    return new RelTo(this, this.graph.edges.appPlatform, this.graph.app);
  }

  /** **library -> this**: Platforms supported by this Library. */
  get relLibrary() {
    return new RelTo(this, this.graph.edges.libraryPlatform, this.graph.library);
  }

  /** **plang -> this**: Platforms supported by the Plang. */
  get relPlang() {
    return new RelTo(this, this.graph.edges.plangPlatform, this.graph.plang);
  }

  /** **tool -> this**: Platforms supported by the tool. */
  get relTool() {
    return new RelTo(this, this.graph.edges.toolPlatform, this.graph.tool);
  }
}

/** Blog Posts. */
export class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly kind = "post" as const;
  static readonly desc = "Blog Posts.";
  override kind = VPostBase.kind;

  /** **this -> plang**: Plangs covered by the Post. */
  get relPlang() {
    return new RelFrom(this, this.graph.edges.postPlang, this.graph.plang);
  }
}

/** Tags. */
export class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly kind = "tag" as const;
  static readonly desc = "Tags.";
  override kind = VTagBase.kind;

  /** **app -> this**: Tags for this App. */
  get relApp() {
    return new RelTo(this, this.graph.edges.appTag, this.graph.app);
  }

  /** **community -> this**: Tags for this Community. */
  get relCommunity() {
    return new RelTo(this, this.graph.edges.communityTag, this.graph.community);
  }

  /** **learning -> this**: Tags for this Learning resource. */
  get relLearning() {
    return new RelTo(this, this.graph.edges.learningTag, this.graph.learning);
  }

  /** **library -> this**: Tags for this Library. */
  get relLibrary() {
    return new RelTo(this, this.graph.edges.libraryTag, this.graph.library);
  }

  /** **plang -> this**: Tags associated with the Plang. */
  get relPlang() {
    return new RelTo(this, this.graph.edges.plangTag, this.graph.plang);
  }

  /** **tool -> this**: Tags associated with the tool. */
  get relTool() {
    return new RelTo(this, this.graph.edges.toolTag, this.graph.tool);
  }
}

/** Programmer's Tools. */
export class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly kind = "tool" as const;
  static readonly desc = "Programmer's Tools.";
  override kind = VToolBase.kind;

  /** **bundle -> this**: Tools in a Bundle. */
  get relBundle() {
    return new RelTo(this, this.graph.edges.bundleTool, this.graph.bundle);
  }

  /** **license -> this**: Licenses for a Tool. */
  get relLicense() {
    return new RelTo(this, this.graph.edges.licenseTool, this.graph.license);
  }

  /** **plang -> this**: Plangs that benefits from this tool. */
  get relPlang() {
    return new RelTo(this, this.graph.edges.plangTool, this.graph.plang);
  }

  /** **this -> plang**: Plangs used to write the tool. */
  get relToolWrittenIn() {
    return new RelFrom(this, this.graph.edges.toolToolWrittenInPlang, this.graph.plang);
  }

  /** **this -> platform**: Platforms supported by the tool. */
  get relPlatform() {
    return new RelFrom(this, this.graph.edges.toolPlatform, this.graph.platform);
  }

  /** **this -> tag**: Tags associated with the tool. */
  get relTag() {
    return new RelFrom(this, this.graph.edges.toolTag, this.graph.tag);
  }
}

/** Type systems. */
export class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly kind = "tsys" as const;
  static readonly desc = "Type systems.";
  override kind = VTypeSystemBase.kind;

  /** **plang -> this**: Type systems used by the Plang. */
  get relPlang() {
    return new RelTo(this, this.graph.edges.plangTypeSystem, this.graph.plang);
  }
}
