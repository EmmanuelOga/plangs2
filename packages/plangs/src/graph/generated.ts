/**  Do not modify manually! Generated by graphgen on 2024-12-10T07:11:21.830Z. */

import { Edges, RelFrom, RelTo, type Relation, type SerializedGraph, Vertices } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

export type TPlangsVertexName =
  | "app"
  | "bundle"
  | "community"
  | "learning"
  | "library"
  | "license"
  | "paradigm"
  | "plang"
  | "platform"
  | "post"
  | "tag"
  | "tool"
  | "typeSystem";

/** Supported relations of each class. */
export type TPlangsRelations = {
  app: VAppRelName;
  bundle: VBundleRelName;
  community: VCommunityRelName;
  learning: VLearningRelName;
  library: VLibraryRelName;
  license: VLicenseRelName;
  paradigm: VParadigmRelName;
  plang: VPlangRelName;
  platform: VPlatformRelName;
  post: VPostRelName;
  tag: VTagRelName;
  tool: VToolRelName;
  typeSystem: VTypeSystemRelName;
};

/** Every Generated Vertex Class. */
export type TPlangsVertexClass =
  | VApp
  | VBundle
  | VCommunity
  | VLearning
  | VLibrary
  | VLicense
  | VParadigm
  | VPlang
  | VPlatform
  | VPost
  | VTag
  | VTool
  | VTypeSystem;

/** Used for better autocomplete. */
export type TPlangsVClassByName = {
  app: VApp;
  bundle: VBundle;
  community: VCommunity;
  learning: VLearning;
  library: VLibrary;
  license: VLicense;
  paradigm: VParadigm;
  plang: VPlang;
  platform: VPlatform;
  post: VPost;
  tag: VTag;
  tool: VTool;
  typeSystem: VTypeSystem;
};

/** Supported edges of the graph. */
export type TPlangsEdgeName = keyof PlangsGraphBase["edges"];

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  /** Return a type checked object identifying a relationship of a specific kind of Vertex. */
  static relConfig<T extends TPlangsVertexName>(vertexName: T, vertexRel: TPlangsRelations[T]) {
    const klass = PlangsGraphBase.vertexClass(vertexName);
    // @ts-ignore correct by construction.
    const rel = klass.relations.get(vertexRel) as Relation<TPlangsEdgeName>;
    return { kind: "rel", edgeName: rel.edgeName, direction: rel.direction } as const;
  }

  /** Return a type checked object identifying a property of the class that is "readable" (a prop returning a String, Boolean or Nunber). */
  static propConfig<T extends TPlangsVertexName>(vertexName: T, vertexProp: keyof TPlangsVClassByName[T]) {
    return { kind: "prop", vertexName: vertexName as TPlangsVertexName, vertexProp: vertexProp as string } as const;
  }

  /** Get a Vertex class by its Vertex name. */
  static vertexClass<T extends TPlangsVertexName>(vertexName: T) {
    // We cannot use a Map here because each of the classes will not be initialized yet.
    if (vertexName === "app") return VApp;
    if (vertexName === "bundle") return VBundle;
    if (vertexName === "community") return VCommunity;
    if (vertexName === "learning") return VLearning;
    if (vertexName === "library") return VLibrary;
    if (vertexName === "license") return VLicense;
    if (vertexName === "paradigm") return VParadigm;
    if (vertexName === "plang") return VPlang;
    if (vertexName === "platform") return VPlatform;
    if (vertexName === "post") return VPost;
    if (vertexName === "tag") return VTag;
    if (vertexName === "tool") return VTool;
    if (vertexName === "typeSystem") return VTypeSystem;
  }

  /** Vertex kinds per Vertex Name. The kind is the prefix of a Vertex Key. */
  static readonly vertexKind = new Map<TPlangsVertexName, string>([
    ["app", "app"],
    ["bundle", "bun"],
    ["community", "comm"],
    ["learning", "learn"],
    ["library", "lib"],
    ["license", "lic"],
    ["paradigm", "para"],
    ["plang", "pl"],
    ["platform", "plat"],
    ["post", "post"],
    ["tag", "tag"],
    ["tool", "tool"],
    ["typeSystem", "tsys"],
  ]);

  /** Reverse map of vertexKind. */
  static readonly vertexNameByKind = new Map<string, TPlangsVertexName>(Array.from(PlangsGraphBase.vertexKind.entries()).map(([k, v]) => [v, k]));

  /** Get a vertex by key, if the kind of vertex is known. */
  getVertex(vertexKey: string): TPlangsVertexClass | undefined {
    const kind = vertexKey.split("+", 2)[0] as TPlangsVertexName;
    const vertexName = PlangsGraphBase.vertexNameByKind.get(kind);
    if (!vertexName) return;
    return this.vertices[vertexName]?.get(vertexKey as any);
  }

  // Create a Vertices instances for each vertex.

  readonly app = new Vertices<VApp>("app", "app", key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>("bundle", "bun", key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>("community", "comm", key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>("learning", "learn", key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>("library", "lib", key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>("license", "lic", key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>("paradigm", "para", key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>("plang", "pl", key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>("platform", "plat", key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>("post", "post", key => new VPost(this, key));
  readonly tag = new Vertices<VTag>("tag", "tag", key => new VTag(this, key));
  readonly tool = new Vertices<VTool>("tool", "tool", key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>("typeSystem", "tsys", key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly vertices = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    appRelPlatforms: new Edges(this.app, this.platform, "Platforms", "Apps"),
    appRelWrittenWith: new Edges(this.app, this.plang, "Plangs", "Apps"),
    bundleRelPlangs: new Edges(this.bundle, this.plang, "Plangs", "Bundles"),
    bundleRelTools: new Edges(this.bundle, this.tool, "Tools", "Bundles"),
    communityRelApps: new Edges(this.community, this.app, "Apps", "Communities"),
    communityRelLibraries: new Edges(this.community, this.library, "Libraries", "Communities"),
    communityRelPlangs: new Edges(this.community, this.plang, "Plangs", "Communities"),
    communityRelTools: new Edges(this.community, this.tool, "Tools", "Communities"),
    learningRelApps: new Edges(this.learning, this.app, "Apps", "Learning Resources"),
    learningRelCommunities: new Edges(this.learning, this.community, "Communities", "Learning Resources"),
    learningRelLibraries: new Edges(this.learning, this.library, "Libraries", "Learning Resources"),
    learningRelPlangs: new Edges(this.learning, this.plang, "Plangs", "Learning Resources"),
    learningRelTools: new Edges(this.learning, this.tool, "Tools", "Learning Resources"),
    libraryRelPlangs: new Edges(this.library, this.plang, "Plangs", "Libraries"),
    libraryRelPlatforms: new Edges(this.library, this.platform, "Platforms", "Libraries"),
    libraryRelWrittenWith: new Edges(this.library, this.plang, "Written With", "Used for Libraries"),
    licenseRelApps: new Edges(this.license, this.app, "Apps", "Licenses"),
    licenseRelLibraries: new Edges(this.license, this.library, "Libraries", "Licenses"),
    licenseRelPlangs: new Edges(this.license, this.plang, "Plangs", "Licenses"),
    licenseRelTools: new Edges(this.license, this.tool, "Tools", "Licenses"),
    plangRelCompilesTo: new Edges(this.plang, this.plang, "Transpiling Targets", "Source Plangs"),
    plangRelDialectOf: new Edges(this.plang, this.plang, "Dialect of", "Dialects"),
    plangRelImplements: new Edges(this.plang, this.plang, "Implements", "Implemented By"),
    plangRelInfluencedBy: new Edges(this.plang, this.plang, "Influenced By", "Influenced"),
    plangRelParadigms: new Edges(this.plang, this.paradigm, "Paradigms", "Plangs"),
    plangRelPlatforms: new Edges(this.plang, this.platform, "Platforms", "Plangs"),
    plangRelTools: new Edges(this.plang, this.tool, "Tools", "Plangs"),
    plangRelTypeSystems: new Edges(this.plang, this.typeSystem, "Type Systems", "Plangs"),
    plangRelWrittenWith: new Edges(this.plang, this.plang, "Written With", "Used to Write"),
    postRelApps: new Edges(this.post, this.app, "Apps", "Posts"),
    postRelCommunities: new Edges(this.post, this.community, "Communities", "Posts"),
    postRelLearning: new Edges(this.post, this.learning, "Learning Resources", "Posts"),
    postRelLibraries: new Edges(this.post, this.library, "Libraries", "Posts"),
    postRelPlangs: new Edges(this.post, this.plang, "Plangs", "Posts"),
    postRelTools: new Edges(this.post, this.tool, "Tools", "Posts"),
    tagRelApps: new Edges(this.tag, this.app, "Apps tagged", "Tags"),
    tagRelCommunities: new Edges(this.tag, this.community, "Communities", "Tags"),
    tagRelLearning: new Edges(this.tag, this.learning, "Learning Resources", "Tags"),
    tagRelLibraries: new Edges(this.tag, this.library, "Libraries", "Tags"),
    tagRelPlangs: new Edges(this.tag, this.plang, "Plangs", "Tags"),
    tagRelTools: new Edges(this.tag, this.tool, "Tools", "Tags"),
    toolRelPlatforms: new Edges(this.tool, this.platform, "Platforms", "Tools"),
    toolRelWrittenWith: new Edges(this.tool, this.plang, "Implemented With", "Tool Plang"),
  } as const;

  toJSON(): SerializedGraph {
    return {
      vertices: Object.fromEntries(Object.entries(this.vertices).map(([k, v]) => [k, v.toJSON()])),
      edges: Object.fromEntries(Object.entries(this.edges).map(([k, e]) => [k, e.toJSON()])),
    };
  }

  loadJSON(data: SerializedGraph): this {
    for (const [vertexName, vertices] of Object.entries(data.vertices)) {
      const map = this.vertices[vertexName as TPlangsVertexName];
      for (const [vertexKey, vertexData] of Object.entries(vertices)) {
        map.set(vertexKey as any, vertexData as any);
      }
    }
    for (const [edgeName, edges] of Object.entries(data.edges)) {
      const map = this.edges[edgeName as keyof typeof this.edges];
      for (const [fromKey, toKeys] of Object.entries(edges)) {
        map.add(fromKey as any, ...(toKeys as any[]));
      }
    }
    return this;
  }
}

/** Type of the key of an instance of {@link VApp}. */
export type VAppKey = `app+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VAppRels = ["relCommunities", "relLearning", "relLicenses", "relPlatforms", "relPosts", "relTags", "relWrittenWith"] as const;

export type VAppRelName = (typeof VAppRels)[number];

/** Software Application */
export abstract class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly vertexKind = "app" as const;
  static readonly vertexName = "app" as const;
  static readonly vertexDesc = "Software Application";

  override readonly vertexKind = VAppBase.vertexKind;
  override readonly vertexDesc = VAppBase.vertexDesc;
  override readonly vertexName = VAppBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VAppRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VAppRels.map(name => this[name]);
  }

  /** Communities `VCommunity-[relApps]->(this:VApp)`. Inverse: {@link VCommunity.relApps}. */
  get relCommunities() {
    return new RelTo(this as unknown as VApp, this.graph.edges.communityRelApps);
  }

  /** Learning Resources `VLearning-[relApps]->(this:VApp)`. Inverse: {@link VLearning.relApps}. */
  get relLearning() {
    return new RelTo(this as unknown as VApp, this.graph.edges.learningRelApps);
  }

  /** Licenses `VLicense-[relApps]->(this:VApp)`. Inverse: {@link VLicense.relApps}. */
  get relLicenses() {
    return new RelTo(this as unknown as VApp, this.graph.edges.licenseRelApps);
  }

  /** Platforms `(this:VApp)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relApps}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelPlatforms);
  }

  /** Posts `VPost-[relApps]->(this:VApp)`. Inverse: {@link VPost.relApps}. */
  get relPosts() {
    return new RelTo(this as unknown as VApp, this.graph.edges.postRelApps);
  }

  /** Tags `VTag-[relApps]->(this:VApp)`. Inverse: {@link VTag.relApps}. */
  get relTags() {
    return new RelTo(this as unknown as VApp, this.graph.edges.tagRelApps);
  }

  /** Plangs `(this:VApp)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relApps}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VBundle}. */
export type VBundleKey = `bun+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VBundleRels = ["relPlangs", "relTools"] as const;

export type VBundleRelName = (typeof VBundleRels)[number];

/** Bundle of Tools */
export abstract class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly vertexKind = "bun" as const;
  static readonly vertexName = "bundle" as const;
  static readonly vertexDesc = "Bundle of Tools";

  override readonly vertexKind = VBundleBase.vertexKind;
  override readonly vertexDesc = VBundleBase.vertexDesc;
  override readonly vertexName = VBundleBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VBundleRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VBundleRels.map(name => this[name]);
  }

  /** Plangs `(this:VBundle)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relBundles}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelPlangs);
  }

  /** Tools `(this:VBundle)-[relTools]->VTool`. Inverse: {@link VTool.relBundles}. */
  get relTools() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelTools);
  }
}

/** Type of the key of an instance of {@link VCommunity}. */
export type VCommunityKey = `comm+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VCommunityRels = ["relApps", "relLearning", "relLibraries", "relPlangs", "relPosts", "relTags", "relTools"] as const;

export type VCommunityRelName = (typeof VCommunityRels)[number];

/** Community */
export abstract class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly vertexKind = "comm" as const;
  static readonly vertexName = "community" as const;
  static readonly vertexDesc = "Community";

  override readonly vertexKind = VCommunityBase.vertexKind;
  override readonly vertexDesc = VCommunityBase.vertexDesc;
  override readonly vertexName = VCommunityBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VCommunityRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VCommunityRels.map(name => this[name]);
  }

  /** Apps `(this:VCommunity)-[relApps]->VApp`. Inverse: {@link VApp.relCommunities}. */
  get relApps() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelApps);
  }

  /** Learning Resources `VLearning-[relCommunities]->(this:VCommunity)`. Inverse: {@link VLearning.relCommunities}. */
  get relLearning() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.learningRelCommunities);
  }

  /** Libraries `(this:VCommunity)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relCommunities}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelLibraries);
  }

  /** Plangs `(this:VCommunity)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relCommunities}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelPlangs);
  }

  /** Posts `VPost-[relCommunities]->(this:VCommunity)`. Inverse: {@link VPost.relCommunities}. */
  get relPosts() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.postRelCommunities);
  }

  /** Tags `VTag-[relCommunities]->(this:VCommunity)`. Inverse: {@link VTag.relCommunities}. */
  get relTags() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.tagRelCommunities);
  }

  /** Tools `(this:VCommunity)-[relTools]->VTool`. Inverse: {@link VTool.relCommunities}. */
  get relTools() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelTools);
  }
}

/** Type of the key of an instance of {@link VLearning}. */
export type VLearningKey = `learn+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VLearningRels = ["relApps", "relCommunities", "relLibraries", "relPlangs", "relPosts", "relTags", "relTools"] as const;

export type VLearningRelName = (typeof VLearningRels)[number];

/** Learning Resource */
export abstract class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly vertexKind = "learn" as const;
  static readonly vertexName = "learning" as const;
  static readonly vertexDesc = "Learning Resource";

  override readonly vertexKind = VLearningBase.vertexKind;
  override readonly vertexDesc = VLearningBase.vertexDesc;
  override readonly vertexName = VLearningBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VLearningRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VLearningRels.map(name => this[name]);
  }

  /** Apps `(this:VLearning)-[relApps]->VApp`. Inverse: {@link VApp.relLearning}. */
  get relApps() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelApps);
  }

  /** Communities `(this:VLearning)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relLearning}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelCommunities);
  }

  /** Libraries `(this:VLearning)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLearning}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelLibraries);
  }

  /** Plangs `(this:VLearning)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLearning}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelPlangs);
  }

  /** Posts `VPost-[relLearning]->(this:VLearning)`. Inverse: {@link VPost.relLearning}. */
  get relPosts() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.postRelLearning);
  }

  /** Tags `VTag-[relLearning]->(this:VLearning)`. Inverse: {@link VTag.relLearning}. */
  get relTags() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.tagRelLearning);
  }

  /** Tools `(this:VLearning)-[relTools]->VTool`. Inverse: {@link VTool.relLearning}. */
  get relTools() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelTools);
  }
}

/** Type of the key of an instance of {@link VLibrary}. */
export type VLibraryKey = `lib+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VLibraryRels = [
  "relCommunities",
  "relLearning",
  "relLicenses",
  "relPlangs",
  "relPlatforms",
  "relPosts",
  "relTags",
  "relWrittenWith",
] as const;

export type VLibraryRelName = (typeof VLibraryRels)[number];

/** Software Library */
export abstract class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly vertexKind = "lib" as const;
  static readonly vertexName = "library" as const;
  static readonly vertexDesc = "Software Library";

  override readonly vertexKind = VLibraryBase.vertexKind;
  override readonly vertexDesc = VLibraryBase.vertexDesc;
  override readonly vertexName = VLibraryBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VLibraryRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VLibraryRels.map(name => this[name]);
  }

  /** Communities `VCommunity-[relLibraries]->(this:VLibrary)`. Inverse: {@link VCommunity.relLibraries}. */
  get relCommunities() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.communityRelLibraries);
  }

  /** Learning Resources `VLearning-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLearning.relLibraries}. */
  get relLearning() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.learningRelLibraries);
  }

  /** Licenses `VLicense-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLicense.relLibraries}. */
  get relLicenses() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs `(this:VLibrary)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLibraries}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlangs);
  }

  /** Platforms `(this:VLibrary)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relLibraries}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlatforms);
  }

  /** Posts `VPost-[relLibraries]->(this:VLibrary)`. Inverse: {@link VPost.relLibraries}. */
  get relPosts() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.postRelLibraries);
  }

  /** Tags `VTag-[relLibraries]->(this:VLibrary)`. Inverse: {@link VTag.relLibraries}. */
  get relTags() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.tagRelLibraries);
  }

  /** Written With `(this:VLibrary)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedInLibrary}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VLicense}. */
export type VLicenseKey = `lic+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VLicenseRels = ["relApps", "relLibraries", "relPlangs", "relTools"] as const;

export type VLicenseRelName = (typeof VLicenseRels)[number];

/** Software License */
export abstract class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly vertexKind = "lic" as const;
  static readonly vertexName = "license" as const;
  static readonly vertexDesc = "Software License";

  override readonly vertexKind = VLicenseBase.vertexKind;
  override readonly vertexDesc = VLicenseBase.vertexDesc;
  override readonly vertexName = VLicenseBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VLicenseRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VLicenseRels.map(name => this[name]);
  }

  /** Apps `(this:VLicense)-[relApps]->VApp`. Inverse: {@link VApp.relLicenses}. */
  get relApps() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelApps);
  }

  /** Libraries `(this:VLicense)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLicenses}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs `(this:VLicense)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLicenses}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelPlangs);
  }

  /** Tools `(this:VLicense)-[relTools]->VTool`. Inverse: {@link VTool.relLicenses}. */
  get relTools() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelTools);
  }
}

/** Type of the key of an instance of {@link VParadigm}. */
export type VParadigmKey = `para+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VParadigmRels = ["relPlangs"] as const;

export type VParadigmRelName = (typeof VParadigmRels)[number];

/** Programming Language Paradigm */
export abstract class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly vertexKind = "para" as const;
  static readonly vertexName = "paradigm" as const;
  static readonly vertexDesc = "Programming Language Paradigm";

  override readonly vertexKind = VParadigmBase.vertexKind;
  override readonly vertexDesc = VParadigmBase.vertexDesc;
  override readonly vertexName = VParadigmBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VParadigmRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VParadigmRels.map(name => this[name]);
  }

  /** Plangs `VPlang-[relParadigms]->(this:VParadigm)`. Inverse: {@link VPlang.relParadigms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VParadigm, this.graph.edges.plangRelParadigms);
  }
}

/** Type of the key of an instance of {@link VPlang}. */
export type VPlangKey = `pl+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VPlangRels = [
  "relApps",
  "relBundles",
  "relCommunities",
  "relCompilesTo",
  "relDialectOf",
  "relDialects",
  "relImplementedBy",
  "relImplements",
  "relInfluenced",
  "relInfluencedBy",
  "relLearning",
  "relLibraries",
  "relLicenses",
  "relParadigms",
  "relPlatforms",
  "relPosts",
  "relTags",
  "relTargetOf",
  "relTools",
  "relToolsUsing",
  "relTypeSystems",
  "relUsedInLibrary",
  "relUsedToWrite",
  "relWrittenWith",
] as const;

export type VPlangRelName = (typeof VPlangRels)[number];

/** Programming Language */
export abstract class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly vertexKind = "pl" as const;
  static readonly vertexName = "plang" as const;
  static readonly vertexDesc = "Programming Language";

  override readonly vertexKind = VPlangBase.vertexKind;
  override readonly vertexDesc = VPlangBase.vertexDesc;
  override readonly vertexName = VPlangBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VPlangRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VPlangRels.map(name => this[name]);
  }

  /** Apps `VApp-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VApp.relWrittenWith}. */
  get relApps() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.appRelWrittenWith);
  }

  /** Bundles `VBundle-[relPlangs]->(this:VPlang)`. Inverse: {@link VBundle.relPlangs}. */
  get relBundles() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.bundleRelPlangs);
  }

  /** Communities `VCommunity-[relPlangs]->(this:VPlang)`. Inverse: {@link VCommunity.relPlangs}. */
  get relCommunities() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.communityRelPlangs);
  }

  /** Transpiling Targets `(this:VPlang)-[relCompilesTo]->VPlang`. Inverse: {@link VPlang.relTargetOf}. */
  get relCompilesTo() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Dialect of `(this:VPlang)-[relDialectOf]->VPlang`. Inverse: {@link VPlang.relDialects}. */
  get relDialectOf() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Dialects `VPlang-[relDialectOf]->(this:VPlang)`. Inverse: {@link VPlang.relDialectOf}. */
  get relDialects() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Implemented By `VPlang-[relImplements]->(this:VPlang)`. Inverse: {@link VPlang.relImplements}. */
  get relImplementedBy() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Implements `(this:VPlang)-[relImplements]->VPlang`. Inverse: {@link VPlang.relImplementedBy}. */
  get relImplements() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Influenced `VPlang-[relInfluencedBy]->(this:VPlang)`. Inverse: {@link VPlang.relInfluencedBy}. */
  get relInfluenced() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Influenced By `(this:VPlang)-[relInfluencedBy]->VPlang`. Inverse: {@link VPlang.relInfluenced}. */
  get relInfluencedBy() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Learning Resources `VLearning-[relPlangs]->(this:VPlang)`. Inverse: {@link VLearning.relPlangs}. */
  get relLearning() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.learningRelPlangs);
  }

  /** Libraries `VLibrary-[relPlangs]->(this:VPlang)`. Inverse: {@link VLibrary.relPlangs}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelPlangs);
  }

  /** Licenses `VLicense-[relPlangs]->(this:VPlang)`. Inverse: {@link VLicense.relPlangs}. */
  get relLicenses() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.licenseRelPlangs);
  }

  /** Paradigms `(this:VPlang)-[relParadigms]->VParadigm`. Inverse: {@link VParadigm.relPlangs}. */
  get relParadigms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelParadigms);
  }

  /** Platforms `(this:VPlang)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relPlangs}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelPlatforms);
  }

  /** Posts `VPost-[relPlangs]->(this:VPlang)`. Inverse: {@link VPost.relPlangs}. */
  get relPosts() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.postRelPlangs);
  }

  /** Tags `VTag-[relPlangs]->(this:VPlang)`. Inverse: {@link VTag.relPlangs}. */
  get relTags() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.tagRelPlangs);
  }

  /** Source Plangs `VPlang-[relCompilesTo]->(this:VPlang)`. Inverse: {@link VPlang.relCompilesTo}. */
  get relTargetOf() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Tools `(this:VPlang)-[relTools]->VTool`. Inverse: {@link VTool.relPlangs}. */
  get relTools() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTools);
  }

  /** Tool Plang `VTool-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VTool.relWrittenWith}. */
  get relToolsUsing() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.toolRelWrittenWith);
  }

  /** Type Systems `(this:VPlang)-[relTypeSystems]->VTypeSystem`. Inverse: {@link VTypeSystem.relPlangs}. */
  get relTypeSystems() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTypeSystems);
  }

  /** Used for Libraries `VLibrary-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VLibrary.relWrittenWith}. */
  get relUsedInLibrary() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelWrittenWith);
  }

  /** Used to Write `VPlang-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VPlang.relWrittenWith}. */
  get relUsedToWrite() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Written With `(this:VPlang)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedToWrite}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VPlatform}. */
export type VPlatformKey = `plat+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VPlatformRels = ["relApps", "relLibraries", "relPlangs", "relTools"] as const;

export type VPlatformRelName = (typeof VPlatformRels)[number];

/** Platform where Software runs */
export abstract class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly vertexKind = "plat" as const;
  static readonly vertexName = "platform" as const;
  static readonly vertexDesc = "Platform where Software runs";

  override readonly vertexKind = VPlatformBase.vertexKind;
  override readonly vertexDesc = VPlatformBase.vertexDesc;
  override readonly vertexName = VPlatformBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VPlatformRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VPlatformRels.map(name => this[name]);
  }

  /** Apps `VApp-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VApp.relPlatforms}. */
  get relApps() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.appRelPlatforms);
  }

  /** Libraries `VLibrary-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VLibrary.relPlatforms}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.libraryRelPlatforms);
  }

  /** Plangs `VPlang-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VPlang.relPlatforms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.plangRelPlatforms);
  }

  /** Tools `VTool-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VTool.relPlatforms}. */
  get relTools() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.toolRelPlatforms);
  }
}

/** Type of the key of an instance of {@link VPost}. */
export type VPostKey = `post+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VPostRels = ["relApps", "relCommunities", "relLearning", "relLibraries", "relPlangs", "relTools"] as const;

export type VPostRelName = (typeof VPostRels)[number];

/** Blog Post */
export abstract class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly vertexKind = "post" as const;
  static readonly vertexName = "post" as const;
  static readonly vertexDesc = "Blog Post";

  override readonly vertexKind = VPostBase.vertexKind;
  override readonly vertexDesc = VPostBase.vertexDesc;
  override readonly vertexName = VPostBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VPostRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VPostRels.map(name => this[name]);
  }

  /** Apps `(this:VPost)-[relApps]->VApp`. Inverse: {@link VApp.relPosts}. */
  get relApps() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelApps);
  }

  /** Communities `(this:VPost)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relPosts}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelCommunities);
  }

  /** Learning Resources `(this:VPost)-[relLearning]->VLearning`. Inverse: {@link VLearning.relPosts}. */
  get relLearning() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelLearning);
  }

  /** Libraries `(this:VPost)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relPosts}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelLibraries);
  }

  /** Plangs `(this:VPost)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relPosts}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelPlangs);
  }

  /** Tools `(this:VPost)-[relTools]->VTool`. Inverse: {@link VTool.relPosts}. */
  get relTools() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelTools);
  }
}

/** Type of the key of an instance of {@link VTag}. */
export type VTagKey = `tag+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VTagRels = ["relApps", "relCommunities", "relLearning", "relLibraries", "relPlangs", "relTools"] as const;

export type VTagRelName = (typeof VTagRels)[number];

/** Tag */
export abstract class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly vertexKind = "tag" as const;
  static readonly vertexName = "tag" as const;
  static readonly vertexDesc = "Tag";

  override readonly vertexKind = VTagBase.vertexKind;
  override readonly vertexDesc = VTagBase.vertexDesc;
  override readonly vertexName = VTagBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VTagRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VTagRels.map(name => this[name]);
  }

  /** Apps tagged `(this:VTag)-[relApps]->VApp`. Inverse: {@link VApp.relTags}. */
  get relApps() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelApps);
  }

  /** Communities `(this:VTag)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relTags}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelCommunities);
  }

  /** Learning Resources `(this:VTag)-[relLearning]->VLearning`. Inverse: {@link VLearning.relTags}. */
  get relLearning() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLearning);
  }

  /** Libraries `(this:VTag)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relTags}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLibraries);
  }

  /** Plangs `(this:VTag)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relTags}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelPlangs);
  }

  /** Tools `(this:VTag)-[relTools]->VTool`. Inverse: {@link VTool.relTags}. */
  get relTools() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelTools);
  }
}

/** Type of the key of an instance of {@link VTool}. */
export type VToolKey = `tool+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VToolRels = [
  "relBundles",
  "relCommunities",
  "relLearning",
  "relLicenses",
  "relPlangs",
  "relPlatforms",
  "relPosts",
  "relTags",
  "relWrittenWith",
] as const;

export type VToolRelName = (typeof VToolRels)[number];

/** Programming Tool */
export abstract class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly vertexKind = "tool" as const;
  static readonly vertexName = "tool" as const;
  static readonly vertexDesc = "Programming Tool";

  override readonly vertexKind = VToolBase.vertexKind;
  override readonly vertexDesc = VToolBase.vertexDesc;
  override readonly vertexName = VToolBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VToolRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VToolRels.map(name => this[name]);
  }

  /** Bundles `VBundle-[relTools]->(this:VTool)`. Inverse: {@link VBundle.relTools}. */
  get relBundles() {
    return new RelTo(this as unknown as VTool, this.graph.edges.bundleRelTools);
  }

  /** Communities `VCommunity-[relTools]->(this:VTool)`. Inverse: {@link VCommunity.relTools}. */
  get relCommunities() {
    return new RelTo(this as unknown as VTool, this.graph.edges.communityRelTools);
  }

  /** Learning Resources `VLearning-[relTools]->(this:VTool)`. Inverse: {@link VLearning.relTools}. */
  get relLearning() {
    return new RelTo(this as unknown as VTool, this.graph.edges.learningRelTools);
  }

  /** Licenses `VLicense-[relTools]->(this:VTool)`. Inverse: {@link VLicense.relTools}. */
  get relLicenses() {
    return new RelTo(this as unknown as VTool, this.graph.edges.licenseRelTools);
  }

  /** Plangs `VPlang-[relTools]->(this:VTool)`. Inverse: {@link VPlang.relTools}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTool, this.graph.edges.plangRelTools);
  }

  /** Platforms `(this:VTool)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relTools}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelPlatforms);
  }

  /** Posts `VPost-[relTools]->(this:VTool)`. Inverse: {@link VPost.relTools}. */
  get relPosts() {
    return new RelTo(this as unknown as VTool, this.graph.edges.postRelTools);
  }

  /** Tags `VTag-[relTools]->(this:VTool)`. Inverse: {@link VTag.relTools}. */
  get relTags() {
    return new RelTo(this as unknown as VTool, this.graph.edges.tagRelTools);
  }

  /** Implemented With `(this:VTool)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relToolsUsing}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VTypeSystem}. */
export type VTypeSystemKey = `tsys+${string}`;

/** The Vertex responds to the following relationship getters. */
export const VTypeSystemRels = ["relPlangs"] as const;

export type VTypeSystemRelName = (typeof VTypeSystemRels)[number];

/** Type System */
export abstract class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly vertexKind = "tsys" as const;
  static readonly vertexName = "typeSystem" as const;
  static readonly vertexDesc = "Type System";

  override readonly vertexKind = VTypeSystemBase.vertexKind;
  override readonly vertexDesc = VTypeSystemBase.vertexDesc;
  override readonly vertexName = VTypeSystemBase.vertexName;

  /** Get one relationship by name. */
  relation(name: VTypeSystemRelName) {
    return this[name];
  }

  /* Get all relationships as an Array. */
  relations() {
    return VTypeSystemRels.map(name => this[name]);
  }

  /** Plangs `VPlang-[relTypeSystems]->(this:VTypeSystem)`. Inverse: {@link VPlang.relTypeSystems}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTypeSystem, this.graph.edges.plangRelTypeSystems);
  }
}
