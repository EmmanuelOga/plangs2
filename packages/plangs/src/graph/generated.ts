/**  Do not modify manually! Generated by graphgen on 2024-11-30T04:45:21.687Z. */

import { Edges, RelFrom, RelTo, type SerializedGraph, Vertices } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

export const PLANGS_GRAPH_CONFIG = {
  app: {
    key: "app",
    relations: {
      relWrittenWith: { from: "app", to: "plang", edgeName: "appRelWrittenWith", direction: "direct", desc: "Plangs used to implement this." },
      relLicenses: { from: "license", to: "app", edgeName: "licenseRelApps", direction: "inverse", desc: "Licenses." },
      relTags: { from: "tag", to: "app", edgeName: "tagRelApps", direction: "inverse", desc: "Tags." },
      relPlatforms: { from: "app", to: "platform", edgeName: "appRelPlatforms", direction: "direct", desc: "Platforms supported." },
    },
  },
  bundle: {
    key: "bun",
    relations: {
      relPlangs: { from: "bundle", to: "plang", edgeName: "bundleRelPlangs", direction: "direct", desc: "Plangs this Bundle is for." },
      relTools: { from: "bundle", to: "tool", edgeName: "bundleRelTools", direction: "direct", desc: "Tools in this." },
    },
  },
  community: {
    key: "comm",
    relations: {
      relPlangs: { from: "community", to: "plang", edgeName: "communityRelPlangs", direction: "direct", desc: "Plangs supported." },
      relTags: { from: "tag", to: "community", edgeName: "tagRelCommunities", direction: "inverse", desc: "Tags." },
      relLearning: { from: "learning", to: "community", edgeName: "learningRelCommunities", direction: "inverse", desc: "Learning resources." },
    },
  },
  learning: {
    key: "learn",
    relations: {
      relPlangs: { from: "learning", to: "plang", edgeName: "learningRelPlangs", direction: "direct", desc: "Plangs covered." },
      relTags: { from: "tag", to: "learning", edgeName: "tagRelLearning", direction: "inverse", desc: "Tags." },
      relCommunities: {
        from: "learning",
        to: "community",
        edgeName: "learningRelCommunities",
        direction: "direct",
        desc: "Communities supporting this.",
      },
    },
  },
  library: {
    key: "lib",
    relations: {
      relPlangs: { from: "library", to: "plang", edgeName: "libraryRelPlangs", direction: "direct", desc: "Plangs supported." },
      relWrittenWith: { from: "library", to: "plang", edgeName: "libraryRelWrittenWith", direction: "direct", desc: "Plangs used." },
      relLicenses: { from: "license", to: "library", edgeName: "licenseRelLibraries", direction: "inverse", desc: "Licenses." },
      relTags: { from: "tag", to: "library", edgeName: "tagRelLibraries", direction: "inverse", desc: "Tags." },
      relPlatforms: { from: "library", to: "platform", edgeName: "libraryRelPlatforms", direction: "direct", desc: "Platforms supported." },
    },
  },
  license: {
    key: "lic",
    relations: {
      relPlangs: { from: "license", to: "plang", edgeName: "licenseRelPlangs", direction: "direct", desc: "Plangs using this." },
      relApps: { from: "license", to: "app", edgeName: "licenseRelApps", direction: "direct", desc: "Apps using this." },
      relLibraries: { from: "license", to: "library", edgeName: "licenseRelLibraries", direction: "direct", desc: "Libraries using this." },
      relTools: { from: "license", to: "tool", edgeName: "licenseRelTools", direction: "direct", desc: "Tools using this." },
    },
  },
  paradigm: {
    key: "para",
    relations: {
      relPlangs: { from: "plang", to: "paradigm", edgeName: "plangRelParadigms", direction: "inverse", desc: "Plangs implementing this." },
    },
  },
  plang: {
    key: "pl",
    relations: {
      relParadigms: { from: "plang", to: "paradigm", edgeName: "plangRelParadigms", direction: "direct", desc: "Paradigms implemented." },
      relPlatforms: { from: "plang", to: "platform", edgeName: "plangRelPlatforms", direction: "direct", desc: "Platforms supported." },
      relTools: { from: "plang", to: "tool", edgeName: "plangRelTools", direction: "direct", desc: "Tools for this." },
      relTypeSystems: { from: "plang", to: "typeSystem", edgeName: "plangRelTypeSystems", direction: "direct", desc: "Type Systems implemented." },
      relCompilesTo: { from: "plang", to: "plang", edgeName: "plangRelCompilesTo", direction: "direct", desc: "Transpiling targets." },
      relTargetOf: { from: "plang", to: "plang", edgeName: "plangRelCompilesTo", direction: "inverse", desc: "Plangs compiling to this." },
      relDialectOf: { from: "plang", to: "plang", edgeName: "plangRelDialectOf", direction: "direct", desc: "Plangs this is a Dialect of." },
      relDialects: { from: "plang", to: "plang", edgeName: "plangRelDialectOf", direction: "inverse", desc: "Dialects." },
      relImplements: { from: "plang", to: "plang", edgeName: "plangRelImplements", direction: "direct", desc: "Plangs this Implements." },
      relImplementedBy: { from: "plang", to: "plang", edgeName: "plangRelImplements", direction: "inverse", desc: "Plangs implementing this." },
      relInfluencedBy: { from: "plang", to: "plang", edgeName: "plangRelInfluencedBy", direction: "direct", desc: "Plangs that influenced this." },
      relInfluenced: { from: "plang", to: "plang", edgeName: "plangRelInfluencedBy", direction: "inverse", desc: "Plangs this influenced." },
      relWrittenWith: { from: "plang", to: "plang", edgeName: "plangRelWrittenWith", direction: "direct", desc: "Plangs used to implement this." },
      relUsedToWrite: { from: "plang", to: "plang", edgeName: "plangRelWrittenWith", direction: "inverse", desc: "Plangs implemented with this." },
      relApps: { from: "app", to: "plang", edgeName: "appRelWrittenWith", direction: "inverse", desc: "Apps implemented with this." },
      relBundles: { from: "bundle", to: "plang", edgeName: "bundleRelPlangs", direction: "inverse", desc: "Bundles of Tools for this." },
      relCommunities: { from: "community", to: "plang", edgeName: "communityRelPlangs", direction: "inverse", desc: "Communities suporting this." },
      relLearning: { from: "learning", to: "plang", edgeName: "learningRelPlangs", direction: "inverse", desc: "Learning resources." },
      relLibraries: { from: "library", to: "plang", edgeName: "libraryRelPlangs", direction: "inverse", desc: "Software Libraries." },
      relUsedInLibrary: { from: "library", to: "plang", edgeName: "libraryRelWrittenWith", direction: "inverse", desc: "Libraries made with this." },
      relLicenses: { from: "license", to: "plang", edgeName: "licenseRelPlangs", direction: "inverse", desc: "Licenses." },
      relPosts: { from: "post", to: "plang", edgeName: "postRelPlangs", direction: "inverse", desc: "Posts talking about this." },
      relTags: { from: "tag", to: "plang", edgeName: "tagRelPlangs", direction: "inverse", desc: "Tags." },
      relToolsUsing: { from: "tool", to: "plang", edgeName: "toolRelWrittenWith", direction: "inverse", desc: "Tools implemented with this." },
    },
  },
  platform: {
    key: "plat",
    relations: {
      relPlangs: { from: "plang", to: "platform", edgeName: "plangRelPlatforms", direction: "inverse", desc: "Plangs supporting this." },
      relApps: { from: "app", to: "platform", edgeName: "appRelPlatforms", direction: "inverse", desc: "Apps supporting this." },
      relLibraries: { from: "library", to: "platform", edgeName: "libraryRelPlatforms", direction: "inverse", desc: "Libraries supporting this." },
      relTools: { from: "tool", to: "platform", edgeName: "toolRelPlatforms", direction: "inverse", desc: "Tools supporting this." },
    },
  },
  post: {
    key: "post",
    relations: { relPlangs: { from: "post", to: "plang", edgeName: "postRelPlangs", direction: "direct", desc: "Plangs covered." } },
  },
  tag: {
    key: "tag",
    relations: {
      relPlangs: { from: "tag", to: "plang", edgeName: "tagRelPlangs", direction: "direct", desc: "Plangs tagged." },
      relApps: { from: "tag", to: "app", edgeName: "tagRelApps", direction: "direct", desc: "Apps tagged." },
      relCommunities: { from: "tag", to: "community", edgeName: "tagRelCommunities", direction: "direct", desc: "Communities tagged." },
      relLearning: { from: "tag", to: "learning", edgeName: "tagRelLearning", direction: "direct", desc: "Learning resources tagged." },
      relLibraries: { from: "tag", to: "library", edgeName: "tagRelLibraries", direction: "direct", desc: "Libraries tagged." },
      relTools: { from: "tag", to: "tool", edgeName: "tagRelTools", direction: "direct", desc: "Tools tagged." },
    },
  },
  tool: {
    key: "tool",
    relations: {
      relPlangs: { from: "plang", to: "tool", edgeName: "plangRelTools", direction: "inverse", desc: "Plangs supported." },
      relWrittenWith: { from: "tool", to: "plang", edgeName: "toolRelWrittenWith", direction: "direct", desc: "Plangs used to implement this." },
      relLicenses: { from: "license", to: "tool", edgeName: "licenseRelTools", direction: "inverse", desc: "Licenses." },
      relTags: { from: "tag", to: "tool", edgeName: "tagRelTools", direction: "inverse", desc: "Tags." },
      relBundles: { from: "bundle", to: "tool", edgeName: "bundleRelTools", direction: "inverse", desc: "Bundles including this." },
      relPlatforms: { from: "tool", to: "platform", edgeName: "toolRelPlatforms", direction: "direct", desc: "Platforms supported." },
    },
  },
  typeSystem: {
    key: "tsys",
    relations: {
      relPlangs: { from: "plang", to: "typeSystem", edgeName: "plangRelTypeSystems", direction: "inverse", desc: "Plangs implementing this." },
    },
  },
} as const;

export type TPlangsVertexName =
  | "app"
  | "bundle"
  | "community"
  | "learning"
  | "library"
  | "license"
  | "paradigm"
  | "plang"
  | "platform"
  | "post"
  | "tag"
  | "tool"
  | "typeSystem";
export type TPlangsVertexKind = "app" | "bun" | "comm" | "learn" | "lib" | "lic" | "para" | "pl" | "plat" | "post" | "tag" | "tool" | "tsys";
export type TPlangsEdgeName =
  | "appRelPlatforms"
  | "appRelWrittenWith"
  | "bundleRelPlangs"
  | "bundleRelTools"
  | "communityRelPlangs"
  | "learningRelCommunities"
  | "learningRelPlangs"
  | "libraryRelPlangs"
  | "libraryRelPlatforms"
  | "libraryRelWrittenWith"
  | "licenseRelApps"
  | "licenseRelLibraries"
  | "licenseRelPlangs"
  | "licenseRelTools"
  | "plangRelCompilesTo"
  | "plangRelDialectOf"
  | "plangRelImplements"
  | "plangRelInfluencedBy"
  | "plangRelParadigms"
  | "plangRelPlatforms"
  | "plangRelTools"
  | "plangRelTypeSystems"
  | "plangRelWrittenWith"
  | "postRelPlangs"
  | "tagRelApps"
  | "tagRelCommunities"
  | "tagRelLearning"
  | "tagRelLibraries"
  | "tagRelPlangs"
  | "tagRelTools"
  | "toolRelPlatforms"
  | "toolRelWrittenWith";

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  readonly app = new Vertices<VApp>(key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>(key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>(key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>(key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>(key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>(key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>(key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>(key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>(key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>(key => new VPost(this, key));
  readonly tag = new Vertices<VTag>(key => new VTag(this, key));
  readonly tool = new Vertices<VTool>(key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>(key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly vertices = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    appRelPlatforms: new Edges(this.app, this.platform),
    appRelWrittenWith: new Edges(this.app, this.plang),
    bundleRelPlangs: new Edges(this.bundle, this.plang),
    bundleRelTools: new Edges(this.bundle, this.tool),
    communityRelPlangs: new Edges(this.community, this.plang),
    learningRelCommunities: new Edges(this.learning, this.community),
    learningRelPlangs: new Edges(this.learning, this.plang),
    libraryRelPlangs: new Edges(this.library, this.plang),
    libraryRelPlatforms: new Edges(this.library, this.platform),
    libraryRelWrittenWith: new Edges(this.library, this.plang),
    licenseRelApps: new Edges(this.license, this.app),
    licenseRelLibraries: new Edges(this.license, this.library),
    licenseRelPlangs: new Edges(this.license, this.plang),
    licenseRelTools: new Edges(this.license, this.tool),
    plangRelCompilesTo: new Edges(this.plang, this.plang),
    plangRelDialectOf: new Edges(this.plang, this.plang),
    plangRelImplements: new Edges(this.plang, this.plang),
    plangRelInfluencedBy: new Edges(this.plang, this.plang),
    plangRelParadigms: new Edges(this.plang, this.paradigm),
    plangRelPlatforms: new Edges(this.plang, this.platform),
    plangRelTools: new Edges(this.plang, this.tool),
    plangRelTypeSystems: new Edges(this.plang, this.typeSystem),
    plangRelWrittenWith: new Edges(this.plang, this.plang),
    postRelPlangs: new Edges(this.post, this.plang),
    tagRelApps: new Edges(this.tag, this.app),
    tagRelCommunities: new Edges(this.tag, this.community),
    tagRelLearning: new Edges(this.tag, this.learning),
    tagRelLibraries: new Edges(this.tag, this.library),
    tagRelPlangs: new Edges(this.tag, this.plang),
    tagRelTools: new Edges(this.tag, this.tool),
    toolRelPlatforms: new Edges(this.tool, this.platform),
    toolRelWrittenWith: new Edges(this.tool, this.plang),
  } as const;

  toJSON(): SerializedGraph {
    return {
      vertices: Object.fromEntries(Object.entries(this.vertices).map(([k, v]) => [k, v.toJSON()])),
      edges: Object.fromEntries(Object.entries(this.edges).map(([k, e]) => [k, e.toJSON()])),
    };
  }

  loadJSON(data: SerializedGraph) {
    for (const [vertexName, vertices] of Object.entries(data.vertices)) {
      this.vertices[vertexName as TPlangsVertexName].setMany(vertices as [any, any]);
    }
    for (const [edgeName, edges] of Object.entries(data.edges)) {
      this.edges[edgeName as TPlangsEdgeName].addMany(edges as [any, any]);
    }
  }
}

/** Type of the key of an instance of {@link VApp}. */
export type VAppKey = `app+${string}`;

/** Relationship available on an instance of {@link VApp}. */
export type VAppRel = "relLicenses" | "relPlatforms" | "relTags" | "relWrittenWith";

/** Software Application */
export abstract class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly kind = "app";
  static readonly vertexName = "app";
  static readonly desc = "Software Application";

  override readonly kind = VAppBase.kind;
  override readonly desc = VAppBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VApp): { vertexName: TPlangsVertexName; propName: keyof VApp } {
    return { vertexName: VApp.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VAppRel) {
    return PLANGS_GRAPH_CONFIG.app.relations[relName];
  }

  /** Licenses. `VLicense-[relApps]->(this:VApp)`. Inverse: {@link VLicense.relApps}. */
  get relLicenses() {
    return new RelTo(this as unknown as VApp, this.graph.edges.licenseRelApps);
  }

  /** Platforms supported. `(this:VApp)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relApps}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelPlatforms);
  }

  /** Tags. `VTag-[relApps]->(this:VApp)`. Inverse: {@link VTag.relApps}. */
  get relTags() {
    return new RelTo(this as unknown as VApp, this.graph.edges.tagRelApps);
  }

  /** Plangs used to implement this. `(this:VApp)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relApps}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VBundle}. */
export type VBundleKey = `bun+${string}`;

/** Relationship available on an instance of {@link VBundle}. */
export type VBundleRel = "relPlangs" | "relTools";

/** Bundle of Tools */
export abstract class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly kind = "bun";
  static readonly vertexName = "bundle";
  static readonly desc = "Bundle of Tools";

  override readonly kind = VBundleBase.kind;
  override readonly desc = VBundleBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VBundle): { vertexName: TPlangsVertexName; propName: keyof VBundle } {
    return { vertexName: VBundle.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VBundleRel) {
    return PLANGS_GRAPH_CONFIG.bundle.relations[relName];
  }

  /** Plangs this Bundle is for. `(this:VBundle)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relBundles}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelPlangs);
  }

  /** Tools in this. `(this:VBundle)-[relTools]->VTool`. Inverse: {@link VTool.relBundles}. */
  get relTools() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelTools);
  }
}

/** Type of the key of an instance of {@link VCommunity}. */
export type VCommunityKey = `comm+${string}`;

/** Relationship available on an instance of {@link VCommunity}. */
export type VCommunityRel = "relLearning" | "relPlangs" | "relTags";

/** Community */
export abstract class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly kind = "comm";
  static readonly vertexName = "community";
  static readonly desc = "Community";

  override readonly kind = VCommunityBase.kind;
  override readonly desc = VCommunityBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VCommunity): { vertexName: TPlangsVertexName; propName: keyof VCommunity } {
    return { vertexName: VCommunity.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VCommunityRel) {
    return PLANGS_GRAPH_CONFIG.community.relations[relName];
  }

  /** Learning resources. `VLearning-[relCommunities]->(this:VCommunity)`. Inverse: {@link VLearning.relCommunities}. */
  get relLearning() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.learningRelCommunities);
  }

  /** Plangs supported. `(this:VCommunity)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relCommunities}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelPlangs);
  }

  /** Tags. `VTag-[relCommunities]->(this:VCommunity)`. Inverse: {@link VTag.relCommunities}. */
  get relTags() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.tagRelCommunities);
  }
}

/** Type of the key of an instance of {@link VLearning}. */
export type VLearningKey = `learn+${string}`;

/** Relationship available on an instance of {@link VLearning}. */
export type VLearningRel = "relCommunities" | "relPlangs" | "relTags";

/** Learning Resource */
export abstract class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly kind = "learn";
  static readonly vertexName = "learning";
  static readonly desc = "Learning Resource";

  override readonly kind = VLearningBase.kind;
  override readonly desc = VLearningBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VLearning): { vertexName: TPlangsVertexName; propName: keyof VLearning } {
    return { vertexName: VLearning.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VLearningRel) {
    return PLANGS_GRAPH_CONFIG.learning.relations[relName];
  }

  /** Communities supporting this. `(this:VLearning)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relLearning}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelCommunities);
  }

  /** Plangs covered. `(this:VLearning)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLearning}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelPlangs);
  }

  /** Tags. `VTag-[relLearning]->(this:VLearning)`. Inverse: {@link VTag.relLearning}. */
  get relTags() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.tagRelLearning);
  }
}

/** Type of the key of an instance of {@link VLibrary}. */
export type VLibraryKey = `lib+${string}`;

/** Relationship available on an instance of {@link VLibrary}. */
export type VLibraryRel = "relLicenses" | "relPlangs" | "relPlatforms" | "relTags" | "relWrittenWith";

/** Software Library */
export abstract class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly kind = "lib";
  static readonly vertexName = "library";
  static readonly desc = "Software Library";

  override readonly kind = VLibraryBase.kind;
  override readonly desc = VLibraryBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VLibrary): { vertexName: TPlangsVertexName; propName: keyof VLibrary } {
    return { vertexName: VLibrary.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VLibraryRel) {
    return PLANGS_GRAPH_CONFIG.library.relations[relName];
  }

  /** Licenses. `VLicense-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLicense.relLibraries}. */
  get relLicenses() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs supported. `(this:VLibrary)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLibraries}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlangs);
  }

  /** Platforms supported. `(this:VLibrary)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relLibraries}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlatforms);
  }

  /** Tags. `VTag-[relLibraries]->(this:VLibrary)`. Inverse: {@link VTag.relLibraries}. */
  get relTags() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.tagRelLibraries);
  }

  /** Plangs used. `(this:VLibrary)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedInLibrary}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VLicense}. */
export type VLicenseKey = `lic+${string}`;

/** Relationship available on an instance of {@link VLicense}. */
export type VLicenseRel = "relApps" | "relLibraries" | "relPlangs" | "relTools";

/** Software License */
export abstract class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly kind = "lic";
  static readonly vertexName = "license";
  static readonly desc = "Software License";

  override readonly kind = VLicenseBase.kind;
  override readonly desc = VLicenseBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VLicense): { vertexName: TPlangsVertexName; propName: keyof VLicense } {
    return { vertexName: VLicense.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VLicenseRel) {
    return PLANGS_GRAPH_CONFIG.license.relations[relName];
  }

  /** Apps using this. `(this:VLicense)-[relApps]->VApp`. Inverse: {@link VApp.relLicenses}. */
  get relApps() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelApps);
  }

  /** Libraries using this. `(this:VLicense)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLicenses}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs using this. `(this:VLicense)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLicenses}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelPlangs);
  }

  /** Tools using this. `(this:VLicense)-[relTools]->VTool`. Inverse: {@link VTool.relLicenses}. */
  get relTools() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelTools);
  }
}

/** Type of the key of an instance of {@link VParadigm}. */
export type VParadigmKey = `para+${string}`;

/** Relationship available on an instance of {@link VParadigm}. */
export type VParadigmRel = "relPlangs";

/** Programming Language Paradigm */
export abstract class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly kind = "para";
  static readonly vertexName = "paradigm";
  static readonly desc = "Programming Language Paradigm";

  override readonly kind = VParadigmBase.kind;
  override readonly desc = VParadigmBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VParadigm): { vertexName: TPlangsVertexName; propName: keyof VParadigm } {
    return { vertexName: VParadigm.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VParadigmRel) {
    return PLANGS_GRAPH_CONFIG.paradigm.relations[relName];
  }

  /** Plangs implementing this. `VPlang-[relParadigms]->(this:VParadigm)`. Inverse: {@link VPlang.relParadigms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VParadigm, this.graph.edges.plangRelParadigms);
  }
}

/** Type of the key of an instance of {@link VPlang}. */
export type VPlangKey = `pl+${string}`;

/** Relationship available on an instance of {@link VPlang}. */
export type VPlangRel =
  | "relApps"
  | "relBundles"
  | "relCommunities"
  | "relCompilesTo"
  | "relDialectOf"
  | "relDialects"
  | "relImplementedBy"
  | "relImplements"
  | "relInfluenced"
  | "relInfluencedBy"
  | "relLearning"
  | "relLibraries"
  | "relLicenses"
  | "relParadigms"
  | "relPlatforms"
  | "relPosts"
  | "relTags"
  | "relTargetOf"
  | "relTools"
  | "relToolsUsing"
  | "relTypeSystems"
  | "relUsedInLibrary"
  | "relUsedToWrite"
  | "relWrittenWith";

/** Programming Language */
export abstract class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly kind = "pl";
  static readonly vertexName = "plang";
  static readonly desc = "Programming Language";

  override readonly kind = VPlangBase.kind;
  override readonly desc = VPlangBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VPlang): { vertexName: TPlangsVertexName; propName: keyof VPlang } {
    return { vertexName: VPlang.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VPlangRel) {
    return PLANGS_GRAPH_CONFIG.plang.relations[relName];
  }

  /** Apps implemented with this. `VApp-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VApp.relWrittenWith}. */
  get relApps() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.appRelWrittenWith);
  }

  /** Bundles of Tools for this. `VBundle-[relPlangs]->(this:VPlang)`. Inverse: {@link VBundle.relPlangs}. */
  get relBundles() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.bundleRelPlangs);
  }

  /** Communities suporting this. `VCommunity-[relPlangs]->(this:VPlang)`. Inverse: {@link VCommunity.relPlangs}. */
  get relCommunities() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.communityRelPlangs);
  }

  /** Transpiling targets. `(this:VPlang)-[relCompilesTo]->VPlang`. Inverse: {@link VPlang.relTargetOf}. */
  get relCompilesTo() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Plangs this is a Dialect of. `(this:VPlang)-[relDialectOf]->VPlang`. Inverse: {@link VPlang.relDialects}. */
  get relDialectOf() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Dialects. `VPlang-[relDialectOf]->(this:VPlang)`. Inverse: {@link VPlang.relDialectOf}. */
  get relDialects() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Plangs implementing this. `VPlang-[relImplements]->(this:VPlang)`. Inverse: {@link VPlang.relImplements}. */
  get relImplementedBy() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs this Implements. `(this:VPlang)-[relImplements]->VPlang`. Inverse: {@link VPlang.relImplementedBy}. */
  get relImplements() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs this influenced. `VPlang-[relInfluencedBy]->(this:VPlang)`. Inverse: {@link VPlang.relInfluencedBy}. */
  get relInfluenced() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Plangs that influenced this. `(this:VPlang)-[relInfluencedBy]->VPlang`. Inverse: {@link VPlang.relInfluenced}. */
  get relInfluencedBy() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Learning resources. `VLearning-[relPlangs]->(this:VPlang)`. Inverse: {@link VLearning.relPlangs}. */
  get relLearning() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.learningRelPlangs);
  }

  /** Software Libraries. `VLibrary-[relPlangs]->(this:VPlang)`. Inverse: {@link VLibrary.relPlangs}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelPlangs);
  }

  /** Licenses. `VLicense-[relPlangs]->(this:VPlang)`. Inverse: {@link VLicense.relPlangs}. */
  get relLicenses() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.licenseRelPlangs);
  }

  /** Paradigms implemented. `(this:VPlang)-[relParadigms]->VParadigm`. Inverse: {@link VParadigm.relPlangs}. */
  get relParadigms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelParadigms);
  }

  /** Platforms supported. `(this:VPlang)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relPlangs}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelPlatforms);
  }

  /** Posts talking about this. `VPost-[relPlangs]->(this:VPlang)`. Inverse: {@link VPost.relPlangs}. */
  get relPosts() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.postRelPlangs);
  }

  /** Tags. `VTag-[relPlangs]->(this:VPlang)`. Inverse: {@link VTag.relPlangs}. */
  get relTags() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.tagRelPlangs);
  }

  /** Plangs compiling to this. `VPlang-[relCompilesTo]->(this:VPlang)`. Inverse: {@link VPlang.relCompilesTo}. */
  get relTargetOf() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Tools for this. `(this:VPlang)-[relTools]->VTool`. Inverse: {@link VTool.relPlangs}. */
  get relTools() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTools);
  }

  /** Tools implemented with this. `VTool-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VTool.relWrittenWith}. */
  get relToolsUsing() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.toolRelWrittenWith);
  }

  /** Type Systems implemented. `(this:VPlang)-[relTypeSystems]->VTypeSystem`. Inverse: {@link VTypeSystem.relPlangs}. */
  get relTypeSystems() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTypeSystems);
  }

  /** Libraries made with this. `VLibrary-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VLibrary.relWrittenWith}. */
  get relUsedInLibrary() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelWrittenWith);
  }

  /** Plangs implemented with this. `VPlang-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VPlang.relWrittenWith}. */
  get relUsedToWrite() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Plangs used to implement this. `(this:VPlang)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedToWrite}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VPlatform}. */
export type VPlatformKey = `plat+${string}`;

/** Relationship available on an instance of {@link VPlatform}. */
export type VPlatformRel = "relApps" | "relLibraries" | "relPlangs" | "relTools";

/** Platform where Software runs */
export abstract class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly kind = "plat";
  static readonly vertexName = "platform";
  static readonly desc = "Platform where Software runs";

  override readonly kind = VPlatformBase.kind;
  override readonly desc = VPlatformBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VPlatform): { vertexName: TPlangsVertexName; propName: keyof VPlatform } {
    return { vertexName: VPlatform.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VPlatformRel) {
    return PLANGS_GRAPH_CONFIG.platform.relations[relName];
  }

  /** Apps supporting this. `VApp-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VApp.relPlatforms}. */
  get relApps() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.appRelPlatforms);
  }

  /** Libraries supporting this. `VLibrary-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VLibrary.relPlatforms}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.libraryRelPlatforms);
  }

  /** Plangs supporting this. `VPlang-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VPlang.relPlatforms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.plangRelPlatforms);
  }

  /** Tools supporting this. `VTool-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VTool.relPlatforms}. */
  get relTools() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.toolRelPlatforms);
  }
}

/** Type of the key of an instance of {@link VPost}. */
export type VPostKey = `post+${string}`;

/** Relationship available on an instance of {@link VPost}. */
export type VPostRel = "relPlangs";

/** Blog Post */
export abstract class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly kind = "post";
  static readonly vertexName = "post";
  static readonly desc = "Blog Post";

  override readonly kind = VPostBase.kind;
  override readonly desc = VPostBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VPost): { vertexName: TPlangsVertexName; propName: keyof VPost } {
    return { vertexName: VPost.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VPostRel) {
    return PLANGS_GRAPH_CONFIG.post.relations[relName];
  }

  /** Plangs covered. `(this:VPost)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relPosts}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelPlangs);
  }
}

/** Type of the key of an instance of {@link VTag}. */
export type VTagKey = `tag+${string}`;

/** Relationship available on an instance of {@link VTag}. */
export type VTagRel = "relApps" | "relCommunities" | "relLearning" | "relLibraries" | "relPlangs" | "relTools";

/** Tag */
export abstract class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly kind = "tag";
  static readonly vertexName = "tag";
  static readonly desc = "Tag";

  override readonly kind = VTagBase.kind;
  override readonly desc = VTagBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VTag): { vertexName: TPlangsVertexName; propName: keyof VTag } {
    return { vertexName: VTag.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VTagRel) {
    return PLANGS_GRAPH_CONFIG.tag.relations[relName];
  }

  /** Apps tagged. `(this:VTag)-[relApps]->VApp`. Inverse: {@link VApp.relTags}. */
  get relApps() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelApps);
  }

  /** Communities tagged. `(this:VTag)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relTags}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelCommunities);
  }

  /** Learning resources tagged. `(this:VTag)-[relLearning]->VLearning`. Inverse: {@link VLearning.relTags}. */
  get relLearning() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLearning);
  }

  /** Libraries tagged. `(this:VTag)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relTags}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLibraries);
  }

  /** Plangs tagged. `(this:VTag)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relTags}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelPlangs);
  }

  /** Tools tagged. `(this:VTag)-[relTools]->VTool`. Inverse: {@link VTool.relTags}. */
  get relTools() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelTools);
  }
}

/** Type of the key of an instance of {@link VTool}. */
export type VToolKey = `tool+${string}`;

/** Relationship available on an instance of {@link VTool}. */
export type VToolRel = "relBundles" | "relLicenses" | "relPlangs" | "relPlatforms" | "relTags" | "relWrittenWith";

/** Programming Tool */
export abstract class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly kind = "tool";
  static readonly vertexName = "tool";
  static readonly desc = "Programming Tool";

  override readonly kind = VToolBase.kind;
  override readonly desc = VToolBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VTool): { vertexName: TPlangsVertexName; propName: keyof VTool } {
    return { vertexName: VTool.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VToolRel) {
    return PLANGS_GRAPH_CONFIG.tool.relations[relName];
  }

  /** Bundles including this. `VBundle-[relTools]->(this:VTool)`. Inverse: {@link VBundle.relTools}. */
  get relBundles() {
    return new RelTo(this as unknown as VTool, this.graph.edges.bundleRelTools);
  }

  /** Licenses. `VLicense-[relTools]->(this:VTool)`. Inverse: {@link VLicense.relTools}. */
  get relLicenses() {
    return new RelTo(this as unknown as VTool, this.graph.edges.licenseRelTools);
  }

  /** Plangs supported. `VPlang-[relTools]->(this:VTool)`. Inverse: {@link VPlang.relTools}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTool, this.graph.edges.plangRelTools);
  }

  /** Platforms supported. `(this:VTool)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relTools}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelPlatforms);
  }

  /** Tags. `VTag-[relTools]->(this:VTool)`. Inverse: {@link VTag.relTools}. */
  get relTags() {
    return new RelTo(this as unknown as VTool, this.graph.edges.tagRelTools);
  }

  /** Plangs used to implement this. `(this:VTool)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relToolsUsing}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VTypeSystem}. */
export type VTypeSystemKey = `tsys+${string}`;

/** Relationship available on an instance of {@link VTypeSystem}. */
export type VTypeSystemRel = "relPlangs";

/** Type System */
export abstract class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly kind = "tsys";
  static readonly vertexName = "typeSystem";
  static readonly desc = "Type System";

  override readonly kind = VTypeSystemBase.kind;
  override readonly desc = VTypeSystemBase.desc;

  /** Return a configuration object for a property of this vertex. */
  static propConf(propName: keyof VTypeSystem): { vertexName: TPlangsVertexName; propName: keyof VTypeSystem } {
    return { vertexName: VTypeSystem.vertexName, propName };
  }

  /** Return a configuration object for a relation of this vertex. */
  static relConf(relName: VTypeSystemRel) {
    return PLANGS_GRAPH_CONFIG.typeSystem.relations[relName];
  }

  /** Plangs implementing this. `VPlang-[relTypeSystems]->(this:VTypeSystem)`. Inverse: {@link VPlang.relTypeSystems}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTypeSystem, this.graph.edges.plangRelTypeSystems);
  }
}
