/**  Do not modify manually! Generated by graphgen on 2024-12-01T06:29:10.726Z. */

import { Edges, type ReadableProps, RelFrom, RelTo, type SerializedGraph, Vertices } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

export type TPlangsVertexName =
  | "app"
  | "bundle"
  | "community"
  | "learning"
  | "library"
  | "license"
  | "paradigm"
  | "plang"
  | "platform"
  | "post"
  | "tag"
  | "tool"
  | "typeSystem";

/** Supported relations of each class. */
export type PlangsRelations = {
  app: "relLicenses" | "relPlatforms" | "relTags" | "relWrittenWith";
  bundle: "relPlangs" | "relTools";
  community: "relLearning" | "relPlangs" | "relTags";
  learning: "relCommunities" | "relPlangs" | "relTags";
  library: "relLicenses" | "relPlangs" | "relPlatforms" | "relTags" | "relWrittenWith";
  license: "relApps" | "relLibraries" | "relPlangs" | "relTools";
  paradigm: "relPlangs";
  plang:
    | "relApps"
    | "relBundles"
    | "relCommunities"
    | "relCompilesTo"
    | "relDialectOf"
    | "relDialects"
    | "relImplementedBy"
    | "relImplements"
    | "relInfluenced"
    | "relInfluencedBy"
    | "relLearning"
    | "relLibraries"
    | "relLicenses"
    | "relParadigms"
    | "relPlatforms"
    | "relPosts"
    | "relTags"
    | "relTargetOf"
    | "relTools"
    | "relToolsUsing"
    | "relTypeSystems"
    | "relUsedInLibrary"
    | "relUsedToWrite"
    | "relWrittenWith";
  platform: "relApps" | "relLibraries" | "relPlangs" | "relTools";
  post: "relPlangs";
  tag: "relApps" | "relCommunities" | "relLearning" | "relLibraries" | "relPlangs" | "relTools";
  tool: "relBundles" | "relLicenses" | "relPlangs" | "relPlatforms" | "relTags" | "relWrittenWith";
  typeSystem: "relPlangs";
};

/** Vertex classes for each Vertex name. */
export type PlangsVClasses = {
  app: VApp;
  bundle: VBundle;
  community: VCommunity;
  learning: VLearning;
  library: VLibrary;
  license: VLicense;
  paradigm: VParadigm;
  plang: VPlang;
  platform: VPlatform;
  post: VPost;
  tag: VTag;
  tool: VTool;
  typeSystem: VTypeSystem;
};

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  /** Return a type checked object identifying a relationship of a specific kind of Vertex. */
  static relConfig = <T extends TPlangsVertexName>(vertexName: T, vertexRel: PlangsRelations[T]) => ({ kind: "rel", vertexName, vertexRel });

  /** Return a type checked object identifying a property of the class that is "readable" (a prop returning a String, Boolean or Nunber). */
  static propConfig = <T extends TPlangsVertexName>(vertexName: T, vertexProp: ReadableProps<PlangsVClasses[T]>) => ({
    kind: "prop",
    vertexName,
    vertexProp,
  });

  /** All Vertex classes. */
  readonly vertexClasses = {
    app: VApp,
    bundle: VBundle,
    community: VCommunity,
    learning: VLearning,
    library: VLibrary,
    license: VLicense,
    paradigm: VParadigm,
    plang: VPlang,
    platform: VPlatform,
    post: VPost,
    tag: VTag,
    tool: VTool,
    typeSystem: VTypeSystem,
  } as const;

  // Create a Vertices instances for each vertex.

  readonly app = new Vertices<VApp>(key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>(key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>(key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>(key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>(key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>(key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>(key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>(key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>(key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>(key => new VPost(this, key));
  readonly tag = new Vertices<VTag>(key => new VTag(this, key));
  readonly tool = new Vertices<VTool>(key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>(key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly vertices = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    appRelPlatforms: new Edges(this.app, this.platform, "Platforms supported", "Apps supporting this"),
    appRelWrittenWith: new Edges(this.app, this.plang, "Plangs used to implement this", "Apps implemented with this"),
    bundleRelPlangs: new Edges(this.bundle, this.plang, "Plangs this Bundle is for", "Bundles of Tools for this"),
    bundleRelTools: new Edges(this.bundle, this.tool, "Tools in this", "Bundles including this"),
    communityRelPlangs: new Edges(this.community, this.plang, "Plangs supported", "Communities suporting this"),
    learningRelCommunities: new Edges(this.learning, this.community, "Communities supporting this", "Learning resources"),
    learningRelPlangs: new Edges(this.learning, this.plang, "Plangs covered", "Learning resources"),
    libraryRelPlangs: new Edges(this.library, this.plang, "Plangs supported", "Software Libraries"),
    libraryRelPlatforms: new Edges(this.library, this.platform, "Platforms supported", "Libraries supporting this"),
    libraryRelWrittenWith: new Edges(this.library, this.plang, "Plangs used", "Libraries made with this"),
    licenseRelApps: new Edges(this.license, this.app, "Apps using this", "Licenses"),
    licenseRelLibraries: new Edges(this.license, this.library, "Libraries using this", "Licenses"),
    licenseRelPlangs: new Edges(this.license, this.plang, "Plangs using this", "Licenses"),
    licenseRelTools: new Edges(this.license, this.tool, "Tools using this", "Licenses"),
    plangRelCompilesTo: new Edges(this.plang, this.plang, "Transpiling targets", "Plangs compiling to this"),
    plangRelDialectOf: new Edges(this.plang, this.plang, "Plangs this is a Dialect of", "Dialects"),
    plangRelImplements: new Edges(this.plang, this.plang, "Plangs this Implements", "Plangs implementing this"),
    plangRelInfluencedBy: new Edges(this.plang, this.plang, "Plangs that influenced this", "Plangs this influenced"),
    plangRelParadigms: new Edges(this.plang, this.paradigm, "Paradigms implemented", "Plangs implementing this"),
    plangRelPlatforms: new Edges(this.plang, this.platform, "Platforms supported", "Plangs supporting this"),
    plangRelTools: new Edges(this.plang, this.tool, "Tools for this", "Plangs supported"),
    plangRelTypeSystems: new Edges(this.plang, this.typeSystem, "Type Systems implemented", "Plangs implementing this"),
    plangRelWrittenWith: new Edges(this.plang, this.plang, "Plangs used to implement this", "Plangs implemented with this"),
    postRelPlangs: new Edges(this.post, this.plang, "Plangs covered", "Posts talking about this"),
    tagRelApps: new Edges(this.tag, this.app, "Apps tagged", "Tags"),
    tagRelCommunities: new Edges(this.tag, this.community, "Communities tagged", "Tags"),
    tagRelLearning: new Edges(this.tag, this.learning, "Learning resources tagged", "Tags"),
    tagRelLibraries: new Edges(this.tag, this.library, "Libraries tagged", "Tags"),
    tagRelPlangs: new Edges(this.tag, this.plang, "Plangs tagged", "Tags"),
    tagRelTools: new Edges(this.tag, this.tool, "Tools tagged", "Tags"),
    toolRelPlatforms: new Edges(this.tool, this.platform, "Platforms supported", "Tools supporting this"),
    toolRelWrittenWith: new Edges(this.tool, this.plang, "Plangs used to implement this", "Tools implemented with this"),
  } as const;

  toJSON(): SerializedGraph {
    return {
      vertices: Object.fromEntries(Object.entries(this.vertices).map(([k, v]) => [k, v.toJSON()])),
      edges: Object.fromEntries(Object.entries(this.edges).map(([k, e]) => [k, e.toJSON()])),
    };
  }

  loadJSON(data: SerializedGraph) {
    for (const [vertexName, vertices] of Object.entries(data.vertices)) {
      const map = this.vertices[vertexName as TPlangsVertexName];
      for (const [vertexKey, vertexData] of Object.entries(vertices)) {
        map.set(vertexKey as any, vertexData as any);
      }
    }
    for (const [edgeName, edges] of Object.entries(data.edges)) {
      const map = this.edges[edgeName as keyof typeof this.edges];
      for (const [fromKey, toKeys] of Object.entries(edges)) {
        map.add(fromKey as any, ...(toKeys as any[]));
      }
    }
  }
}

/** Type of the key of an instance of {@link VApp}. */
export type VAppKey = `app+${string}`;

/** Software Application */
export abstract class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly keyPrefix = "app";
  static readonly vertexName = "app";
  static readonly vertexDesc = "Software Application";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relLicenses: { edgeName: "licenseRelApps", direction: "inverse" },
    relPlatforms: { edgeName: "appRelPlatforms", direction: "direct" },
    relTags: { edgeName: "tagRelApps", direction: "inverse" },
    relWrittenWith: { edgeName: "appRelWrittenWith", direction: "direct" },
  } as const;

  readonly vertexDesc = VAppBase.vertexDesc;

  /** Licenses `VLicense-[relApps]->(this:VApp)`. Inverse: {@link VLicense.relApps}. */
  get relLicenses() {
    return new RelTo(this as unknown as VApp, this.graph.edges.licenseRelApps);
  }

  /** Platforms supported `(this:VApp)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relApps}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelPlatforms);
  }

  /** Tags `VTag-[relApps]->(this:VApp)`. Inverse: {@link VTag.relApps}. */
  get relTags() {
    return new RelTo(this as unknown as VApp, this.graph.edges.tagRelApps);
  }

  /** Plangs used to implement this `(this:VApp)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relApps}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VBundle}. */
export type VBundleKey = `bun+${string}`;

/** Bundle of Tools */
export abstract class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly keyPrefix = "bun";
  static readonly vertexName = "bundle";
  static readonly vertexDesc = "Bundle of Tools";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relPlangs: { edgeName: "bundleRelPlangs", direction: "direct" },
    relTools: { edgeName: "bundleRelTools", direction: "direct" },
  } as const;

  readonly vertexDesc = VBundleBase.vertexDesc;

  /** Plangs this Bundle is for `(this:VBundle)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relBundles}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelPlangs);
  }

  /** Tools in this `(this:VBundle)-[relTools]->VTool`. Inverse: {@link VTool.relBundles}. */
  get relTools() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelTools);
  }
}

/** Type of the key of an instance of {@link VCommunity}. */
export type VCommunityKey = `comm+${string}`;

/** Community */
export abstract class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly keyPrefix = "comm";
  static readonly vertexName = "community";
  static readonly vertexDesc = "Community";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relLearning: { edgeName: "learningRelCommunities", direction: "inverse" },
    relPlangs: { edgeName: "communityRelPlangs", direction: "direct" },
    relTags: { edgeName: "tagRelCommunities", direction: "inverse" },
  } as const;

  readonly vertexDesc = VCommunityBase.vertexDesc;

  /** Learning resources `VLearning-[relCommunities]->(this:VCommunity)`. Inverse: {@link VLearning.relCommunities}. */
  get relLearning() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.learningRelCommunities);
  }

  /** Plangs supported `(this:VCommunity)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relCommunities}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelPlangs);
  }

  /** Tags `VTag-[relCommunities]->(this:VCommunity)`. Inverse: {@link VTag.relCommunities}. */
  get relTags() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.tagRelCommunities);
  }
}

/** Type of the key of an instance of {@link VLearning}. */
export type VLearningKey = `learn+${string}`;

/** Learning Resource */
export abstract class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly keyPrefix = "learn";
  static readonly vertexName = "learning";
  static readonly vertexDesc = "Learning Resource";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relCommunities: { edgeName: "learningRelCommunities", direction: "direct" },
    relPlangs: { edgeName: "learningRelPlangs", direction: "direct" },
    relTags: { edgeName: "tagRelLearning", direction: "inverse" },
  } as const;

  readonly vertexDesc = VLearningBase.vertexDesc;

  /** Communities supporting this `(this:VLearning)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relLearning}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelCommunities);
  }

  /** Plangs covered `(this:VLearning)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLearning}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelPlangs);
  }

  /** Tags `VTag-[relLearning]->(this:VLearning)`. Inverse: {@link VTag.relLearning}. */
  get relTags() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.tagRelLearning);
  }
}

/** Type of the key of an instance of {@link VLibrary}. */
export type VLibraryKey = `lib+${string}`;

/** Software Library */
export abstract class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly keyPrefix = "lib";
  static readonly vertexName = "library";
  static readonly vertexDesc = "Software Library";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relLicenses: { edgeName: "licenseRelLibraries", direction: "inverse" },
    relPlangs: { edgeName: "libraryRelPlangs", direction: "direct" },
    relPlatforms: { edgeName: "libraryRelPlatforms", direction: "direct" },
    relTags: { edgeName: "tagRelLibraries", direction: "inverse" },
    relWrittenWith: { edgeName: "libraryRelWrittenWith", direction: "direct" },
  } as const;

  readonly vertexDesc = VLibraryBase.vertexDesc;

  /** Licenses `VLicense-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLicense.relLibraries}. */
  get relLicenses() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs supported `(this:VLibrary)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLibraries}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlangs);
  }

  /** Platforms supported `(this:VLibrary)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relLibraries}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlatforms);
  }

  /** Tags `VTag-[relLibraries]->(this:VLibrary)`. Inverse: {@link VTag.relLibraries}. */
  get relTags() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.tagRelLibraries);
  }

  /** Plangs used `(this:VLibrary)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedInLibrary}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VLicense}. */
export type VLicenseKey = `lic+${string}`;

/** Software License */
export abstract class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly keyPrefix = "lic";
  static readonly vertexName = "license";
  static readonly vertexDesc = "Software License";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relApps: { edgeName: "licenseRelApps", direction: "direct" },
    relLibraries: { edgeName: "licenseRelLibraries", direction: "direct" },
    relPlangs: { edgeName: "licenseRelPlangs", direction: "direct" },
    relTools: { edgeName: "licenseRelTools", direction: "direct" },
  } as const;

  readonly vertexDesc = VLicenseBase.vertexDesc;

  /** Apps using this `(this:VLicense)-[relApps]->VApp`. Inverse: {@link VApp.relLicenses}. */
  get relApps() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelApps);
  }

  /** Libraries using this `(this:VLicense)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLicenses}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs using this `(this:VLicense)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLicenses}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelPlangs);
  }

  /** Tools using this `(this:VLicense)-[relTools]->VTool`. Inverse: {@link VTool.relLicenses}. */
  get relTools() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelTools);
  }
}

/** Type of the key of an instance of {@link VParadigm}. */
export type VParadigmKey = `para+${string}`;

/** Programming Language Paradigm */
export abstract class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly keyPrefix = "para";
  static readonly vertexName = "paradigm";
  static readonly vertexDesc = "Programming Language Paradigm";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = { relPlangs: { edgeName: "plangRelParadigms", direction: "inverse" } } as const;

  readonly vertexDesc = VParadigmBase.vertexDesc;

  /** Plangs implementing this `VPlang-[relParadigms]->(this:VParadigm)`. Inverse: {@link VPlang.relParadigms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VParadigm, this.graph.edges.plangRelParadigms);
  }
}

/** Type of the key of an instance of {@link VPlang}. */
export type VPlangKey = `pl+${string}`;

/** Programming Language */
export abstract class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly keyPrefix = "pl";
  static readonly vertexName = "plang";
  static readonly vertexDesc = "Programming Language";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relApps: { edgeName: "appRelWrittenWith", direction: "inverse" },
    relBundles: { edgeName: "bundleRelPlangs", direction: "inverse" },
    relCommunities: { edgeName: "communityRelPlangs", direction: "inverse" },
    relCompilesTo: { edgeName: "plangRelCompilesTo", direction: "direct" },
    relDialectOf: { edgeName: "plangRelDialectOf", direction: "direct" },
    relDialects: { edgeName: "plangRelDialectOf", direction: "inverse" },
    relImplementedBy: { edgeName: "plangRelImplements", direction: "inverse" },
    relImplements: { edgeName: "plangRelImplements", direction: "direct" },
    relInfluenced: { edgeName: "plangRelInfluencedBy", direction: "inverse" },
    relInfluencedBy: { edgeName: "plangRelInfluencedBy", direction: "direct" },
    relLearning: { edgeName: "learningRelPlangs", direction: "inverse" },
    relLibraries: { edgeName: "libraryRelPlangs", direction: "inverse" },
    relLicenses: { edgeName: "licenseRelPlangs", direction: "inverse" },
    relParadigms: { edgeName: "plangRelParadigms", direction: "direct" },
    relPlatforms: { edgeName: "plangRelPlatforms", direction: "direct" },
    relPosts: { edgeName: "postRelPlangs", direction: "inverse" },
    relTags: { edgeName: "tagRelPlangs", direction: "inverse" },
    relTargetOf: { edgeName: "plangRelCompilesTo", direction: "inverse" },
    relTools: { edgeName: "plangRelTools", direction: "direct" },
    relToolsUsing: { edgeName: "toolRelWrittenWith", direction: "inverse" },
    relTypeSystems: { edgeName: "plangRelTypeSystems", direction: "direct" },
    relUsedInLibrary: { edgeName: "libraryRelWrittenWith", direction: "inverse" },
    relUsedToWrite: { edgeName: "plangRelWrittenWith", direction: "inverse" },
    relWrittenWith: { edgeName: "plangRelWrittenWith", direction: "direct" },
  } as const;

  readonly vertexDesc = VPlangBase.vertexDesc;

  /** Apps implemented with this `VApp-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VApp.relWrittenWith}. */
  get relApps() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.appRelWrittenWith);
  }

  /** Bundles of Tools for this `VBundle-[relPlangs]->(this:VPlang)`. Inverse: {@link VBundle.relPlangs}. */
  get relBundles() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.bundleRelPlangs);
  }

  /** Communities suporting this `VCommunity-[relPlangs]->(this:VPlang)`. Inverse: {@link VCommunity.relPlangs}. */
  get relCommunities() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.communityRelPlangs);
  }

  /** Transpiling targets `(this:VPlang)-[relCompilesTo]->VPlang`. Inverse: {@link VPlang.relTargetOf}. */
  get relCompilesTo() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Plangs this is a Dialect of `(this:VPlang)-[relDialectOf]->VPlang`. Inverse: {@link VPlang.relDialects}. */
  get relDialectOf() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Dialects `VPlang-[relDialectOf]->(this:VPlang)`. Inverse: {@link VPlang.relDialectOf}. */
  get relDialects() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Plangs implementing this `VPlang-[relImplements]->(this:VPlang)`. Inverse: {@link VPlang.relImplements}. */
  get relImplementedBy() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs this Implements `(this:VPlang)-[relImplements]->VPlang`. Inverse: {@link VPlang.relImplementedBy}. */
  get relImplements() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs this influenced `VPlang-[relInfluencedBy]->(this:VPlang)`. Inverse: {@link VPlang.relInfluencedBy}. */
  get relInfluenced() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Plangs that influenced this `(this:VPlang)-[relInfluencedBy]->VPlang`. Inverse: {@link VPlang.relInfluenced}. */
  get relInfluencedBy() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Learning resources `VLearning-[relPlangs]->(this:VPlang)`. Inverse: {@link VLearning.relPlangs}. */
  get relLearning() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.learningRelPlangs);
  }

  /** Software Libraries `VLibrary-[relPlangs]->(this:VPlang)`. Inverse: {@link VLibrary.relPlangs}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelPlangs);
  }

  /** Licenses `VLicense-[relPlangs]->(this:VPlang)`. Inverse: {@link VLicense.relPlangs}. */
  get relLicenses() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.licenseRelPlangs);
  }

  /** Paradigms implemented `(this:VPlang)-[relParadigms]->VParadigm`. Inverse: {@link VParadigm.relPlangs}. */
  get relParadigms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelParadigms);
  }

  /** Platforms supported `(this:VPlang)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relPlangs}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelPlatforms);
  }

  /** Posts talking about this `VPost-[relPlangs]->(this:VPlang)`. Inverse: {@link VPost.relPlangs}. */
  get relPosts() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.postRelPlangs);
  }

  /** Tags `VTag-[relPlangs]->(this:VPlang)`. Inverse: {@link VTag.relPlangs}. */
  get relTags() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.tagRelPlangs);
  }

  /** Plangs compiling to this `VPlang-[relCompilesTo]->(this:VPlang)`. Inverse: {@link VPlang.relCompilesTo}. */
  get relTargetOf() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Tools for this `(this:VPlang)-[relTools]->VTool`. Inverse: {@link VTool.relPlangs}. */
  get relTools() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTools);
  }

  /** Tools implemented with this `VTool-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VTool.relWrittenWith}. */
  get relToolsUsing() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.toolRelWrittenWith);
  }

  /** Type Systems implemented `(this:VPlang)-[relTypeSystems]->VTypeSystem`. Inverse: {@link VTypeSystem.relPlangs}. */
  get relTypeSystems() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTypeSystems);
  }

  /** Libraries made with this `VLibrary-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VLibrary.relWrittenWith}. */
  get relUsedInLibrary() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelWrittenWith);
  }

  /** Plangs implemented with this `VPlang-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VPlang.relWrittenWith}. */
  get relUsedToWrite() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Plangs used to implement this `(this:VPlang)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedToWrite}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VPlatform}. */
export type VPlatformKey = `plat+${string}`;

/** Platform where Software runs */
export abstract class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly keyPrefix = "plat";
  static readonly vertexName = "platform";
  static readonly vertexDesc = "Platform where Software runs";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relApps: { edgeName: "appRelPlatforms", direction: "inverse" },
    relLibraries: { edgeName: "libraryRelPlatforms", direction: "inverse" },
    relPlangs: { edgeName: "plangRelPlatforms", direction: "inverse" },
    relTools: { edgeName: "toolRelPlatforms", direction: "inverse" },
  } as const;

  readonly vertexDesc = VPlatformBase.vertexDesc;

  /** Apps supporting this `VApp-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VApp.relPlatforms}. */
  get relApps() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.appRelPlatforms);
  }

  /** Libraries supporting this `VLibrary-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VLibrary.relPlatforms}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.libraryRelPlatforms);
  }

  /** Plangs supporting this `VPlang-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VPlang.relPlatforms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.plangRelPlatforms);
  }

  /** Tools supporting this `VTool-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VTool.relPlatforms}. */
  get relTools() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.toolRelPlatforms);
  }
}

/** Type of the key of an instance of {@link VPost}. */
export type VPostKey = `post+${string}`;

/** Blog Post */
export abstract class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly keyPrefix = "post";
  static readonly vertexName = "post";
  static readonly vertexDesc = "Blog Post";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = { relPlangs: { edgeName: "postRelPlangs", direction: "direct" } } as const;

  readonly vertexDesc = VPostBase.vertexDesc;

  /** Plangs covered `(this:VPost)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relPosts}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelPlangs);
  }
}

/** Type of the key of an instance of {@link VTag}. */
export type VTagKey = `tag+${string}`;

/** Tag */
export abstract class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly keyPrefix = "tag";
  static readonly vertexName = "tag";
  static readonly vertexDesc = "Tag";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relApps: { edgeName: "tagRelApps", direction: "direct" },
    relCommunities: { edgeName: "tagRelCommunities", direction: "direct" },
    relLearning: { edgeName: "tagRelLearning", direction: "direct" },
    relLibraries: { edgeName: "tagRelLibraries", direction: "direct" },
    relPlangs: { edgeName: "tagRelPlangs", direction: "direct" },
    relTools: { edgeName: "tagRelTools", direction: "direct" },
  } as const;

  readonly vertexDesc = VTagBase.vertexDesc;

  /** Apps tagged `(this:VTag)-[relApps]->VApp`. Inverse: {@link VApp.relTags}. */
  get relApps() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelApps);
  }

  /** Communities tagged `(this:VTag)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relTags}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelCommunities);
  }

  /** Learning resources tagged `(this:VTag)-[relLearning]->VLearning`. Inverse: {@link VLearning.relTags}. */
  get relLearning() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLearning);
  }

  /** Libraries tagged `(this:VTag)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relTags}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLibraries);
  }

  /** Plangs tagged `(this:VTag)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relTags}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelPlangs);
  }

  /** Tools tagged `(this:VTag)-[relTools]->VTool`. Inverse: {@link VTool.relTags}. */
  get relTools() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelTools);
  }
}

/** Type of the key of an instance of {@link VTool}. */
export type VToolKey = `tool+${string}`;

/** Programming Tool */
export abstract class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly keyPrefix = "tool";
  static readonly vertexName = "tool";
  static readonly vertexDesc = "Programming Tool";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = {
    relBundles: { edgeName: "bundleRelTools", direction: "inverse" },
    relLicenses: { edgeName: "licenseRelTools", direction: "inverse" },
    relPlangs: { edgeName: "plangRelTools", direction: "inverse" },
    relPlatforms: { edgeName: "toolRelPlatforms", direction: "direct" },
    relTags: { edgeName: "tagRelTools", direction: "inverse" },
    relWrittenWith: { edgeName: "toolRelWrittenWith", direction: "direct" },
  } as const;

  readonly vertexDesc = VToolBase.vertexDesc;

  /** Bundles including this `VBundle-[relTools]->(this:VTool)`. Inverse: {@link VBundle.relTools}. */
  get relBundles() {
    return new RelTo(this as unknown as VTool, this.graph.edges.bundleRelTools);
  }

  /** Licenses `VLicense-[relTools]->(this:VTool)`. Inverse: {@link VLicense.relTools}. */
  get relLicenses() {
    return new RelTo(this as unknown as VTool, this.graph.edges.licenseRelTools);
  }

  /** Plangs supported `VPlang-[relTools]->(this:VTool)`. Inverse: {@link VPlang.relTools}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTool, this.graph.edges.plangRelTools);
  }

  /** Platforms supported `(this:VTool)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relTools}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelPlatforms);
  }

  /** Tags `VTag-[relTools]->(this:VTool)`. Inverse: {@link VTag.relTools}. */
  get relTags() {
    return new RelTo(this as unknown as VTool, this.graph.edges.tagRelTools);
  }

  /** Plangs used to implement this `(this:VTool)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relToolsUsing}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VTypeSystem}. */
export type VTypeSystemKey = `tsys+${string}`;

/** Type System */
export abstract class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly keyPrefix = "tsys";
  static readonly vertexName = "typeSystem";
  static readonly vertexDesc = "Type System";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations = { relPlangs: { edgeName: "plangRelTypeSystems", direction: "inverse" } } as const;

  readonly vertexDesc = VTypeSystemBase.vertexDesc;

  /** Plangs implementing this `VPlang-[relTypeSystems]->(this:VTypeSystem)`. Inverse: {@link VPlang.relTypeSystems}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTypeSystem, this.graph.edges.plangRelTypeSystems);
  }
}
