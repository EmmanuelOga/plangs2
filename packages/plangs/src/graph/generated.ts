/**  Do not modify manually! Generated by graphgen on 2024-12-09T00:28:22.469Z. */

import { Edges, RelFrom, RelTo, type Relation, type SerializedGraph, Vertices } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

export type TPlangsVertexName =
  | "app"
  | "bundle"
  | "community"
  | "learning"
  | "library"
  | "license"
  | "paradigm"
  | "plang"
  | "platform"
  | "post"
  | "tag"
  | "tool"
  | "typeSystem";

/** Supported relations of each class. */
export type TPlangsRelations = {
  app: "relCommunities" | "relLearning" | "relLicenses" | "relPlatforms" | "relPosts" | "relTags" | "relWrittenWith";
  bundle: "relPlangs" | "relTools";
  community: "relApps" | "relLearning" | "relLibraries" | "relPlangs" | "relPosts" | "relTags" | "relTools";
  learning: "relApps" | "relCommunities" | "relLibraries" | "relPlangs" | "relPosts" | "relTags" | "relTools";
  library: "relCommunities" | "relLearning" | "relLicenses" | "relPlangs" | "relPlatforms" | "relPosts" | "relTags" | "relWrittenWith";
  license: "relApps" | "relLibraries" | "relPlangs" | "relTools";
  paradigm: "relPlangs";
  plang:
    | "relApps"
    | "relBundles"
    | "relCommunities"
    | "relCompilesTo"
    | "relDialectOf"
    | "relDialects"
    | "relImplementedBy"
    | "relImplements"
    | "relInfluenced"
    | "relInfluencedBy"
    | "relLearning"
    | "relLibraries"
    | "relLicenses"
    | "relParadigms"
    | "relPlatforms"
    | "relPosts"
    | "relTags"
    | "relTargetOf"
    | "relTools"
    | "relToolsUsing"
    | "relTypeSystems"
    | "relUsedInLibrary"
    | "relUsedToWrite"
    | "relWrittenWith";
  platform: "relApps" | "relLibraries" | "relPlangs" | "relTools";
  post: "relApps" | "relCommunities" | "relLearning" | "relLibraries" | "relPlangs" | "relTools";
  tag: "relApps" | "relCommunities" | "relLearning" | "relLibraries" | "relPlangs" | "relTools";
  tool: "relBundles" | "relCommunities" | "relLearning" | "relLicenses" | "relPlangs" | "relPlatforms" | "relPosts" | "relTags" | "relWrittenWith";
  typeSystem: "relPlangs";
};

/** Supported relations of the graph. */
export type TPlangsRelName = keyof PlangsGraphBase["edges"];

/** Every Generated Vertex Class. */
export type TPlangsVertexClass =
  | VApp
  | VBundle
  | VCommunity
  | VLearning
  | VLibrary
  | VLicense
  | VParadigm
  | VPlang
  | VPlatform
  | VPost
  | VTag
  | VTool
  | VTypeSystem;

/** Used for better autocomplete. */
export type TPlangsVClassByName = {
  app: VApp;
  bundle: VBundle;
  community: VCommunity;
  learning: VLearning;
  library: VLibrary;
  license: VLicense;
  paradigm: VParadigm;
  plang: VPlang;
  platform: VPlatform;
  post: VPost;
  tag: VTag;
  tool: VTool;
  typeSystem: VTypeSystem;
};

/** Supported edges of the graph. */
export type TPlangsEdgeName = keyof PlangsGraphBase["edges"];

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  /** Return a type checked object identifying a relationship of a specific kind of Vertex. */
  static relConfig<T extends TPlangsVertexName>(vertexName: T, vertexRel: TPlangsRelations[T]) {
    const klass = PlangsGraphBase.vertexClass(vertexName);
    // @ts-ignore correct by construction.
    const rel = klass.relations.get(vertexRel) as Relation<TPlangsEdgeName>;
    return { kind: "rel", edgeName: rel.edgeName, direction: rel.direction } as const;
  }

  /** Return a type checked object identifying a property of the class that is "readable" (a prop returning a String, Boolean or Nunber). */
  static propConfig<T extends TPlangsVertexName>(vertexName: T, vertexProp: keyof TPlangsVClassByName[T]) {
    return { kind: "prop", vertexName: vertexName as TPlangsVertexName, vertexProp: vertexProp as string } as const;
  }

  /** Get a Vertex class by its Vertex name. */
  static vertexClass<T extends TPlangsVertexName>(vertexName: T) {
    // We cannot use a Map here because each of the classes will not be initialized yet.
    if (vertexName === "app") return VApp;
    if (vertexName === "bundle") return VBundle;
    if (vertexName === "community") return VCommunity;
    if (vertexName === "learning") return VLearning;
    if (vertexName === "library") return VLibrary;
    if (vertexName === "license") return VLicense;
    if (vertexName === "paradigm") return VParadigm;
    if (vertexName === "plang") return VPlang;
    if (vertexName === "platform") return VPlatform;
    if (vertexName === "post") return VPost;
    if (vertexName === "tag") return VTag;
    if (vertexName === "tool") return VTool;
    if (vertexName === "typeSystem") return VTypeSystem;
  }

  /** Vertex kinds per Vertex Name. The kind is the prefix of a Vertex Key. */
  static readonly vertexKind = new Map<TPlangsVertexName, string>([
    ["app", "app"],
    ["bundle", "bun"],
    ["community", "comm"],
    ["learning", "learn"],
    ["library", "lib"],
    ["license", "lic"],
    ["paradigm", "para"],
    ["plang", "pl"],
    ["platform", "plat"],
    ["post", "post"],
    ["tag", "tag"],
    ["tool", "tool"],
    ["typeSystem", "tsys"],
  ]);

  /** Reverse map of vertexKind. */
  static readonly vertexNameByKind = new Map<string, TPlangsVertexName>(Array.from(PlangsGraphBase.vertexKind.entries()).map(([k, v]) => [v, k]));

  /** Get a vertex by key, if the kind of vertex is known. */
  getVertex(vertexKey: string): TPlangsVertexClass | undefined {
    const kind = vertexKey.split("+", 2)[0] as TPlangsVertexName;
    const vertexName = PlangsGraphBase.vertexNameByKind.get(kind);
    if (!vertexName) return;
    return this.vertices[vertexName]?.get(vertexKey as any);
  }

  // Create a Vertices instances for each vertex.

  readonly app = new Vertices<VApp>("app", "app", key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>("bundle", "bun", key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>("community", "comm", key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>("learning", "learn", key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>("library", "lib", key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>("license", "lic", key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>("paradigm", "para", key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>("plang", "pl", key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>("platform", "plat", key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>("post", "post", key => new VPost(this, key));
  readonly tag = new Vertices<VTag>("tag", "tag", key => new VTag(this, key));
  readonly tool = new Vertices<VTool>("tool", "tool", key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>("typeSystem", "tsys", key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly vertices = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    appRelPlatforms: new Edges(this.app, this.platform, "Platforms", "Apps"),
    appRelWrittenWith: new Edges(this.app, this.plang, "Plangs", "Apps"),
    bundleRelPlangs: new Edges(this.bundle, this.plang, "Plangs", "Bundles"),
    bundleRelTools: new Edges(this.bundle, this.tool, "Tools", "Bundles"),
    communityRelApps: new Edges(this.community, this.app, "Apps", "Communities"),
    communityRelLibraries: new Edges(this.community, this.library, "Libraries", "Communities"),
    communityRelPlangs: new Edges(this.community, this.plang, "Plangs", "Communities"),
    communityRelTools: new Edges(this.community, this.tool, "Tools", "Communities"),
    learningRelApps: new Edges(this.learning, this.app, "Apps", "Learning Resources"),
    learningRelCommunities: new Edges(this.learning, this.community, "Communities", "Learning Resources"),
    learningRelLibraries: new Edges(this.learning, this.library, "Libraries", "Learning Resources"),
    learningRelPlangs: new Edges(this.learning, this.plang, "Plangs", "Learning Resources"),
    learningRelTools: new Edges(this.learning, this.tool, "Tools", "Learning Resources"),
    libraryRelPlangs: new Edges(this.library, this.plang, "Plangs", "Libraries"),
    libraryRelPlatforms: new Edges(this.library, this.platform, "Platforms", "Libraries"),
    libraryRelWrittenWith: new Edges(this.library, this.plang, "Written With", "Used for Libraries"),
    licenseRelApps: new Edges(this.license, this.app, "Apps", "Licenses"),
    licenseRelLibraries: new Edges(this.license, this.library, "Libraries", "Licenses"),
    licenseRelPlangs: new Edges(this.license, this.plang, "Plangs", "Licenses"),
    licenseRelTools: new Edges(this.license, this.tool, "Tools", "Licenses"),
    plangRelCompilesTo: new Edges(this.plang, this.plang, "Transpiling Targets", "Source Plangs"),
    plangRelDialectOf: new Edges(this.plang, this.plang, "Dialect of", "Dialects"),
    plangRelImplements: new Edges(this.plang, this.plang, "Implements", "Implemented By"),
    plangRelInfluencedBy: new Edges(this.plang, this.plang, "Influenced By", "Influenced"),
    plangRelParadigms: new Edges(this.plang, this.paradigm, "Paradigms", "Plangs"),
    plangRelPlatforms: new Edges(this.plang, this.platform, "Platforms", "Plangs"),
    plangRelTools: new Edges(this.plang, this.tool, "Tools", "Plangs"),
    plangRelTypeSystems: new Edges(this.plang, this.typeSystem, "Type Systems", "Plangs"),
    plangRelWrittenWith: new Edges(this.plang, this.plang, "Written With", "Used to Write"),
    postRelApps: new Edges(this.post, this.app, "Apps", "Posts"),
    postRelCommunities: new Edges(this.post, this.community, "Communities", "Posts"),
    postRelLearning: new Edges(this.post, this.learning, "Learning Resources", "Posts"),
    postRelLibraries: new Edges(this.post, this.library, "Libraries", "Posts"),
    postRelPlangs: new Edges(this.post, this.plang, "Plangs", "Posts"),
    postRelTools: new Edges(this.post, this.tool, "Tools", "Posts"),
    tagRelApps: new Edges(this.tag, this.app, "Apps tagged", "Tags"),
    tagRelCommunities: new Edges(this.tag, this.community, "Communities", "Tags"),
    tagRelLearning: new Edges(this.tag, this.learning, "Learning Resources", "Tags"),
    tagRelLibraries: new Edges(this.tag, this.library, "Libraries", "Tags"),
    tagRelPlangs: new Edges(this.tag, this.plang, "Plangs", "Tags"),
    tagRelTools: new Edges(this.tag, this.tool, "Tools", "Tags"),
    toolRelPlatforms: new Edges(this.tool, this.platform, "Platforms", "Tools"),
    toolRelWrittenWith: new Edges(this.tool, this.plang, "Implemented With", "Tool Plang"),
  } as const;

  toJSON(): SerializedGraph {
    return {
      vertices: Object.fromEntries(Object.entries(this.vertices).map(([k, v]) => [k, v.toJSON()])),
      edges: Object.fromEntries(Object.entries(this.edges).map(([k, e]) => [k, e.toJSON()])),
    };
  }

  loadJSON(data: SerializedGraph): this {
    for (const [vertexName, vertices] of Object.entries(data.vertices)) {
      const map = this.vertices[vertexName as TPlangsVertexName];
      for (const [vertexKey, vertexData] of Object.entries(vertices)) {
        map.set(vertexKey as any, vertexData as any);
      }
    }
    for (const [edgeName, edges] of Object.entries(data.edges)) {
      const map = this.edges[edgeName as keyof typeof this.edges];
      for (const [fromKey, toKeys] of Object.entries(edges)) {
        map.add(fromKey as any, ...(toKeys as any[]));
      }
    }
    return this;
  }
}

/** Type of the key of an instance of {@link VApp}. */
export type VAppKey = `app+${string}`;

/** Software Application */
export abstract class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly vertexKind = "app" as const;
  static readonly vertexName = "app" as const;
  static readonly vertexDesc = "Software Application";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relCommunities", { edgeName: "communityRelApps", direction: "inverse" }],
    ["relLearning", { edgeName: "learningRelApps", direction: "inverse" }],
    ["relLicenses", { edgeName: "licenseRelApps", direction: "inverse" }],
    ["relPlatforms", { edgeName: "appRelPlatforms", direction: "direct" }],
    ["relPosts", { edgeName: "postRelApps", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelApps", direction: "inverse" }],
    ["relWrittenWith", { edgeName: "appRelWrittenWith", direction: "direct" }],
  ]);

  override readonly vertexKind = VAppBase.vertexKind;
  override readonly vertexDesc = VAppBase.vertexDesc;
  override readonly vertexName = VAppBase.vertexName;
  override readonly relations = VAppBase.relations;

  /** Communities `VCommunity-[relApps]->(this:VApp)`. Inverse: {@link VCommunity.relApps}. */
  get relCommunities() {
    return new RelTo(this as unknown as VApp, this.graph.edges.communityRelApps);
  }

  /** Learning Resources `VLearning-[relApps]->(this:VApp)`. Inverse: {@link VLearning.relApps}. */
  get relLearning() {
    return new RelTo(this as unknown as VApp, this.graph.edges.learningRelApps);
  }

  /** Licenses `VLicense-[relApps]->(this:VApp)`. Inverse: {@link VLicense.relApps}. */
  get relLicenses() {
    return new RelTo(this as unknown as VApp, this.graph.edges.licenseRelApps);
  }

  /** Platforms `(this:VApp)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relApps}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelPlatforms);
  }

  /** Posts `VPost-[relApps]->(this:VApp)`. Inverse: {@link VPost.relApps}. */
  get relPosts() {
    return new RelTo(this as unknown as VApp, this.graph.edges.postRelApps);
  }

  /** Tags `VTag-[relApps]->(this:VApp)`. Inverse: {@link VTag.relApps}. */
  get relTags() {
    return new RelTo(this as unknown as VApp, this.graph.edges.tagRelApps);
  }

  /** Plangs `(this:VApp)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relApps}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VBundle}. */
export type VBundleKey = `bun+${string}`;

/** Bundle of Tools */
export abstract class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly vertexKind = "bun" as const;
  static readonly vertexName = "bundle" as const;
  static readonly vertexDesc = "Bundle of Tools";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relPlangs", { edgeName: "bundleRelPlangs", direction: "direct" }],
    ["relTools", { edgeName: "bundleRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VBundleBase.vertexKind;
  override readonly vertexDesc = VBundleBase.vertexDesc;
  override readonly vertexName = VBundleBase.vertexName;
  override readonly relations = VBundleBase.relations;

  /** Plangs `(this:VBundle)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relBundles}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelPlangs);
  }

  /** Tools `(this:VBundle)-[relTools]->VTool`. Inverse: {@link VTool.relBundles}. */
  get relTools() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelTools);
  }
}

/** Type of the key of an instance of {@link VCommunity}. */
export type VCommunityKey = `comm+${string}`;

/** Community */
export abstract class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly vertexKind = "comm" as const;
  static readonly vertexName = "community" as const;
  static readonly vertexDesc = "Community";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "communityRelApps", direction: "direct" }],
    ["relLearning", { edgeName: "learningRelCommunities", direction: "inverse" }],
    ["relLibraries", { edgeName: "communityRelLibraries", direction: "direct" }],
    ["relPlangs", { edgeName: "communityRelPlangs", direction: "direct" }],
    ["relPosts", { edgeName: "postRelCommunities", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelCommunities", direction: "inverse" }],
    ["relTools", { edgeName: "communityRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VCommunityBase.vertexKind;
  override readonly vertexDesc = VCommunityBase.vertexDesc;
  override readonly vertexName = VCommunityBase.vertexName;
  override readonly relations = VCommunityBase.relations;

  /** Apps `(this:VCommunity)-[relApps]->VApp`. Inverse: {@link VApp.relCommunities}. */
  get relApps() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelApps);
  }

  /** Learning Resources `VLearning-[relCommunities]->(this:VCommunity)`. Inverse: {@link VLearning.relCommunities}. */
  get relLearning() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.learningRelCommunities);
  }

  /** Libraries `(this:VCommunity)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relCommunities}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelLibraries);
  }

  /** Plangs `(this:VCommunity)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relCommunities}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelPlangs);
  }

  /** Posts `VPost-[relCommunities]->(this:VCommunity)`. Inverse: {@link VPost.relCommunities}. */
  get relPosts() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.postRelCommunities);
  }

  /** Tags `VTag-[relCommunities]->(this:VCommunity)`. Inverse: {@link VTag.relCommunities}. */
  get relTags() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.tagRelCommunities);
  }

  /** Tools `(this:VCommunity)-[relTools]->VTool`. Inverse: {@link VTool.relCommunities}. */
  get relTools() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelTools);
  }
}

/** Type of the key of an instance of {@link VLearning}. */
export type VLearningKey = `learn+${string}`;

/** Learning Resource */
export abstract class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly vertexKind = "learn" as const;
  static readonly vertexName = "learning" as const;
  static readonly vertexDesc = "Learning Resource";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "learningRelApps", direction: "direct" }],
    ["relCommunities", { edgeName: "learningRelCommunities", direction: "direct" }],
    ["relLibraries", { edgeName: "learningRelLibraries", direction: "direct" }],
    ["relPlangs", { edgeName: "learningRelPlangs", direction: "direct" }],
    ["relPosts", { edgeName: "postRelLearning", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelLearning", direction: "inverse" }],
    ["relTools", { edgeName: "learningRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VLearningBase.vertexKind;
  override readonly vertexDesc = VLearningBase.vertexDesc;
  override readonly vertexName = VLearningBase.vertexName;
  override readonly relations = VLearningBase.relations;

  /** Apps `(this:VLearning)-[relApps]->VApp`. Inverse: {@link VApp.relLearning}. */
  get relApps() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelApps);
  }

  /** Communities `(this:VLearning)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relLearning}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelCommunities);
  }

  /** Libraries `(this:VLearning)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLearning}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelLibraries);
  }

  /** Plangs `(this:VLearning)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLearning}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelPlangs);
  }

  /** Posts `VPost-[relLearning]->(this:VLearning)`. Inverse: {@link VPost.relLearning}. */
  get relPosts() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.postRelLearning);
  }

  /** Tags `VTag-[relLearning]->(this:VLearning)`. Inverse: {@link VTag.relLearning}. */
  get relTags() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.tagRelLearning);
  }

  /** Tools `(this:VLearning)-[relTools]->VTool`. Inverse: {@link VTool.relLearning}. */
  get relTools() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelTools);
  }
}

/** Type of the key of an instance of {@link VLibrary}. */
export type VLibraryKey = `lib+${string}`;

/** Software Library */
export abstract class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly vertexKind = "lib" as const;
  static readonly vertexName = "library" as const;
  static readonly vertexDesc = "Software Library";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relCommunities", { edgeName: "communityRelLibraries", direction: "inverse" }],
    ["relLearning", { edgeName: "learningRelLibraries", direction: "inverse" }],
    ["relLicenses", { edgeName: "licenseRelLibraries", direction: "inverse" }],
    ["relPlangs", { edgeName: "libraryRelPlangs", direction: "direct" }],
    ["relPlatforms", { edgeName: "libraryRelPlatforms", direction: "direct" }],
    ["relPosts", { edgeName: "postRelLibraries", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelLibraries", direction: "inverse" }],
    ["relWrittenWith", { edgeName: "libraryRelWrittenWith", direction: "direct" }],
  ]);

  override readonly vertexKind = VLibraryBase.vertexKind;
  override readonly vertexDesc = VLibraryBase.vertexDesc;
  override readonly vertexName = VLibraryBase.vertexName;
  override readonly relations = VLibraryBase.relations;

  /** Communities `VCommunity-[relLibraries]->(this:VLibrary)`. Inverse: {@link VCommunity.relLibraries}. */
  get relCommunities() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.communityRelLibraries);
  }

  /** Learning Resources `VLearning-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLearning.relLibraries}. */
  get relLearning() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.learningRelLibraries);
  }

  /** Licenses `VLicense-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLicense.relLibraries}. */
  get relLicenses() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs `(this:VLibrary)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLibraries}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlangs);
  }

  /** Platforms `(this:VLibrary)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relLibraries}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlatforms);
  }

  /** Posts `VPost-[relLibraries]->(this:VLibrary)`. Inverse: {@link VPost.relLibraries}. */
  get relPosts() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.postRelLibraries);
  }

  /** Tags `VTag-[relLibraries]->(this:VLibrary)`. Inverse: {@link VTag.relLibraries}. */
  get relTags() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.tagRelLibraries);
  }

  /** Written With `(this:VLibrary)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedInLibrary}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VLicense}. */
export type VLicenseKey = `lic+${string}`;

/** Software License */
export abstract class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly vertexKind = "lic" as const;
  static readonly vertexName = "license" as const;
  static readonly vertexDesc = "Software License";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "licenseRelApps", direction: "direct" }],
    ["relLibraries", { edgeName: "licenseRelLibraries", direction: "direct" }],
    ["relPlangs", { edgeName: "licenseRelPlangs", direction: "direct" }],
    ["relTools", { edgeName: "licenseRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VLicenseBase.vertexKind;
  override readonly vertexDesc = VLicenseBase.vertexDesc;
  override readonly vertexName = VLicenseBase.vertexName;
  override readonly relations = VLicenseBase.relations;

  /** Apps `(this:VLicense)-[relApps]->VApp`. Inverse: {@link VApp.relLicenses}. */
  get relApps() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelApps);
  }

  /** Libraries `(this:VLicense)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLicenses}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs `(this:VLicense)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLicenses}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelPlangs);
  }

  /** Tools `(this:VLicense)-[relTools]->VTool`. Inverse: {@link VTool.relLicenses}. */
  get relTools() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelTools);
  }
}

/** Type of the key of an instance of {@link VParadigm}. */
export type VParadigmKey = `para+${string}`;

/** Programming Language Paradigm */
export abstract class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly vertexKind = "para" as const;
  static readonly vertexName = "paradigm" as const;
  static readonly vertexDesc = "Programming Language Paradigm";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relPlangs", { edgeName: "plangRelParadigms", direction: "inverse" }],
  ]);

  override readonly vertexKind = VParadigmBase.vertexKind;
  override readonly vertexDesc = VParadigmBase.vertexDesc;
  override readonly vertexName = VParadigmBase.vertexName;
  override readonly relations = VParadigmBase.relations;

  /** Plangs `VPlang-[relParadigms]->(this:VParadigm)`. Inverse: {@link VPlang.relParadigms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VParadigm, this.graph.edges.plangRelParadigms);
  }
}

/** Type of the key of an instance of {@link VPlang}. */
export type VPlangKey = `pl+${string}`;

/** Programming Language */
export abstract class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly vertexKind = "pl" as const;
  static readonly vertexName = "plang" as const;
  static readonly vertexDesc = "Programming Language";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "appRelWrittenWith", direction: "inverse" }],
    ["relBundles", { edgeName: "bundleRelPlangs", direction: "inverse" }],
    ["relCommunities", { edgeName: "communityRelPlangs", direction: "inverse" }],
    ["relCompilesTo", { edgeName: "plangRelCompilesTo", direction: "direct" }],
    ["relDialectOf", { edgeName: "plangRelDialectOf", direction: "direct" }],
    ["relDialects", { edgeName: "plangRelDialectOf", direction: "inverse" }],
    ["relImplementedBy", { edgeName: "plangRelImplements", direction: "inverse" }],
    ["relImplements", { edgeName: "plangRelImplements", direction: "direct" }],
    ["relInfluenced", { edgeName: "plangRelInfluencedBy", direction: "inverse" }],
    ["relInfluencedBy", { edgeName: "plangRelInfluencedBy", direction: "direct" }],
    ["relLearning", { edgeName: "learningRelPlangs", direction: "inverse" }],
    ["relLibraries", { edgeName: "libraryRelPlangs", direction: "inverse" }],
    ["relLicenses", { edgeName: "licenseRelPlangs", direction: "inverse" }],
    ["relParadigms", { edgeName: "plangRelParadigms", direction: "direct" }],
    ["relPlatforms", { edgeName: "plangRelPlatforms", direction: "direct" }],
    ["relPosts", { edgeName: "postRelPlangs", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelPlangs", direction: "inverse" }],
    ["relTargetOf", { edgeName: "plangRelCompilesTo", direction: "inverse" }],
    ["relTools", { edgeName: "plangRelTools", direction: "direct" }],
    ["relToolsUsing", { edgeName: "toolRelWrittenWith", direction: "inverse" }],
    ["relTypeSystems", { edgeName: "plangRelTypeSystems", direction: "direct" }],
    ["relUsedInLibrary", { edgeName: "libraryRelWrittenWith", direction: "inverse" }],
    ["relUsedToWrite", { edgeName: "plangRelWrittenWith", direction: "inverse" }],
    ["relWrittenWith", { edgeName: "plangRelWrittenWith", direction: "direct" }],
  ]);

  override readonly vertexKind = VPlangBase.vertexKind;
  override readonly vertexDesc = VPlangBase.vertexDesc;
  override readonly vertexName = VPlangBase.vertexName;
  override readonly relations = VPlangBase.relations;

  /** Apps `VApp-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VApp.relWrittenWith}. */
  get relApps() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.appRelWrittenWith);
  }

  /** Bundles `VBundle-[relPlangs]->(this:VPlang)`. Inverse: {@link VBundle.relPlangs}. */
  get relBundles() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.bundleRelPlangs);
  }

  /** Communities `VCommunity-[relPlangs]->(this:VPlang)`. Inverse: {@link VCommunity.relPlangs}. */
  get relCommunities() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.communityRelPlangs);
  }

  /** Transpiling Targets `(this:VPlang)-[relCompilesTo]->VPlang`. Inverse: {@link VPlang.relTargetOf}. */
  get relCompilesTo() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Dialect of `(this:VPlang)-[relDialectOf]->VPlang`. Inverse: {@link VPlang.relDialects}. */
  get relDialectOf() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Dialects `VPlang-[relDialectOf]->(this:VPlang)`. Inverse: {@link VPlang.relDialectOf}. */
  get relDialects() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Implemented By `VPlang-[relImplements]->(this:VPlang)`. Inverse: {@link VPlang.relImplements}. */
  get relImplementedBy() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Implements `(this:VPlang)-[relImplements]->VPlang`. Inverse: {@link VPlang.relImplementedBy}. */
  get relImplements() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Influenced `VPlang-[relInfluencedBy]->(this:VPlang)`. Inverse: {@link VPlang.relInfluencedBy}. */
  get relInfluenced() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Influenced By `(this:VPlang)-[relInfluencedBy]->VPlang`. Inverse: {@link VPlang.relInfluenced}. */
  get relInfluencedBy() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Learning Resources `VLearning-[relPlangs]->(this:VPlang)`. Inverse: {@link VLearning.relPlangs}. */
  get relLearning() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.learningRelPlangs);
  }

  /** Libraries `VLibrary-[relPlangs]->(this:VPlang)`. Inverse: {@link VLibrary.relPlangs}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelPlangs);
  }

  /** Licenses `VLicense-[relPlangs]->(this:VPlang)`. Inverse: {@link VLicense.relPlangs}. */
  get relLicenses() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.licenseRelPlangs);
  }

  /** Paradigms `(this:VPlang)-[relParadigms]->VParadigm`. Inverse: {@link VParadigm.relPlangs}. */
  get relParadigms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelParadigms);
  }

  /** Platforms `(this:VPlang)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relPlangs}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelPlatforms);
  }

  /** Posts `VPost-[relPlangs]->(this:VPlang)`. Inverse: {@link VPost.relPlangs}. */
  get relPosts() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.postRelPlangs);
  }

  /** Tags `VTag-[relPlangs]->(this:VPlang)`. Inverse: {@link VTag.relPlangs}. */
  get relTags() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.tagRelPlangs);
  }

  /** Source Plangs `VPlang-[relCompilesTo]->(this:VPlang)`. Inverse: {@link VPlang.relCompilesTo}. */
  get relTargetOf() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Tools `(this:VPlang)-[relTools]->VTool`. Inverse: {@link VTool.relPlangs}. */
  get relTools() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTools);
  }

  /** Tool Plang `VTool-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VTool.relWrittenWith}. */
  get relToolsUsing() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.toolRelWrittenWith);
  }

  /** Type Systems `(this:VPlang)-[relTypeSystems]->VTypeSystem`. Inverse: {@link VTypeSystem.relPlangs}. */
  get relTypeSystems() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTypeSystems);
  }

  /** Used for Libraries `VLibrary-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VLibrary.relWrittenWith}. */
  get relUsedInLibrary() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelWrittenWith);
  }

  /** Used to Write `VPlang-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VPlang.relWrittenWith}. */
  get relUsedToWrite() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Written With `(this:VPlang)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedToWrite}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VPlatform}. */
export type VPlatformKey = `plat+${string}`;

/** Platform where Software runs */
export abstract class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly vertexKind = "plat" as const;
  static readonly vertexName = "platform" as const;
  static readonly vertexDesc = "Platform where Software runs";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "appRelPlatforms", direction: "inverse" }],
    ["relLibraries", { edgeName: "libraryRelPlatforms", direction: "inverse" }],
    ["relPlangs", { edgeName: "plangRelPlatforms", direction: "inverse" }],
    ["relTools", { edgeName: "toolRelPlatforms", direction: "inverse" }],
  ]);

  override readonly vertexKind = VPlatformBase.vertexKind;
  override readonly vertexDesc = VPlatformBase.vertexDesc;
  override readonly vertexName = VPlatformBase.vertexName;
  override readonly relations = VPlatformBase.relations;

  /** Apps `VApp-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VApp.relPlatforms}. */
  get relApps() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.appRelPlatforms);
  }

  /** Libraries `VLibrary-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VLibrary.relPlatforms}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.libraryRelPlatforms);
  }

  /** Plangs `VPlang-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VPlang.relPlatforms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.plangRelPlatforms);
  }

  /** Tools `VTool-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VTool.relPlatforms}. */
  get relTools() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.toolRelPlatforms);
  }
}

/** Type of the key of an instance of {@link VPost}. */
export type VPostKey = `post+${string}`;

/** Blog Post */
export abstract class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly vertexKind = "post" as const;
  static readonly vertexName = "post" as const;
  static readonly vertexDesc = "Blog Post";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "postRelApps", direction: "direct" }],
    ["relCommunities", { edgeName: "postRelCommunities", direction: "direct" }],
    ["relLearning", { edgeName: "postRelLearning", direction: "direct" }],
    ["relLibraries", { edgeName: "postRelLibraries", direction: "direct" }],
    ["relPlangs", { edgeName: "postRelPlangs", direction: "direct" }],
    ["relTools", { edgeName: "postRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VPostBase.vertexKind;
  override readonly vertexDesc = VPostBase.vertexDesc;
  override readonly vertexName = VPostBase.vertexName;
  override readonly relations = VPostBase.relations;

  /** Apps `(this:VPost)-[relApps]->VApp`. Inverse: {@link VApp.relPosts}. */
  get relApps() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelApps);
  }

  /** Communities `(this:VPost)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relPosts}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelCommunities);
  }

  /** Learning Resources `(this:VPost)-[relLearning]->VLearning`. Inverse: {@link VLearning.relPosts}. */
  get relLearning() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelLearning);
  }

  /** Libraries `(this:VPost)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relPosts}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelLibraries);
  }

  /** Plangs `(this:VPost)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relPosts}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelPlangs);
  }

  /** Tools `(this:VPost)-[relTools]->VTool`. Inverse: {@link VTool.relPosts}. */
  get relTools() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelTools);
  }
}

/** Type of the key of an instance of {@link VTag}. */
export type VTagKey = `tag+${string}`;

/** Tag */
export abstract class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly vertexKind = "tag" as const;
  static readonly vertexName = "tag" as const;
  static readonly vertexDesc = "Tag";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relApps", { edgeName: "tagRelApps", direction: "direct" }],
    ["relCommunities", { edgeName: "tagRelCommunities", direction: "direct" }],
    ["relLearning", { edgeName: "tagRelLearning", direction: "direct" }],
    ["relLibraries", { edgeName: "tagRelLibraries", direction: "direct" }],
    ["relPlangs", { edgeName: "tagRelPlangs", direction: "direct" }],
    ["relTools", { edgeName: "tagRelTools", direction: "direct" }],
  ]);

  override readonly vertexKind = VTagBase.vertexKind;
  override readonly vertexDesc = VTagBase.vertexDesc;
  override readonly vertexName = VTagBase.vertexName;
  override readonly relations = VTagBase.relations;

  /** Apps tagged `(this:VTag)-[relApps]->VApp`. Inverse: {@link VApp.relTags}. */
  get relApps() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelApps);
  }

  /** Communities `(this:VTag)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relTags}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelCommunities);
  }

  /** Learning Resources `(this:VTag)-[relLearning]->VLearning`. Inverse: {@link VLearning.relTags}. */
  get relLearning() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLearning);
  }

  /** Libraries `(this:VTag)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relTags}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLibraries);
  }

  /** Plangs `(this:VTag)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relTags}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelPlangs);
  }

  /** Tools `(this:VTag)-[relTools]->VTool`. Inverse: {@link VTool.relTags}. */
  get relTools() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelTools);
  }
}

/** Type of the key of an instance of {@link VTool}. */
export type VToolKey = `tool+${string}`;

/** Programming Tool */
export abstract class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly vertexKind = "tool" as const;
  static readonly vertexName = "tool" as const;
  static readonly vertexDesc = "Programming Tool";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relBundles", { edgeName: "bundleRelTools", direction: "inverse" }],
    ["relCommunities", { edgeName: "communityRelTools", direction: "inverse" }],
    ["relLearning", { edgeName: "learningRelTools", direction: "inverse" }],
    ["relLicenses", { edgeName: "licenseRelTools", direction: "inverse" }],
    ["relPlangs", { edgeName: "plangRelTools", direction: "inverse" }],
    ["relPlatforms", { edgeName: "toolRelPlatforms", direction: "direct" }],
    ["relPosts", { edgeName: "postRelTools", direction: "inverse" }],
    ["relTags", { edgeName: "tagRelTools", direction: "inverse" }],
    ["relWrittenWith", { edgeName: "toolRelWrittenWith", direction: "direct" }],
  ]);

  override readonly vertexKind = VToolBase.vertexKind;
  override readonly vertexDesc = VToolBase.vertexDesc;
  override readonly vertexName = VToolBase.vertexName;
  override readonly relations = VToolBase.relations;

  /** Bundles `VBundle-[relTools]->(this:VTool)`. Inverse: {@link VBundle.relTools}. */
  get relBundles() {
    return new RelTo(this as unknown as VTool, this.graph.edges.bundleRelTools);
  }

  /** Communities `VCommunity-[relTools]->(this:VTool)`. Inverse: {@link VCommunity.relTools}. */
  get relCommunities() {
    return new RelTo(this as unknown as VTool, this.graph.edges.communityRelTools);
  }

  /** Learning Resources `VLearning-[relTools]->(this:VTool)`. Inverse: {@link VLearning.relTools}. */
  get relLearning() {
    return new RelTo(this as unknown as VTool, this.graph.edges.learningRelTools);
  }

  /** Licenses `VLicense-[relTools]->(this:VTool)`. Inverse: {@link VLicense.relTools}. */
  get relLicenses() {
    return new RelTo(this as unknown as VTool, this.graph.edges.licenseRelTools);
  }

  /** Plangs `VPlang-[relTools]->(this:VTool)`. Inverse: {@link VPlang.relTools}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTool, this.graph.edges.plangRelTools);
  }

  /** Platforms `(this:VTool)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relTools}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelPlatforms);
  }

  /** Posts `VPost-[relTools]->(this:VTool)`. Inverse: {@link VPost.relTools}. */
  get relPosts() {
    return new RelTo(this as unknown as VTool, this.graph.edges.postRelTools);
  }

  /** Tags `VTag-[relTools]->(this:VTool)`. Inverse: {@link VTag.relTools}. */
  get relTags() {
    return new RelTo(this as unknown as VTool, this.graph.edges.tagRelTools);
  }

  /** Implemented With `(this:VTool)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relToolsUsing}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelWrittenWith);
  }
}

/** Type of the key of an instance of {@link VTypeSystem}. */
export type VTypeSystemKey = `tsys+${string}`;

/** Type System */
export abstract class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly vertexKind = "tsys" as const;
  static readonly vertexName = "typeSystem" as const;
  static readonly vertexDesc = "Type System";

  /** Describes the edges and direction used for every relationship in this Vertex. */
  static readonly relations: Map<string, Relation<TPlangsRelName>> = new Map([
    ["relPlangs", { edgeName: "plangRelTypeSystems", direction: "inverse" }],
  ]);

  override readonly vertexKind = VTypeSystemBase.vertexKind;
  override readonly vertexDesc = VTypeSystemBase.vertexDesc;
  override readonly vertexName = VTypeSystemBase.vertexName;
  override readonly relations = VTypeSystemBase.relations;

  /** Plangs `VPlang-[relTypeSystems]->(this:VTypeSystem)`. Inverse: {@link VPlang.relTypeSystems}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTypeSystem, this.graph.edges.plangRelTypeSystems);
  }
}
