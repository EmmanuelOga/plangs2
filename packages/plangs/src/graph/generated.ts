/**  Do not modify manually! Generated by graphgen on 2024-11-28T11:54:38.205Z. */

import { Edges, RelFrom, RelTo, type SerializedGraph, Vertices } from "@plangs/graphgen/library";

/** Import user defined classes and types. */
import { VApp, VBundle, VCommunity, VLearning, VLibrary, VLicense, VParadigm, VPlang, VPlatform, VPost, VTag, VTool, VTypeSystem } from ".";
import { PlangsVertex } from "./vertex_base";
import type {
  VAppData,
  VBundleData,
  VCommunityData,
  VLearningData,
  VLibraryData,
  VLicenseData,
  VParadigmData,
  VPlangData,
  VPlatformData,
  VPostData,
  VTagData,
  VToolData,
  VTypeSystemData,
} from "./vertex_data_schemas";

/** Mapping from vertex name to kind. The vertex kind is the prefix for Vertex keys: `${kind}+${id}`. */
export const PLANGS_VERTEX_NAME_TO_KIND = {
  app: "app",
  bundle: "bun",
  community: "comm",
  learning: "learn",
  library: "lib",
  license: "lic",
  paradigm: "para",
  plang: "pl",
  platform: "plat",
  post: "post",
  tag: "tag",
  tool: "tool",
  typeSystem: "tsys",
} as const;

export type PlangsVertexName = keyof typeof PLANGS_VERTEX_NAME_TO_KIND;
export type PlangsEdgeName = keyof PlangsGraphBase["edges"];

/** Base class for the Plangs graph, generated from its specification. */
export class PlangsGraphBase {
  readonly app = new Vertices<VApp>(key => new VApp(this, key));
  readonly bundle = new Vertices<VBundle>(key => new VBundle(this, key));
  readonly community = new Vertices<VCommunity>(key => new VCommunity(this, key));
  readonly learning = new Vertices<VLearning>(key => new VLearning(this, key));
  readonly library = new Vertices<VLibrary>(key => new VLibrary(this, key));
  readonly license = new Vertices<VLicense>(key => new VLicense(this, key));
  readonly paradigm = new Vertices<VParadigm>(key => new VParadigm(this, key));
  readonly plang = new Vertices<VPlang>(key => new VPlang(this, key));
  readonly platform = new Vertices<VPlatform>(key => new VPlatform(this, key));
  readonly post = new Vertices<VPost>(key => new VPost(this, key));
  readonly tag = new Vertices<VTag>(key => new VTag(this, key));
  readonly tool = new Vertices<VTool>(key => new VTool(this, key));
  readonly typeSystem = new Vertices<VTypeSystem>(key => new VTypeSystem(this, key));

  /** All vertex collections. */
  readonly vertices = {
    app: this.app,
    bundle: this.bundle,
    community: this.community,
    learning: this.learning,
    library: this.library,
    license: this.license,
    paradigm: this.paradigm,
    plang: this.plang,
    platform: this.platform,
    post: this.post,
    tag: this.tag,
    tool: this.tool,
    typeSystem: this.typeSystem,
  } as const;

  /** All edge collections. */
  readonly edges = {
    plangRelParadigms: new Edges(this.plang, this.paradigm),
    plangRelCompilesTo: new Edges(this.plang, this.plang),
    plangRelDialectOf: new Edges(this.plang, this.plang),
    plangRelImplements: new Edges(this.plang, this.plang),
    plangRelInfluencedBy: new Edges(this.plang, this.plang),
    plangRelWrittenWith: new Edges(this.plang, this.plang),
    plangRelPlatforms: new Edges(this.plang, this.platform),
    plangRelTools: new Edges(this.plang, this.tool),
    plangRelTypeSystems: new Edges(this.plang, this.typeSystem),
    licenseRelApps: new Edges(this.license, this.app),
    licenseRelLibraries: new Edges(this.license, this.library),
    licenseRelPlangs: new Edges(this.license, this.plang),
    licenseRelTools: new Edges(this.license, this.tool),
    tagRelApps: new Edges(this.tag, this.app),
    tagRelCommunities: new Edges(this.tag, this.community),
    tagRelLearning: new Edges(this.tag, this.learning),
    tagRelLibraries: new Edges(this.tag, this.library),
    tagRelPlangs: new Edges(this.tag, this.plang),
    tagRelTools: new Edges(this.tag, this.tool),
    appRelPlatforms: new Edges(this.app, this.platform),
    appRelWrittenWith: new Edges(this.app, this.plang),
    bundleRelTools: new Edges(this.bundle, this.tool),
    communityRelPlangs: new Edges(this.community, this.plang),
    learningRelCommunities: new Edges(this.learning, this.community),
    learningRelPlangs: new Edges(this.learning, this.plang),
    libraryRelPlatforms: new Edges(this.library, this.platform),
    libraryRelPlangs: new Edges(this.library, this.plang),
    libraryRelWrittenWith: new Edges(this.library, this.plang),
    postRelPlangs: new Edges(this.post, this.plang),
    toolRelPlatforms: new Edges(this.tool, this.platform),
    toolRelWrittenWith: new Edges(this.tool, this.plang),
  } as const;

  toJSON(): SerializedGraph {
    return {
      vertices: Object.fromEntries(Object.entries(this.vertices).map(([k, v]) => [k, v.toJSON()])),
      edges: Object.fromEntries(Object.entries(this.edges).map(([k, e]) => [k, e.toJSON()])),
    };
  }

  loadJSON(data: SerializedGraph) {
    for (const [vertexName, vertices] of Object.entries(data.vertices)) {
      this.vertices[vertexName as PlangsVertexName].setMany(vertices as [any, any]);
    }
    for (const [edgeName, edges] of Object.entries(data.edges)) {
      this.edges[edgeName as PlangsEdgeName].addMany(edges as [any, any]);
    }
  }
}

export type VAppKey = `app+${string}`;

/** Software Application */
export abstract class VAppBase extends PlangsVertex<"app", VAppData> {
  static readonly kind = "app";
  override readonly kind = VAppBase.kind;

  static readonly desc = "Software Application";
  override readonly desc = VAppBase.desc;

  /** Licenses. `VLicense-[relApps]->(this:VApp)`. Inverse: {@link VLicense.relApps}. */
  get relLicenses() {
    return new RelTo(this as unknown as VApp, this.graph.edges.licenseRelApps);
  }

  /** Tags. `VTag-[relApps]->(this:VApp)`. Inverse: {@link VTag.relApps}. */
  get relTags() {
    return new RelTo(this as unknown as VApp, this.graph.edges.tagRelApps);
  }

  /** Platforms supported. `(this:VApp)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relApps}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelPlatforms);
  }

  /** Plangs used to implement this. `(this:VApp)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relApps}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VApp, this.graph.edges.appRelWrittenWith);
  }
}

export type VBundleKey = `bun+${string}`;

/** Bundle of Tools */
export abstract class VBundleBase extends PlangsVertex<"bun", VBundleData> {
  static readonly kind = "bun";
  override readonly kind = VBundleBase.kind;

  static readonly desc = "Bundle of Tools";
  override readonly desc = VBundleBase.desc;

  /** Tools in this. `(this:VBundle)-[relTools]->VTool`. Inverse: {@link VTool.relBundles}. */
  get relTools() {
    return new RelFrom(this as unknown as VBundle, this.graph.edges.bundleRelTools);
  }
}

export type VCommunityKey = `comm+${string}`;

/** Community */
export abstract class VCommunityBase extends PlangsVertex<"comm", VCommunityData> {
  static readonly kind = "comm";
  override readonly kind = VCommunityBase.kind;

  static readonly desc = "Community";
  override readonly desc = VCommunityBase.desc;

  /** Tags. `VTag-[relCommunities]->(this:VCommunity)`. Inverse: {@link VTag.relCommunities}. */
  get relTags() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.tagRelCommunities);
  }

  /** Plangs supported. `(this:VCommunity)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relCommunities}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VCommunity, this.graph.edges.communityRelPlangs);
  }

  /** Learning resources. `VLearning-[relCommunities]->(this:VCommunity)`. Inverse: {@link VLearning.relCommunities}. */
  get relLearning() {
    return new RelTo(this as unknown as VCommunity, this.graph.edges.learningRelCommunities);
  }
}

export type VLearningKey = `learn+${string}`;

/** Learning Resource */
export abstract class VLearningBase extends PlangsVertex<"learn", VLearningData> {
  static readonly kind = "learn";
  override readonly kind = VLearningBase.kind;

  static readonly desc = "Learning Resource";
  override readonly desc = VLearningBase.desc;

  /** Tags. `VTag-[relLearning]->(this:VLearning)`. Inverse: {@link VTag.relLearning}. */
  get relTags() {
    return new RelTo(this as unknown as VLearning, this.graph.edges.tagRelLearning);
  }

  /** Communities supporting this. `(this:VLearning)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relLearning}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelCommunities);
  }

  /** Plangs covered. `(this:VLearning)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLearning}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLearning, this.graph.edges.learningRelPlangs);
  }
}

export type VLibraryKey = `lib+${string}`;

/** Software Library */
export abstract class VLibraryBase extends PlangsVertex<"lib", VLibraryData> {
  static readonly kind = "lib";
  override readonly kind = VLibraryBase.kind;

  static readonly desc = "Software Library";
  override readonly desc = VLibraryBase.desc;

  /** Licenses. `VLicense-[relLibraries]->(this:VLibrary)`. Inverse: {@link VLicense.relLibraries}. */
  get relLicenses() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.licenseRelLibraries);
  }

  /** Tags. `VTag-[relLibraries]->(this:VLibrary)`. Inverse: {@link VTag.relLibraries}. */
  get relTags() {
    return new RelTo(this as unknown as VLibrary, this.graph.edges.tagRelLibraries);
  }

  /** Platforms supported. `(this:VLibrary)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relLibraries}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlatforms);
  }

  /** Plangs supported. `(this:VLibrary)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLibraries}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelPlangs);
  }

  /** Plangs used. `(this:VLibrary)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedInLibrary}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VLibrary, this.graph.edges.libraryRelWrittenWith);
  }
}

export type VLicenseKey = `lic+${string}`;

/** Software License */
export abstract class VLicenseBase extends PlangsVertex<"lic", VLicenseData> {
  static readonly kind = "lic";
  override readonly kind = VLicenseBase.kind;

  static readonly desc = "Software License";
  override readonly desc = VLicenseBase.desc;

  /** Apps using this. `(this:VLicense)-[relApps]->VApp`. Inverse: {@link VApp.relLicenses}. */
  get relApps() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelApps);
  }

  /** Libraries using this. `(this:VLicense)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relLicenses}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelLibraries);
  }

  /** Plangs using this. `(this:VLicense)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relLicenses}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelPlangs);
  }

  /** Tools using this. `(this:VLicense)-[relTools]->VTool`. Inverse: {@link VTool.relLicenses}. */
  get relTools() {
    return new RelFrom(this as unknown as VLicense, this.graph.edges.licenseRelTools);
  }
}

export type VParadigmKey = `para+${string}`;

/** Programming Language Paradigm */
export abstract class VParadigmBase extends PlangsVertex<"para", VParadigmData> {
  static readonly kind = "para";
  override readonly kind = VParadigmBase.kind;

  static readonly desc = "Programming Language Paradigm";
  override readonly desc = VParadigmBase.desc;

  /** Plangs implementing this. `VPlang-[relParadigms]->(this:VParadigm)`. Inverse: {@link VPlang.relParadigms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VParadigm, this.graph.edges.plangRelParadigms);
  }
}

export type VPlangKey = `pl+${string}`;

/** Programming Language */
export abstract class VPlangBase extends PlangsVertex<"pl", VPlangData> {
  static readonly kind = "pl";
  override readonly kind = VPlangBase.kind;

  static readonly desc = "Programming Language";
  override readonly desc = VPlangBase.desc;

  /** Paradigms implemented. `(this:VPlang)-[relParadigms]->VParadigm`. Inverse: {@link VParadigm.relPlangs}. */
  get relParadigms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelParadigms);
  }

  /** Transpiling targets. `(this:VPlang)-[relCompilesTo]->VPlang`. Inverse: {@link VPlang.relTargetOf}. */
  get relCompilesTo() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Plangs compiling to this. `VPlang-[relCompilesTo]->(this:VPlang)`. Inverse: {@link VPlang.relCompilesTo}. */
  get relTargetOf() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelCompilesTo);
  }

  /** Plangs this is a Dialect of. `(this:VPlang)-[relDialectOf]->VPlang`. Inverse: {@link VPlang.relDialects}. */
  get relDialectOf() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Dialects. `VPlang-[relDialectOf]->(this:VPlang)`. Inverse: {@link VPlang.relDialectOf}. */
  get relDialects() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelDialectOf);
  }

  /** Plangs this Implements. `(this:VPlang)-[relImplements]->VPlang`. Inverse: {@link VPlang.relImplementedBy}. */
  get relImplements() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs implementing this. `VPlang-[relImplements]->(this:VPlang)`. Inverse: {@link VPlang.relImplements}. */
  get relImplementedBy() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelImplements);
  }

  /** Plangs that influenced this. `(this:VPlang)-[relInfluencedBy]->VPlang`. Inverse: {@link VPlang.relInfluenced}. */
  get relInfluencedBy() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Plangs this influenced. `VPlang-[relInfluencedBy]->(this:VPlang)`. Inverse: {@link VPlang.relInfluencedBy}. */
  get relInfluenced() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelInfluencedBy);
  }

  /** Plangs used to implement this. `(this:VPlang)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relUsedToWrite}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Plangs implemented with this. `VPlang-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VPlang.relWrittenWith}. */
  get relUsedToWrite() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.plangRelWrittenWith);
  }

  /** Platforms supported. `(this:VPlang)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relPlangs}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelPlatforms);
  }

  /** Tools for this. `(this:VPlang)-[relTools]->VTool`. Inverse: {@link VTool.relPlangs}. */
  get relTools() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTools);
  }

  /** Type Systems implemented. `(this:VPlang)-[relTypeSystems]->VTypeSystem`. Inverse: {@link VTypeSystem.relPlangs}. */
  get relTypeSystems() {
    return new RelFrom(this as unknown as VPlang, this.graph.edges.plangRelTypeSystems);
  }

  /** Licenses. `VLicense-[relPlangs]->(this:VPlang)`. Inverse: {@link VLicense.relPlangs}. */
  get relLicenses() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.licenseRelPlangs);
  }

  /** Tags. `VTag-[relPlangs]->(this:VPlang)`. Inverse: {@link VTag.relPlangs}. */
  get relTags() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.tagRelPlangs);
  }

  /** Apps implemented with this. `VApp-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VApp.relWrittenWith}. */
  get relApps() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.appRelWrittenWith);
  }

  /** Communities suporting this. `VCommunity-[relPlangs]->(this:VPlang)`. Inverse: {@link VCommunity.relPlangs}. */
  get relCommunities() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.communityRelPlangs);
  }

  /** Learning resources. `VLearning-[relPlangs]->(this:VPlang)`. Inverse: {@link VLearning.relPlangs}. */
  get relLearning() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.learningRelPlangs);
  }

  /** Software Libraries. `VLibrary-[relPlangs]->(this:VPlang)`. Inverse: {@link VLibrary.relPlangs}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelPlangs);
  }

  /** Libraries made with this. `VLibrary-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VLibrary.relWrittenWith}. */
  get relUsedInLibrary() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.libraryRelWrittenWith);
  }

  /** Posts talking about this. `VPost-[relPlangs]->(this:VPlang)`. Inverse: {@link VPost.relPlangs}. */
  get relPosts() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.postRelPlangs);
  }

  /** Tools implemented with this. `VTool-[relWrittenWith]->(this:VPlang)`. Inverse: {@link VTool.relWrittenWith}. */
  get relToolsUsing() {
    return new RelTo(this as unknown as VPlang, this.graph.edges.toolRelWrittenWith);
  }
}

export type VPlatformKey = `plat+${string}`;

/** Platform where Software runs */
export abstract class VPlatformBase extends PlangsVertex<"plat", VPlatformData> {
  static readonly kind = "plat";
  override readonly kind = VPlatformBase.kind;

  static readonly desc = "Platform where Software runs";
  override readonly desc = VPlatformBase.desc;

  /** Plangs supporting this. `VPlang-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VPlang.relPlatforms}. */
  get relPlangs() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.plangRelPlatforms);
  }

  /** Apps supporting this. `VApp-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VApp.relPlatforms}. */
  get relApps() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.appRelPlatforms);
  }

  /** Libraries supporting this. `VLibrary-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VLibrary.relPlatforms}. */
  get relLibraries() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.libraryRelPlatforms);
  }

  /** Tools supporting this. `VTool-[relPlatforms]->(this:VPlatform)`. Inverse: {@link VTool.relPlatforms}. */
  get relTools() {
    return new RelTo(this as unknown as VPlatform, this.graph.edges.toolRelPlatforms);
  }
}

export type VPostKey = `post+${string}`;

/** Blog Post */
export abstract class VPostBase extends PlangsVertex<"post", VPostData> {
  static readonly kind = "post";
  override readonly kind = VPostBase.kind;

  static readonly desc = "Blog Post";
  override readonly desc = VPostBase.desc;

  /** Plangs covered. `(this:VPost)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relPosts}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VPost, this.graph.edges.postRelPlangs);
  }
}

export type VTagKey = `tag+${string}`;

/** Tag */
export abstract class VTagBase extends PlangsVertex<"tag", VTagData> {
  static readonly kind = "tag";
  override readonly kind = VTagBase.kind;

  static readonly desc = "Tag";
  override readonly desc = VTagBase.desc;

  /** Apps tagged. `(this:VTag)-[relApps]->VApp`. Inverse: {@link VApp.relTags}. */
  get relApps() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelApps);
  }

  /** Communities tagged. `(this:VTag)-[relCommunities]->VCommunity`. Inverse: {@link VCommunity.relTags}. */
  get relCommunities() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelCommunities);
  }

  /** Learning resources tagged. `(this:VTag)-[relLearning]->VLearning`. Inverse: {@link VLearning.relTags}. */
  get relLearning() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLearning);
  }

  /** Libraries tagged. `(this:VTag)-[relLibraries]->VLibrary`. Inverse: {@link VLibrary.relTags}. */
  get relLibraries() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelLibraries);
  }

  /** Plangs tagged. `(this:VTag)-[relPlangs]->VPlang`. Inverse: {@link VPlang.relTags}. */
  get relPlangs() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelPlangs);
  }

  /** Tools tagged. `(this:VTag)-[relTools]->VTool`. Inverse: {@link VTool.relTags}. */
  get relTools() {
    return new RelFrom(this as unknown as VTag, this.graph.edges.tagRelTools);
  }
}

export type VToolKey = `tool+${string}`;

/** Programming Tool */
export abstract class VToolBase extends PlangsVertex<"tool", VToolData> {
  static readonly kind = "tool";
  override readonly kind = VToolBase.kind;

  static readonly desc = "Programming Tool";
  override readonly desc = VToolBase.desc;

  /** Plangs supported. `VPlang-[relTools]->(this:VTool)`. Inverse: {@link VPlang.relTools}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTool, this.graph.edges.plangRelTools);
  }

  /** Licenses. `VLicense-[relTools]->(this:VTool)`. Inverse: {@link VLicense.relTools}. */
  get relLicenses() {
    return new RelTo(this as unknown as VTool, this.graph.edges.licenseRelTools);
  }

  /** Tags. `VTag-[relTools]->(this:VTool)`. Inverse: {@link VTag.relTools}. */
  get relTags() {
    return new RelTo(this as unknown as VTool, this.graph.edges.tagRelTools);
  }

  /** Bundles including this. `VBundle-[relTools]->(this:VTool)`. Inverse: {@link VBundle.relTools}. */
  get relBundles() {
    return new RelTo(this as unknown as VTool, this.graph.edges.bundleRelTools);
  }

  /** Platforms supported. `(this:VTool)-[relPlatforms]->VPlatform`. Inverse: {@link VPlatform.relTools}. */
  get relPlatforms() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelPlatforms);
  }

  /** Plangs used to implement this. `(this:VTool)-[relWrittenWith]->VPlang`. Inverse: {@link VPlang.relToolsUsing}. */
  get relWrittenWith() {
    return new RelFrom(this as unknown as VTool, this.graph.edges.toolRelWrittenWith);
  }
}

export type VTypeSystemKey = `tsys+${string}`;

/** Type System */
export abstract class VTypeSystemBase extends PlangsVertex<"tsys", VTypeSystemData> {
  static readonly kind = "tsys";
  override readonly kind = VTypeSystemBase.kind;

  static readonly desc = "Type System";
  override readonly desc = VTypeSystemBase.desc;

  /** Plangs implementing this. `VPlang-[relTypeSystems]->(this:VTypeSystem)`. Inverse: {@link VPlang.relTypeSystems}. */
  get relPlangs() {
    return new RelTo(this as unknown as VTypeSystem, this.graph.edges.plangRelTypeSystems);
  }
}
