import { join } from "node:path";

import { cleanup } from "@plangs/auxiliar/misc";
import { type PlangsGraph, VPlang } from "@plangs/plangs/graph";
import type { TPlangsVertex, TPlangsVertexName } from "@plangs/plangs/graph/generated";
import type { Image } from "@plangs/plangs/graph/vertex_data_schemas";

export const DEFINITIONS_PATH = join(import.meta.dir, "../../definitions/src/definitions");

export function tsLongPath(vertex: TPlangsVertex): string {
  const name = vertex.plainKey.replace(/[^a-zA-Z0-9\_\+\-]/g, "_");
  return join(DEFINITIONS_PATH, vertex.vertexName, vertex.classifier, name, `${name}.ts`);
}

export const tsShortPath = (name: TPlangsVertexName) => join(DEFINITIONS_PATH, `${name}.ts`);

/** Generate code that can reconstruct the state of a single vertex. */
export function vertexCodeGen(vertex: TPlangsVertex): string {
  let other = "";
  // Special handling for VPlang, as we collocate the tools, bundles, libraries and apps.
  if (vertex instanceof VPlang) {
    other = `
    // TOOLS\n
    ${vertex.relTools.values.map(val => genSetter(val)).join("\n\n")}
    // BUNDLES\n
    ${vertex.relBundles.values.map(val => genSetter(val)).join("\n\n")}
    // LIBRARIES\n
    ${vertex.relLibraries.values.map(val => genSetter(val)).join("\n\n")}
    // APPS\n
    ${vertex.relApps.values.map(val => genSetter(val)).join("\n\n")}
  `;
  }
  return `import type { PlangsGraph } from "@plangs/plangs/graph";
  export function define(g: PlangsGraph) {
    ${genSetter(vertex)}
    ${other}
  }`;
}

/** Generates code that can reconstruct a whole collection of vertices. */
export function verticesCodeGen(pg: PlangsGraph, name: TPlangsVertexName): string {
  const vertices = [...pg[name].values];
  return `import type { PlangsGraph } from "@plangs/plangs/graph";
  export function define(g: PlangsGraph) {
    ${vertices.map(v => genSetter(v)).join("\n\n")}
  }`;
}

function genSetter(vertex: TPlangsVertex, genRelations = true) {
  const data = cleanup(vertex.data); // Sort, remove undefined, etc.

  // Remove links to local images, which are generated by the server on data load.
  if ("images" in data && Array.isArray(data.images)) {
    const images = data.images.filter(({ url }: Image) => !url.startsWith("/"));
    if (images.length > 0) data.images = images;
    else delete data.images;
  }

  const relations: string[] = [];

  if (genRelations) {
    // Set of relation names that should be generated.
    const toGenerate = new Set(
      Object.entries(vertex.relConfig)
        .filter(([, { gen }]) => gen)
        .map(([name]) => name),
    );

    for (const [relName, relation] of vertex.relations) {
      if (!toGenerate.has(relName)) continue;
      // We filter self relationships as those are materialized at some point.
      const keys = [...relation.keys].filter(key => key !== vertex.key).sort();
      relations.push(`\n    .${relName}.add(${JSON.stringify(keys).slice(1, -1)})`);
    }
  }

  return `g.${vertex.vertexName}.set(${JSON.stringify(vertex.key)}, ${JSON.stringify(data)})${relations.join("\n")}`;
}
