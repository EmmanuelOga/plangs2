{
  "version": 3,
  "sources": ["../../../node_modules/lodash-es/_freeGlobal.js", "../../../node_modules/lodash-es/_root.js", "../../../node_modules/lodash-es/_Symbol.js", "../../../node_modules/lodash-es/_getRawTag.js", "../../../node_modules/lodash-es/_objectToString.js", "../../../node_modules/lodash-es/_baseGetTag.js", "../../../node_modules/lodash-es/isObjectLike.js", "../../../node_modules/lodash-es/isSymbol.js", "../../../node_modules/lodash-es/_trimmedEndIndex.js", "../../../node_modules/lodash-es/_baseTrim.js", "../../../node_modules/lodash-es/isObject.js", "../../../node_modules/lodash-es/toNumber.js", "../../../node_modules/lodash-es/now.js", "../../../node_modules/lodash-es/debounce.js", "../../../node_modules/preact/src/constants.js", "../../../node_modules/preact/src/util.js", "../../../node_modules/preact/src/options.js", "../../../node_modules/preact/src/create-element.js", "../../../node_modules/preact/src/component.js", "../../../node_modules/preact/src/diff/props.js", "../../../node_modules/preact/src/create-context.js", "../../../node_modules/preact/src/diff/children.js", "../../../node_modules/preact/src/diff/index.js", "../../../node_modules/preact/src/render.js", "../../../node_modules/preact/src/clone-element.js", "../../../node_modules/preact/src/diff/catch-error.js", "../../../node_modules/preact/devtools/src/devtools.js", "../../../node_modules/preact/devtools/src/index.js", "../../../node_modules/preact/debug/src/check-props.js", "../../../node_modules/preact/debug/src/component-stack.js", "../../../node_modules/preact/debug/src/debug.js", "../../../node_modules/preact/debug/src/constants.js", "../../../node_modules/preact/debug/src/util.js", "../../../node_modules/preact/debug/src/index.js", "../../graph/src/auxiliar.ts", "../../graph/src/index.ts", "../../plangs/src/index.ts", "../../../node_modules/preact/jsx-runtime/src/utils.js", "../../../node_modules/preact/src/constants.js", "../../../node_modules/preact/jsx-runtime/src/index.js", "../src/pages/browse.tsx", "../src/pages/dom.ts", "../../frontend/src/utils.ts", "../../../node_modules/preact/hooks/src/index.js", "../../frontend/src/components/input-sel/reducer.ts", "../../frontend/src/components/input-sel/input-sel.tsx", "../../frontend/src/components/input-sel/index.ts", "../../frontend/src/components/input-compl/reducer.ts", "../../frontend/src/components/input-compl/input-compl.tsx", "../../frontend/src/components/input-compl/index.ts", "../../frontend/src/components/pl-info/pl-info.tsx", "../../frontend/src/components/pl-info/index.ts", "../../plangs/src/filter.ts", "../../frontend/src/app/filters.ts", "../../frontend/src/app/livereload.ts", "../../frontend/src/app/index.ts"],
  "sourcesContent": ["/** Detect free variable `global` from Node.js. */\nconst freeGlobal = typeof global === \"object\" && global && global.Object === Object && global;\n\nexport default freeGlobal;\n", "import freeGlobal from \"./_freeGlobal.js\";\n\n/** Detect free variable `self`. */\nconst freeSelf = typeof self === \"object\" && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nconst root = freeGlobal || freeSelf || Function(\"return this\")();\n\nexport default root;\n", "import root from \"./_root.js\";\n\n/** Built-in value references. */\nconst Symbol = root.Symbol;\n\nexport default Symbol;\n", "import Symbol from \"./_Symbol.js\";\n\n/** Used for built-in method references. */\nconst objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nconst hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nconst nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nconst symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  const isOwn = hasOwnProperty.call(value, symToStringTag);\n  const tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    const unmasked = true;\n  } catch (e) {}\n\n  const result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n", "/** Used for built-in method references. */\nconst objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nconst nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n", "import Symbol from \"./_Symbol.js\";\nimport getRawTag from \"./_getRawTag.js\";\nimport objectToString from \"./_objectToString.js\";\n\n/** `Object#toString` result references. */\nconst nullTag = \"[object Null]\";\nconst undefinedTag = \"[object Undefined]\";\n\n/** Built-in value references. */\nconst symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n\nexport default baseGetTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value === \"object\";\n}\n\nexport default isObjectLike;\n", "import baseGetTag from \"./_baseGetTag.js\";\nimport isObjectLike from \"./isObjectLike.js\";\n\n/** `Object#toString` result references. */\nconst symbolTag = \"[object Symbol]\";\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value === \"symbol\" || (isObjectLike(value) && baseGetTag(value) === symbolTag);\n}\n\nexport default isSymbol;\n", "/** Used to match a single whitespace character. */\nconst reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  let index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n", "import trimmedEndIndex from \"./_trimmedEndIndex.js\";\n\n/** Used to match leading whitespace. */\nconst reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n}\n\nexport default baseTrim;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === \"object\" || type === \"function\");\n}\n\nexport default isObject;\n", "import baseTrim from \"./_baseTrim.js\";\nimport isObject from \"./isObject.js\";\nimport isSymbol from \"./isSymbol.js\";\n\n/** Used as references for various `Number` constants. */\nconst NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nconst reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nconst reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nconst reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nconst freeParseInt = Number.parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    const other = typeof value.valueOf === \"function\" ? value.valueOf() : value;\n    value = isObject(other) ? `${other}` : other;\n  }\n  if (typeof value !== \"string\") {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  const isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nexport default toNumber;\n", "import root from \"./_root.js\";\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nconst now = () => root.Date.now();\n\nexport default now;\n", "import isObject from \"./isObject.js\";\nimport now from \"./now.js\";\nimport toNumber from \"./toNumber.js\";\n\n/** Error message constants. */\nconst FUNC_ERROR_TEXT = \"Expected a function\";\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nconst nativeMax = Math.max;\nconst nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  let lastArgs;\n  let lastThis;\n  let maxWait;\n  let result;\n  let timerId;\n  let lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  if (typeof func !== \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = \"maxWait\" in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = \"trailing\" in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || (maxing && timeSinceLastInvoke >= maxWait);\n  }\n\n  function timerExpired() {\n    const time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    const time = now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[] | null} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\t\tsubs = null;\n\t\t\t\t};\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tif (subs) {\n\t\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\n\t\t// Handle unmounting null placeholders, i.e. VNode => null in unkeyed children\n\t\tif (childVNode == null) {\n\t\t\toldVNode = oldChildren[skewedIndex];\n\t\t\tif (\n\t\t\t\toldVNode &&\n\t\t\t\toldVNode.key == null &&\n\t\t\t\toldVNode._dom &&\n\t\t\t\t(oldVNode._flags & MATCHED) === 0\n\t\t\t) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode, false);\n\n\t\t\t\t// Explicitly nullify this position in oldChildren instead of just\n\t\t\t\t// setting `_match=true` to prevent other routines (e.g.\n\t\t\t\t// `findMatchingIndex` or `getDomSibling`) from thinking VNodes or DOM\n\t\t\t\t// nodes in this position are still available to be used in diffing when\n\t\t\t\t// they have actually already been unmounted. For example, by only\n\t\t\t\t// setting `_match=true` here, the unmounting loop later would attempt\n\t\t\t\t// to unmount this VNode again seeing `_match==true`.  Further,\n\t\t\t\t// getDomSibling doesn't know about _match and so would incorrectly\n\t\t\t\t// assume DOM nodes in this subtree are mounted and usable.\n\t\t\t\toldChildren[skewedIndex] = null;\n\t\t\t\tremainingOldChildren--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\tconst matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tchildVNode._index = matchingIndex;\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\t// Our matched DOM-node is further in the list of children than\n\t\t\t\t// where it's at now.\n\n\t\t\t\t// When the remaining old children is bigger than the new-children\n\t\t\t\t// minus our skewed index we know we are dealing with a shrinking list\n\t\t\t\t// we have to increase our skew with the matchedIndex - the skewed index\n\t\t\t\tif (remainingOldChildren > newChildrenLength - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\t// If we have matched all the children just decrease the skew\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - skew) {\n\t\t\t\t\tskew -= matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\t// When our new position is in front of our old position than we increase the skew\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t// match the new skew index (i + new skew)\n\t\t\tif (matchingIndex !== i + skew) {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\n\t\t\t\twhile (oldDom && oldDom.nodeType === 8 && oldDom.nextSibling) {\n\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t}\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (i !== 'key' && !(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\ti !== 'key' &&\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != null) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? null\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { Component, Fragment, options } from 'preact';\n\nexport function initDevTools() {\n\tconst globalVar =\n\t\ttypeof globalThis !== 'undefined'\n\t\t\t? globalThis\n\t\t\t: typeof window !== 'undefined'\n\t\t\t\t? window\n\t\t\t\t: undefined;\n\n\tif (\n\t\tglobalVar !== null &&\n\t\tglobalVar !== undefined &&\n\t\tglobalVar.__PREACT_DEVTOOLS__\n\t) {\n\t\tglobalVar.__PREACT_DEVTOOLS__.attachPreact('10.23.2', options, {\n\t\t\tFragment,\n\t\t\tComponent\n\t\t});\n\t}\n}\n", "import { options } from 'preact';\nimport { initDevTools } from './devtools';\n\ninitDevTools();\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, name: string) => T}\n */\nexport function addHookName(value, name) {\n\tif (options._addHookName) {\n\t\toptions._addHookName(name);\n\t}\n\treturn value;\n}\n", "const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\n/**\n * Reset the history of which prop type warnings have been logged.\n */\nexport function resetPropWarnings() {\n\tloggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * Adapted from https://github.com/facebook/prop-types/blob/master/checkPropTypes.js\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n */\nexport function checkPropTypes(\n\ttypeSpecs,\n\tvalues,\n\tlocation,\n\tcomponentName,\n\tgetStack\n) {\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\n\t\tlet error;\n\t\ttry {\n\t\t\terror = typeSpecs[typeSpecName](\n\t\t\t\tvalues,\n\t\t\t\ttypeSpecName,\n\t\t\t\tcomponentName,\n\t\t\t\tlocation,\n\t\t\t\tnull,\n\t\t\t\tReactPropTypesSecret\n\t\t\t);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t\tif (error && !(error.message in loggedTypeFailures)) {\n\t\t\tloggedTypeFailures[error.message] = true;\n\t\t\tconsole.error(\n\t\t\t\t`Failed ${location} type: ${error.message}${\n\t\t\t\t\t(getStack && `\\n${getStack()}`) || ''\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t});\n}\n", "import { options, Fragment } from 'preact';\n\n/**\n * Get human readable name of the component/dom node\n * @param {import('./internal').VNode} vnode\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) {\n\t\treturn 'Fragment';\n\t} else if (typeof vnode.type == 'function') {\n\t\treturn vnode.type.displayName || vnode.type.name;\n\t} else if (typeof vnode.type == 'string') {\n\t\treturn vnode.type;\n\t}\n\n\treturn '#text';\n}\n\n/**\n * Used to keep track of the currently rendered `vnode` and print it\n * in debug messages.\n */\nlet renderStack = [];\n\n/**\n * Keep track of the current owners. An owner describes a component\n * which was responsible to render a specific `vnode`. This exclude\n * children that are passed via `props.children`, because they belong\n * to the parent owner.\n *\n * ```jsx\n * const Foo = props => <div>{props.children}</div> // div's owner is Foo\n * const Bar = props => {\n *   return (\n *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar\n *   )\n * }\n * ```\n *\n * Note: A `vnode` may be hoisted to the root scope due to compiler\n * optimiztions. In these cases the `_owner` will be different.\n */\nlet ownerStack = [];\n\n/**\n * Get the currently rendered `vnode`\n * @returns {import('./internal').VNode | null}\n */\nexport function getCurrentVNode() {\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\n}\n\n/**\n * If the user doesn't have `@babel/plugin-transform-react-jsx-source`\n * somewhere in his tool chain we can't print the filename and source\n * location of a component. In that case we just omit that, but we'll\n * print a helpful message to the console, notifying the user of it.\n */\nlet showJsxSourcePluginWarning = true;\n\n/**\n * Check if a `vnode` is a possible owner.\n * @param {import('./internal').VNode} vnode\n */\nfunction isPossibleOwner(vnode) {\n\treturn typeof vnode.type == 'function' && vnode.type != Fragment;\n}\n\n/**\n * Return the component stack that was captured up to this point.\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function getOwnerStack(vnode) {\n\tconst stack = [vnode];\n\tlet next = vnode;\n\twhile (next._owner != null) {\n\t\tstack.push(next._owner);\n\t\tnext = next._owner;\n\t}\n\n\treturn stack.reduce((acc, owner) => {\n\t\tacc += `  in ${getDisplayName(owner)}`;\n\n\t\tconst source = owner.__source;\n\t\tif (source) {\n\t\t\tacc += ` (at ${source.fileName}:${source.lineNumber})`;\n\t\t} else if (showJsxSourcePluginWarning) {\n\t\t\tconsole.warn(\n\t\t\t\t'Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.'\n\t\t\t);\n\t\t}\n\t\tshowJsxSourcePluginWarning = false;\n\n\t\treturn (acc += '\\n');\n\t}, '');\n}\n\n/**\n * Setup code to capture the component trace while rendering. Note that\n * we cannot simply traverse `vnode._parent` upwards, because we have some\n * debug messages for `this.setState` where the `vnode` is `undefined`.\n */\nexport function setupComponentStack() {\n\tlet oldDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldRoot = options._root;\n\tlet oldVNode = options.vnode;\n\tlet oldRender = options._render;\n\n\toptions.diffed = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.pop();\n\t\t}\n\t\trenderStack.pop();\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\trenderStack.push(vnode);\n\t\t}\n\t\tif (oldDiff) oldDiff(vnode);\n\t};\n\n\toptions._root = (vnode, parent) => {\n\t\townerStack = [];\n\t\tif (oldRoot) oldRoot(vnode, parent);\n\t};\n\n\toptions.vnode = vnode => {\n\t\tvnode._owner =\n\t\t\townerStack.length > 0 ? ownerStack[ownerStack.length - 1] : null;\n\t\tif (oldVNode) oldVNode(vnode);\n\t};\n\n\toptions._render = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.push(vnode);\n\t\t}\n\n\t\tif (oldRender) oldRender(vnode);\n\t};\n}\n", "import { checkPropTypes } from './check-props';\nimport { options, Component } from 'preact';\nimport {\n\tELEMENT_NODE,\n\tDOCUMENT_NODE,\n\tDOCUMENT_FRAGMENT_NODE\n} from './constants';\nimport {\n\tgetOwnerStack,\n\tsetupComponentStack,\n\tgetCurrentVNode,\n\tgetDisplayName\n} from './component-stack';\nimport { assign, isNaN } from './util';\n\nconst isWeakMapSupported = typeof WeakMap == 'function';\n\n/**\n * @param {import('./internal').VNode} vnode\n * @returns {Array<string>}\n */\nfunction getDomChildren(vnode) {\n\tlet domChildren = [];\n\n\tif (!vnode._children) return domChildren;\n\n\tvnode._children.forEach(child => {\n\t\tif (child && typeof child.type === 'function') {\n\t\t\tdomChildren.push.apply(domChildren, getDomChildren(child));\n\t\t} else if (child && typeof child.type === 'string') {\n\t\t\tdomChildren.push(child.type);\n\t\t}\n\t});\n\n\treturn domChildren;\n}\n\n/**\n * @param {import('./internal').VNode} parent\n * @returns {string}\n */\nfunction getClosestDomNodeParentName(parent) {\n\tif (!parent) return '';\n\tif (typeof parent.type == 'function') {\n\t\tif (parent._parent == null) {\n\t\t\tif (parent._dom != null && parent._dom.parentNode != null) {\n\t\t\t\treturn parent._dom.parentNode.localName;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t\treturn getClosestDomNodeParentName(parent._parent);\n\t}\n\treturn /** @type {string} */ (parent.type);\n}\n\nexport function initDebug() {\n\tsetupComponentStack();\n\n\tlet hooksAllowed = false;\n\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\tlet oldRender = options._render;\n\tlet oldCatchError = options._catchError;\n\tlet oldRoot = options._root;\n\tlet oldHook = options._hook;\n\tconst warnedComponents = !isWeakMapSupported\n\t\t? null\n\t\t: {\n\t\t\t\tuseEffect: new WeakMap(),\n\t\t\t\tuseLayoutEffect: new WeakMap(),\n\t\t\t\tlazyPropTypes: new WeakMap()\n\t\t\t};\n\tconst deprecations = [];\n\n\toptions._catchError = (error, vnode, oldVNode, errorInfo) => {\n\t\tlet component = vnode && vnode._component;\n\t\tif (component && typeof error.then == 'function') {\n\t\t\tconst promise = error;\n\t\t\terror = new Error(\n\t\t\t\t`Missing Suspense. The throwing component was: ${getDisplayName(vnode)}`\n\t\t\t);\n\n\t\t\tlet parent = vnode;\n\t\t\tfor (; parent; parent = parent._parent) {\n\t\t\t\tif (parent._component && parent._component._childDidSuspend) {\n\t\t\t\t\terror = promise;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We haven't recovered and we know at this point that there is no\n\t\t\t// Suspense component higher up in the tree\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\terrorInfo = errorInfo || {};\n\t\t\terrorInfo.componentStack = getOwnerStack(vnode);\n\t\t\toldCatchError(error, vnode, oldVNode, errorInfo);\n\n\t\t\t// when an error was handled by an ErrorBoundary we will nonetheless emit an error\n\t\t\t// event on the window object. This is to make up for react compatibility in dev mode\n\t\t\t// and thus make the Next.js dev overlay work.\n\t\t\tif (typeof error.then != 'function') {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\toptions._root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined parent passed to render(), this is the second argument.\\n' +\n\t\t\t\t\t'Check if the element is available in the DOM/has the correct id.'\n\t\t\t);\n\t\t}\n\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE:\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tisValid = false;\n\t\t}\n\n\t\tif (!isValid) {\n\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a valid HTML node as a second argument to render.\tReceived ${parentNode} instead: render(<${componentName} />, ${parentNode});`\n\t\t\t);\n\t\t}\n\n\t\tif (oldRoot) oldRoot(vnode, parentNode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tlet { type } = vnode;\n\n\t\thooksAllowed = true;\n\n\t\tif (type === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined component passed to createElement()\\n\\n' +\n\t\t\t\t\t'You likely forgot to export your component or might have mixed up default and named imports' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (type != null && typeof type == 'object') {\n\t\t\tif (type._children !== undefined && type._dom !== undefined) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid type passed to createElement(): ${type}\\n\\n` +\n\t\t\t\t\t\t'Did you accidentally pass a JSX literal as JSX twice?\\n\\n' +\n\t\t\t\t\t\t`  let My${getDisplayName(vnode)} = ${serializeVNode(type)};\\n` +\n\t\t\t\t\t\t`  let vnode = <My${getDisplayName(vnode)} />;\\n\\n` +\n\t\t\t\t\t\t'This usually happens when you export a JSX literal and not the component.' +\n\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid type passed to createElement(): ' +\n\t\t\t\t\t(Array.isArray(type) ? 'array' : type)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref !== undefined &&\n\t\t\ttypeof vnode.ref != 'function' &&\n\t\t\ttypeof vnode.ref != 'object' &&\n\t\t\t!('$$typeof' in vnode) // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type == 'string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (\n\t\t\t\t\tkey[0] === 'o' &&\n\t\t\t\t\tkey[1] === 'n' &&\n\t\t\t\t\ttypeof vnode.props[key] != 'function' &&\n\t\t\t\t\tvnode.props[key] != null\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type == 'function' && vnode.type.propTypes) {\n\t\t\tif (\n\t\t\t\tvnode.type.displayName === 'Lazy' &&\n\t\t\t\twarnedComponents &&\n\t\t\t\t!warnedComponents.lazyPropTypes.has(vnode.type)\n\t\t\t) {\n\t\t\t\tconst m =\n\t\t\t\t\t'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';\n\t\t\t\ttry {\n\t\t\t\t\tconst lazyVNode = vnode.type();\n\t\t\t\t\twarnedComponents.lazyPropTypes.set(vnode.type, true);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + `Component wrapped in lazy() is ${getDisplayName(lazyVNode)}`\n\t\t\t\t\t);\n\t\t\t\t} catch (promise) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + \"We will log the wrapped component's name once it is loaded.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet values = vnode.props;\n\t\t\tif (vnode.type._forwarded) {\n\t\t\t\tvalues = assign({}, values);\n\t\t\t\tdelete values.ref;\n\t\t\t}\n\n\t\t\tcheckPropTypes(\n\t\t\t\tvnode.type.propTypes,\n\t\t\t\tvalues,\n\t\t\t\t'prop',\n\t\t\t\tgetDisplayName(vnode),\n\t\t\t\t() => getOwnerStack(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\tlet renderCount = 0;\n\tlet currentComponent;\n\toptions._render = vnode => {\n\t\tif (oldRender) {\n\t\t\toldRender(vnode);\n\t\t}\n\t\thooksAllowed = true;\n\n\t\tconst nextComponent = vnode._component;\n\t\tif (nextComponent === currentComponent) {\n\t\t\trenderCount++;\n\t\t} else {\n\t\t\trenderCount = 1;\n\t\t}\n\n\t\tif (renderCount >= 25) {\n\t\t\tthrow new Error(\n\t\t\t\t`Too many re-renders. This is limited to prevent an infinite loop ` +\n\t\t\t\t\t`which may lock up your browser. The component causing this is: ${getDisplayName(\n\t\t\t\t\t\tvnode\n\t\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\n\t\tcurrentComponent = nextComponent;\n\t};\n\n\toptions._hook = (comp, index, type) => {\n\t\tif (!comp || !hooksAllowed) {\n\t\t\tthrow new Error('Hook can only be invoked from render methods.');\n\t\t}\n\n\t\tif (oldHook) oldHook(comp, index, type);\n\t};\n\n\t// Ideally we'd want to print a warning once per component, but we\n\t// don't have access to the vnode that triggered it here. As a\n\t// compromise and to avoid flooding the console with warnings we\n\t// print each deprecation warning only once.\n\tconst warn = (property, message) => ({\n\t\tget() {\n\t\t\tconst key = 'get' + property + message;\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\n\t\t\t\tdeprecations.push(key);\n\t\t\t\tconsole.warn(`getting vnode.${property} is deprecated, ${message}`);\n\t\t\t}\n\t\t},\n\t\tset() {\n\t\t\tconst key = 'set' + property + message;\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\n\t\t\t\tdeprecations.push(key);\n\t\t\t\tconsole.warn(`setting vnode.${property} is not allowed, ${message}`);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\tconst deprecatedProto = Object.create({}, deprecatedAttributes);\n\n\toptions.vnode = vnode => {\n\t\tconst props = vnode.props;\n\t\tif (\n\t\t\tvnode.type !== null &&\n\t\t\tprops != null &&\n\t\t\t('__source' in props || '__self' in props)\n\t\t) {\n\t\t\tconst newProps = (vnode.props = {});\n\t\t\tfor (let i in props) {\n\t\t\t\tconst v = props[i];\n\t\t\t\tif (i === '__source') vnode.__source = v;\n\t\t\t\telse if (i === '__self') vnode.__self = v;\n\t\t\t\telse newProps[i] = v;\n\t\t\t}\n\t\t}\n\n\t\t// eslint-disable-next-line\n\t\tvnode.__proto__ = deprecatedProto;\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\tconst { type, _parent: parent } = vnode;\n\t\t// Check if the user passed plain objects as children. Note that we cannot\n\t\t// move this check into `options.vnode` because components can receive\n\t\t// children in any shape they want (e.g.\n\t\t// `<MyJSONFormatter>{{ foo: 123, bar: \"abc\" }}</MyJSONFormatter>`).\n\t\t// Putting this check in `options.diffed` ensures that\n\t\t// `vnode._children` is set and that we only validate the children\n\t\t// that were actually rendered.\n\t\tif (vnode._children) {\n\t\t\tvnode._children.forEach(child => {\n\t\t\t\tif (typeof child === 'object' && child && child.type === undefined) {\n\t\t\t\t\tconst keys = Object.keys(child).join(',');\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Objects are not valid as a child. Encountered an object with the keys {${keys}}.` +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (vnode._component === currentComponent) {\n\t\t\trenderCount = 0;\n\t\t}\n\n\t\tif (\n\t\t\ttypeof type === 'string' &&\n\t\t\t(isTableElement(type) ||\n\t\t\t\ttype === 'p' ||\n\t\t\t\ttype === 'a' ||\n\t\t\t\ttype === 'button')\n\t\t) {\n\t\t\t// Avoid false positives when Preact only partially rendered the\n\t\t\t// HTML tree. Whilst we attempt to include the outer DOM in our\n\t\t\t// validation, this wouldn't work on the server for\n\t\t\t// `preact-render-to-string`. There we'd otherwise flood the terminal\n\t\t\t// with false positives, which we'd like to avoid.\n\t\t\tlet domParentName = getClosestDomNodeParentName(parent);\n\t\t\tif (domParentName !== '' && isTableElement(type)) {\n\t\t\t\tif (\n\t\t\t\t\ttype === 'table' &&\n\t\t\t\t\t// Tables can be nested inside each other if it's inside a cell.\n\t\t\t\t\t// See https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced#nesting_tables\n\t\t\t\t\tdomParentName !== 'td' &&\n\t\t\t\t\tisTableElement(domParentName)\n\t\t\t\t) {\n\t\t\t\t\tconsole.log(domParentName, parent._dom);\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <table> should not have a table-node parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\t(type === 'thead' || type === 'tfoot' || type === 'tbody') &&\n\t\t\t\t\tdomParentName !== 'table'\n\t\t\t\t) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\ttype === 'tr' &&\n\t\t\t\t\tdomParentName !== 'thead' &&\n\t\t\t\t\tdomParentName !== 'tfoot' &&\n\t\t\t\t\tdomParentName !== 'tbody'\n\t\t\t\t) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (type === 'td' && domParentName !== 'tr') {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <td> should have a <tr> parent.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t} else if (type === 'th' && domParentName !== 'tr') {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of table. Your <th> should have a <tr>.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (type === 'p') {\n\t\t\t\tlet illegalDomChildrenTypes = getDomChildren(vnode).filter(childType =>\n\t\t\t\t\tILLEGAL_PARAGRAPH_CHILD_ELEMENTS.test(childType)\n\t\t\t\t);\n\t\t\t\tif (illegalDomChildrenTypes.length) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Improper nesting of paragraph. Your <p> should not have ' +\n\t\t\t\t\t\t\tillegalDomChildrenTypes.join(', ') +\n\t\t\t\t\t\t\t'as child-elements.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (type === 'a' || type === 'button') {\n\t\t\t\tif (getDomChildren(vnode).indexOf(type) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`Improper nesting of interactive content. Your <${type}>` +\n\t\t\t\t\t\t\t` should not have other ${type === 'a' ? 'anchor' : 'button'}` +\n\t\t\t\t\t\t\t' tags as child-elements.' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thooksAllowed = false;\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\n\t\tif (vnode._children != null) {\n\t\t\tconst keys = [];\n\t\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\t\tconst child = vnode._children[i];\n\t\t\t\tif (!child || child.key == null) continue;\n\n\t\t\t\tconst key = child.key;\n\t\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Break early to not spam the console\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\tif (vnode._component != null && vnode._component.__hooks != null) {\n\t\t\t// Validate that none of the hooks in this component contain arguments that are NaN.\n\t\t\t// This is a common mistake that can be hard to debug, so we want to catch it early.\n\t\t\tconst hooks = vnode._component.__hooks._list;\n\t\t\tif (hooks) {\n\t\t\t\tfor (let i = 0; i < hooks.length; i += 1) {\n\t\t\t\t\tconst hook = hooks[i];\n\t\t\t\t\tif (hook._args) {\n\t\t\t\t\t\tfor (let j = 0; j < hook._args.length; j++) {\n\t\t\t\t\t\t\tconst arg = hook._args[j];\n\t\t\t\t\t\t\tif (isNaN(arg)) {\n\t\t\t\t\t\t\t\tconst componentName = getDisplayName(vnode);\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index ${i} in component ${componentName} was called with NaN.`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst setState = Component.prototype.setState;\nComponent.prototype.setState = function (update, callback) {\n\tif (this._vnode == null) {\n\t\t// `this._vnode` will be `null` during componentWillMount. But it\n\t\t// is perfectly valid to call `setState` during cWM. So we\n\t\t// need an additional check to verify that we are dealing with a\n\t\t// call inside constructor.\n\t\tif (this.state == null) {\n\t\t\tconsole.warn(\n\t\t\t\t`Calling \"this.setState\" inside the constructor of a component is a ` +\n\t\t\t\t\t`no-op and might be a bug in your application. Instead, set ` +\n\t\t\t\t\t`\"this.state = {}\" directly.\\n\\n${getOwnerStack(getCurrentVNode())}`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn setState.call(this, update, callback);\n};\n\nfunction isTableElement(type) {\n\treturn (\n\t\ttype === 'table' ||\n\t\ttype === 'tfoot' ||\n\t\ttype === 'tbody' ||\n\t\ttype === 'thead' ||\n\t\ttype === 'td' ||\n\t\ttype === 'tr' ||\n\t\ttype === 'th'\n\t);\n}\n\nconst ILLEGAL_PARAGRAPH_CHILD_ELEMENTS =\n\t/^(address|article|aside|blockquote|details|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|main|menu|nav|ol|p|pre|search|section|table|ul)$/;\n\nconst forceUpdate = Component.prototype.forceUpdate;\nComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.forceUpdate\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application.\\n\\n${getOwnerStack(\n\t\t\t\t\tgetCurrentVNode()\n\t\t\t\t)}`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.forceUpdate\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\n\t\t);\n\t}\n\treturn forceUpdate.call(this, callback);\n};\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tfor (let prop in props) {\n\t\tif (props.hasOwnProperty(prop) && prop !== 'children') {\n\t\t\tlet value = props[prop];\n\n\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\tif (typeof value == 'function') {\n\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t}\n\n\t\t\tvalue =\n\t\t\t\tObject(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${\n\t\tchildren && children.length ? '>..</' + name + '>' : ' />'\n\t}`;\n}\n", "export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n", "/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\nexport function isNaN(value) {\n\treturn value !== value;\n}\n", "import { initDebug } from './debug';\nimport 'preact/devtools';\n\ninitDebug();\n\nexport { resetPropWarnings } from './check-props';\n", "/** Two dimensional Map. */\nexport class Map2<K1, K2, V> {\n  #map = new Map<K1, Map<K2, V>>();\n\n  set(k1: K1, k2: K2, v: V): this {\n    let m2 = this.#map.get(k1);\n    if (!m2) {\n      m2 = new Map();\n      this.#map.set(k1, m2);\n    }\n    m2.set(k2, v);\n    return this;\n  }\n\n  get(k1: K1, k2: K2): V | undefined {\n    const m2 = this.#map.get(k1);\n    if (!m2) return undefined;\n    return m2.get(k2);\n  }\n\n  getMap(k1: K1): Map<K2, V> | undefined {\n    return this.#map.get(k1);\n  }\n\n  get size(): number {\n    let size = 0;\n    for (const [_, map] of this.#map) size += map.size;\n    return size;\n  }\n\n  /** Returns an iterator of the keys in the first dimension. */\n  keys(): IterableIterator<K1> {\n    return this.#map.keys();\n  }\n\n  values(): V[] {\n    let values: V[] = [];\n    for (const [_, map] of this.#map) {\n      values = values.concat([...map.values()]);\n    }\n    return values;\n  }\n\n  has(k1: K1, k2: K2): boolean {\n    const m2 = this.#map.get(k1);\n    if (!m2) return false;\n    return m2.has(k2);\n  }\n}\n\n/**\n * Wrapper to work with potentially empty or undefined iterables.\n */\nexport class IterTap<T> implements Iterable<T> {\n  readonly array: T[] | undefined;\n\n  constructor(iterable: Iterable<T> | undefined) {\n    this.array = Array.isArray(iterable) ? iterable : iterable ? [...iterable] : undefined;\n  }\n\n  get first(): T | undefined {\n    return this.array ? this.array[0] : undefined;\n  }\n\n  map<R>(callback: (value: T, index: number, array: T[]) => R) {\n    return this.array ? this.array.map(callback) : [];\n  }\n\n  sort(): T[] {\n    return this.array ? [...this.array].sort() : [];\n  }\n\n  join(str: string): string {\n    return this.array ? this.array.join(str) : \"\";\n  }\n\n  get isEmpty(): boolean {\n    return this.array ? this.array.length === 0 : true;\n  }\n\n  includes(val: T): boolean {\n    return this.array ? this.array.includes(val) : false;\n  }\n\n  some(predicate: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this.array ? this.array.some(predicate) : false;\n  }\n\n  find(predicate: (value: T, index?: number, obj?: T[]) => boolean): T | undefined {\n    return this.array?.find(predicate);\n  }\n\n  get size(): number {\n    return this.array ? this.array.length : 0;\n  }\n\n  tap<R>(callback: (array: T[]) => R): R | undefined {\n    if (this.array && this.array.length > 0) return callback(this.array);\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this.array ? this.array[Symbol.iterator]() : [].values();\n  }\n}\n\n/**\n * Wrapper to work with potentially empty or undefined maps.\n */\nexport class MapTap<K, V> implements Iterable<[K, V]> {\n  constructor(private readonly map?: Map<K, V>) {}\n\n  get size(): number {\n    return this.map ? this.map.size : 0;\n  }\n\n  has(val: K): boolean {\n    return this.map ? this.map.has(val) : false;\n  }\n\n  tap<R>(callback: (tap: this) => R): R | undefined {\n    if (this.map && this.map.size > 0) return callback(this);\n  }\n\n  get keys(): IterTap<K> {\n    return new IterTap(this.map?.keys());\n  }\n\n  get values(): IterTap<V> {\n    return new IterTap(this.map?.values());\n  }\n\n  get entries(): IterTap<[K, V]> {\n    return new IterTap(this.map?.entries());\n  }\n\n  merge(other?: Iterable<[K, V]>): this {\n    if (other && this.map) for (const [key, value] of other) this.map.set(key, value);\n    return this;\n  }\n\n  /** Create a new map wrapped in MapTap from the entries of this one. */\n  toMapTap<NewK, NewV>(callback: (tap: MapTap<NewK, NewV>, key: K, value: V) => void): MapTap<NewK, NewV> {\n    const tap = new MapTap(new Map<NewK, NewV>());\n    for (const [key, value] of this.entries) callback(tap, key, value);\n    return tap;\n  }\n\n  [Symbol.iterator](): Iterator<[K, V]> {\n    return this.map ? this.map[Symbol.iterator]() : [].values();\n  }\n}\n\nexport type Predicate<T> = (v: T) => boolean;\n\n/**\n * A filter that can match any or all of the elements against a predicate.\n */\nexport class Filter<T> {\n  constructor(\n    public mode: \"all\" | \"any\" = \"all\",\n    public readonly values: Set<T> = new Set(),\n  ) {}\n\n  matches(predicate: Predicate<T>): boolean {\n    return this.mode === \"all\" ? this.all(predicate) : this.any(predicate);\n  }\n\n  all(predicate: Predicate<T>): boolean {\n    if (this.values.size === 0) return true;\n    for (const v of this.values) if (!predicate(v)) return false;\n    return true;\n  }\n\n  any(predicate: Predicate<T>): boolean {\n    if (this.values.size === 0) return true;\n    for (const v of this.values) if (predicate(v)) return true;\n    return false;\n  }\n}\n\n/**\n * Insert elements in the array if they are not already present.\n */\nexport function arrayMerge<T>(\n  target: T[],\n  newData: T[],\n  similar: (l1: T, l2: T) => boolean = (l1, l2) => l1 === l2,\n  onDuplicate?: (prevElem: T, newElem: T) => void,\n) {\n  for (const newElem of newData) {\n    const prevElem = target.find((elem: T) => similar(elem, newElem));\n    if (prevElem) {\n      onDuplicate?.(prevElem, newElem);\n    } else {\n      target.push(newElem);\n    }\n  }\n}\n", "/**\n * Simple single-edge directed graph data structure.\n */\n\nimport { IterTap, Map2 } from \"./auxiliar\";\n\n// biome-ignore lint/suspicious/noExplicitAny: we use any for the generic types... sory biome.\ntype Any = any;\n\n/** A type to express empty object. */\nexport type NO_DATA = Record<string, never>;\n\n/** Graph Node. */\nexport abstract class Node<T_Graph, T_Key extends string, T_Data> {\n  /** Sometimes it is useful to know the kind of node. */\n  abstract readonly kind: string;\n\n  readonly data: Partial<T_Data> = {};\n\n  constructor(\n    readonly graph: T_Graph,\n    readonly key: T_Key,\n  ) {}\n\n  /** Shallow merge data. */\n  merge(data: Partial<T_Data>): this {\n    Object.assign(this.data, data);\n    return this;\n  }\n\n  /** The key without the node kind prefix. */\n  get plainKey(): string {\n    return this.key.replace(/^[a-z]+[+]/, \"\");\n  }\n\n  /** The first letter of the key, or \"_\" if it starts with a non-letter. */\n  get keyPrefix(): string {\n    const pk = this.plainKey;\n    return /^[a-z]/.test(pk) ? pk[0] : \"_\";\n  }\n}\n\n/** Graph Edge. */\nexport abstract class Edge<T_Graph, T_From extends Node<T_Graph, Any, Any>, T_To extends Node<T_Graph, Any, Any>, T_Data> {\n  /** Used to construct a key for the edge. */\n  abstract readonly kind: string;\n\n  readonly data: Partial<T_Data> = {};\n\n  constructor(\n    readonly graph: T_Graph,\n    readonly from: T_From[\"key\"],\n    readonly to: T_To[\"key\"],\n  ) {}\n\n  /** Shallow merge data. */\n  merge(data: Partial<T_Data>): this {\n    Object.assign(this.data, data);\n    return this;\n  }\n\n  get key(): string {\n    return `${this.kind}~${this.from}~${this.to}`;\n  }\n}\n\n/** Graph Node Map. */\nexport class NodeMap<T_Graph, T_Node extends Node<T_Graph, Any, Any>> implements Iterable<[T_Node[\"key\"], T_Node]> {\n  readonly #map = new Map<T_Node[\"key\"], T_Node>();\n\n  constructor(private readonly factory: (key: T_Node[\"key\"]) => T_Node) {}\n\n  get(key: T_Node[\"key\"] | undefined): T_Node | undefined {\n    return key ? this.#map.get(key) : undefined;\n  }\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  keys(): IterableIterator<T_Node[\"key\"]> {\n    return this.#map.keys();\n  }\n\n  set(key: T_Node[\"key\"], data: T_Node[\"data\"] = {}): T_Node {\n    let n = this.#map.get(key);\n    if (n === undefined) {\n      n = this.factory(key);\n      this.#map.set(key, n);\n    }\n    return n.merge(data);\n  }\n\n  has(key: T_Node[\"key\"]): boolean {\n    return this.#map.has(key);\n  }\n\n  get values(): IterTap<T_Node> {\n    return new IterTap(this.#map.values());\n  }\n\n  *findAll(predicate: (node: T_Node) => boolean): Generator<T_Node> {\n    for (const node of this.#map.values()) if (predicate(node)) yield node;\n  }\n\n  [Symbol.iterator](n?: number): IterableIterator<[T_Node[\"key\"], T_Node]> {\n    return this.#map[Symbol.iterator]();\n  }\n\n  batch(maxEntries?: number): [T_Node[\"key\"], T_Node][] {\n    return Array.from(this.#map).slice(0, maxEntries);\n  }\n}\n\n/** Stores edges by the compound keys (from, to) and (to, from). */\nexport class EdgeMap<T_Graph, T_Edge extends Edge<T_Graph, Any, Any, Any>> {\n  readonly adjFrom = new Map2<T_Edge[\"from\"], T_Edge[\"to\"], T_Edge>();\n  readonly adjTo = new Map2<T_Edge[\"to\"], T_Edge[\"from\"], T_Edge>();\n\n  constructor(private readonly factory: (from: T_Edge[\"from\"], to: T_Edge[\"to\"]) => T_Edge) {}\n\n  connect(from: T_Edge[\"from\"], to: T_Edge[\"to\"]): T_Edge {\n    let edge = this.adjFrom.get(from, to);\n    if (edge) return edge;\n    edge = this.factory(from, to);\n    this.adjFrom.set(from, to, edge);\n    this.adjTo.set(to, from, edge);\n    return edge;\n  }\n\n  set(from: T_Edge[\"from\"], to: T_Edge[\"to\"], data: T_Edge[\"data\"]): T_Edge {\n    return this.connect(from, to).merge(data);\n  }\n}\n\ntype SerializedGraph<N extends string, E extends string> = {\n  /**\n   * Example: { \"node-a\" : { \"node-a+1\" : data1, \"node-a+2\" : data2, ... } }\n   */\n  nodes: Partial<Record<N, Record<`${N}+${string}`, Any>>>;\n\n  /**\n   * Example: { \"edge-a\" : { \"node-a+1\" : { \"node-b+1\" : data1, \"node-b+2\": data2 }, \"node-a+2\" : ... } }\n   */\n  edges: Partial<Record<E, Record<`${N}+${string}`, Record<`${N}+${string}`, Any>>>>;\n};\n\n/** Base Graph class with the ability to de/serialize registered node and edge maps. */\nexport abstract class BaseGraph<N extends string, E extends string, G> {\n  abstract readonly nodes: Record<N, NodeMap<G, Any>>;\n  abstract readonly edges: Record<E, EdgeMap<G, Any>>;\n\n  get nodeEntries() {\n    return Object.entries(this.nodes) as [N, NodeMap<G, Any>][];\n  }\n\n  get edgeEntries() {\n    return Object.entries(this.edges) as [E, EdgeMap<G, Any>][];\n  }\n\n  get nodeCount(): number {\n    return this.nodeEntries.reduce((acc, [_, map]) => acc + map.size, 0);\n  }\n\n  get edgeCount(): number {\n    return this.edgeEntries.reduce((acc, [_, map]) => acc + map.adjFrom.size, 0);\n  }\n\n  toJSON(): SerializedGraph<N, E> {\n    const data: SerializedGraph<N, E> = { nodes: {}, edges: {} };\n\n    type NK = `${N}+${string}`;\n\n    for (const [name, nodeMap] of this.nodeEntries) {\n      const m = {} as Record<NK, Any>;\n      for (const [key, { data }] of nodeMap) m[key as NK] = data;\n      data.nodes[name] = m;\n    }\n\n    for (const [name, edgeMap] of this.edgeEntries) {\n      const m = {} as Record<NK, Record<NK, Any>>;\n      for (const edge of edgeMap.adjFrom.values()) {\n        const fromMap = (m[edge.from as NK] ??= {} as Record<NK, Any>);\n        fromMap[edge.to as NK] = edge.data;\n      }\n      data.edges[name] = m;\n    }\n\n    return data;\n  }\n\n  loadJSON(data: SerializedGraph<N, E>): this {\n    for (const [name, nodes] of Object.entries(data.nodes)) {\n      const nodeMap = this.nodes[name as N];\n\n      if (!nodes) console.warn(`Data has no nodes for type \"${name}\"`);\n      if (!nodeMap) console.warn(`Graph has no node map for type \"${name}\"`);\n      if (!nodes || !nodeMap) continue;\n\n      for (const [key, nodeData] of Object.entries(nodes)) {\n        nodeMap.set(key).merge(nodeData);\n      }\n    }\n\n    for (const [name, edges] of Object.entries(data.edges)) {\n      const edgeMap = this.edges[name as E];\n\n      if (!edges) console.warn(`Data has no edges for type \"${name}\"`);\n      if (!edgeMap) console.warn(`Graph has no edge map for type \"${name}\"`);\n      if (!edges || !edgeMap) continue;\n\n      for (const [from, tos] of Object.entries(edges)) {\n        for (const [to, edgeData] of Object.entries(tos)) {\n          edgeMap.connect(from, to).merge(edgeData);\n        }\n      }\n    }\n\n    return this;\n  }\n}\n", "import { BaseGraph, Edge, EdgeMap, Node, NodeMap } from \"@plangs/graph\";\nimport { IterTap, MapTap, arrayMerge } from \"@plangs/graph/auxiliar\";\n\nimport type { PlangFilters } from \"./filter\";\n\nexport const NODE_NAMES = [\"app\", \"bundle\", \"lib\", \"license\", \"paradigm\", \"pl\", \"plat\", \"post\", \"tag\", \"tool\", \"tsys\"] as const;\nexport const EDGE_NAMES = [\n  \"bundle\",\n  \"dialect\",\n  \"impl\",\n  \"influence\",\n  \"lib\",\n  \"license\",\n  \"paradigm\",\n  \"plBundle\",\n  \"plat\",\n  \"post\",\n  \"tag\",\n  \"tool\",\n  \"tsys\",\n  \"writtenIn\",\n] as const;\n\nexport type N = (typeof NODE_NAMES)[number];\nexport type E = (typeof EDGE_NAMES)[number];\n\n/** Alias to define types more succinctly. */\nexport type G = PlangsGraph;\n\nexport class PlangsGraph extends BaseGraph<N, E, G> {\n  readonly nodes = {\n    app: new NodeMap<G, NApp>(key => new NApp(this, key)),\n    post: new NodeMap<G, NPost>(key => new NPost(this, key)),\n    bundle: new NodeMap<G, NBundle>(key => new NBundle(this, key)),\n    lib: new NodeMap<G, NLibrary>(key => new NLibrary(this, key)),\n    license: new NodeMap<G, NLicense>(key => new NLicense(this, key)),\n    paradigm: new NodeMap<G, NParadigm>(key => new NParadigm(this, key)),\n    pl: new NodeMap<G, NPlang>(key => new NPlang(this, key)),\n    plat: new NodeMap<G, NPlatform>(key => new NPlatform(this, key)),\n    tag: new NodeMap<G, NTag>(key => new NTag(this, key)),\n    tool: new NodeMap<G, NTool>(key => new NTool(this, key)),\n    tsys: new NodeMap<G, NTsys>(key => new NTsys(this, key)),\n  };\n\n  readonly edges = {\n    app: new EdgeMap<G, EApp>((from, to) => new EApp(this, from, to)),\n    bundle: new EdgeMap<G, EBundle>((from, to) => new EBundle(this, from, to)),\n    dialect: new EdgeMap<G, EDialect>((from, to) => new EDialect(this, from, to)),\n    impl: new EdgeMap<G, EImpl>((from, to) => new EImpl(this, from, to)),\n    influence: new EdgeMap<G, EInfluence>((from, to) => new EInfluence(this, from, to)),\n    lib: new EdgeMap<G, ELib>((from, to) => new ELib(this, from, to)),\n    license: new EdgeMap<G, ELicense>((from, to) => new ELicense(this, from, to)),\n    paradigm: new EdgeMap<G, EParadigm>((from, to) => new EParadigm(this, from, to)),\n    plBundle: new EdgeMap<G, EPlBundle>((from, to) => new EPlBundle(this, from, to)),\n    plat: new EdgeMap<G, EPlat>((from, to) => new EPlat(this, from, to)),\n    post: new EdgeMap<G, EPost>((from, to) => new EPost(this, from, to)),\n    tag: new EdgeMap<G, ETag>((from, to) => new ETag(this, from, to)),\n    tool: new EdgeMap<G, ETool>((from, to) => new ETool(this, from, to)),\n    tsys: new EdgeMap<G, ETsys>((from, to) => new ETsys(this, from, to)),\n    writtenIn: new EdgeMap<G, EWrittenIn>((from, to) => new EWrittenIn(this, from, to)),\n  };\n\n  /** Find all plangs that match the given filters. */\n  plangs(f: PlangFilters, limit = -1): Set<NPlang[\"key\"]> {\n    const keys = new Set<NPlang[\"key\"]>();\n    for (const pl of this.nodes.pl.values) {\n      if (limit >= 0 && keys.size >= limit) break;\n      if (f.matchesAll(pl)) keys.add(pl.key);\n    }\n    return keys;\n  }\n}\n\nexport interface CommonNodeData {\n  name: string;\n  description: string;\n  websites: Link[];\n  keywords: string[];\n}\n\n/** Base type for data on all nodes. */\nexport abstract class NBase<Prefix extends N, Data extends CommonNodeData> extends Node<PlangsGraph, `${Prefix}+${string}`, Data> {\n  get name(): string {\n    return this.data.name ? this.data.name : this.plainKey;\n  }\n\n  get description(): string {\n    return this.data.description || this.name;\n  }\n\n  get websites(): IterTap<Link> {\n    return new IterTap(this.data.websites);\n  }\n\n  get keywords(): IterTap<string> {\n    return new IterTap(this.data.keywords);\n  }\n\n  get keywordsRegexp(): RegExp | undefined {\n    const { keywords } = this.data;\n    if (!keywords) return undefined;\n    const lenient = keywords.map(k => k.replaceAll(/[- ]/g, \"\\\\s*.?\\\\s*\"));\n    return new RegExp(`\\\\b(${lenient.join(\"|\")})\\\\b`, \"i\");\n  }\n\n  addWebsites(links: Link[]): this {\n    arrayMerge((this.data.websites ??= []), links, (l1, l2) => l1.href === l2.href);\n    return this;\n  }\n}\n\n/** A programming language Node. */\nexport class NPlang extends NBase<\n  \"pl\",\n  CommonNodeData & {\n    extensions: string[];\n    firstAppeared: StrDate;\n    images: Image[];\n    isTranspiler: boolean;\n    isMainstream: boolean;\n    releases: Release[];\n  }\n> {\n  override kind: N = \"pl\";\n\n  get extensions(): IterTap<string> {\n    return new IterTap(this.data.extensions);\n  }\n\n  get firstAppeared(): StrDate | undefined {\n    return this.data.firstAppeared;\n  }\n\n  firstAppearedAfter(minDate: StrDate): boolean {\n    return !!this.data.firstAppeared && this.data.firstAppeared >= minDate;\n  }\n\n  get images() {\n    return new IterTap(this.data.images);\n  }\n\n  get thumbUrl(): string | undefined {\n    return (this.images.find(({ kind }) => kind === \"logo\") ?? this.images.first)?.url;\n  }\n\n  get isTranspiler(): boolean {\n    return this.data.isTranspiler === true;\n  }\n\n  get isMainstream(): boolean {\n    return this.data.isMainstream === true;\n  }\n\n  get releases(): IterTap<Release> {\n    return new IterTap(this.data.releases);\n  }\n\n  addExtensions(exts: string[]): this {\n    arrayMerge((this.data.extensions ??= []), exts);\n    return this;\n  }\n\n  addImages(images: Image[]): this {\n    arrayMerge((this.data.images ??= []), images, (i1, i2) => i1.url === i2.url);\n    return this;\n  }\n\n  addReleases(releases: Release[]): this {\n    arrayMerge((this.data.releases ??= []), releases, (r1, r2) => r1.version === r2.version);\n    return this;\n  }\n\n  addDialectOf(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.dialect.connect(this.key, other);\n    return this;\n  }\n\n  addLicenses(others: NLicense[\"key\"][]): this {\n    for (const other of others) this.graph.edges.license.connect(this.key, other);\n    return this;\n  }\n\n  addImplements(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.impl.connect(this.key, other);\n    return this;\n  }\n\n  addInfluencedBy(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.influence.connect(this.key, other);\n    return this;\n  }\n\n  addLibraries(others: NLibrary[\"key\"][]): this {\n    for (const other of others) this.graph.edges.lib.connect(this.key, other);\n    return this;\n  }\n\n  addParadigms(others: NParadigm[\"key\"][]): this {\n    for (const otherkey of others) this.graph.edges.paradigm.connect(this.key, otherkey);\n    return this;\n  }\n\n  addPlatforms(others: NPlatform[\"key\"][]): this {\n    for (const other of others) this.graph.edges.plat.connect(this.key, other);\n    return this;\n  }\n\n  addTags(others: NTag[\"key\"][]): this {\n    for (const other of others) this.graph.edges.tag.connect(this.key, other);\n    return this;\n  }\n\n  addTools(others: NTool[\"key\"][]): this {\n    for (const other of others) this.graph.edges.tool.connect(this.key, other);\n    return this;\n  }\n\n  addTypeSystems(others: NTsys[\"key\"][]): this {\n    for (const other of others) this.graph.edges.tsys.connect(this.key, other);\n    return this;\n  }\n\n  addWrittenIn(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.writtenIn.connect(this.key, other);\n    return this;\n  }\n\n  get relApps(): MapTap<NApp[\"key\"], EApp> {\n    return new MapTap(this.graph.edges.app.adjFrom.getMap(this.key));\n  }\n\n  get relDialectOf(): MapTap<NPlang[\"key\"], EDialect> {\n    return new MapTap(this.graph.edges.dialect.adjFrom.getMap(this.key));\n  }\n\n  get relImplements(): MapTap<NPlang[\"key\"], EImpl> {\n    return new MapTap(this.graph.edges.impl.adjFrom.getMap(this.key));\n  }\n\n  get relInfluenced(): MapTap<NPlang[\"key\"], EImpl> {\n    return new MapTap(this.graph.edges.influence.adjTo.getMap(this.key));\n  }\n\n  get relInfluencedBy(): MapTap<NPlang[\"key\"], EImpl> {\n    return new MapTap(this.graph.edges.influence.adjFrom.getMap(this.key));\n  }\n\n  get relLibs(): MapTap<NLibrary[\"key\"], ELib> {\n    return new MapTap(this.graph.edges.lib.adjFrom.getMap(this.key));\n  }\n\n  get relLicenses(): MapTap<NLicense[\"key\"], ELicense> {\n    return new MapTap(this.graph.edges.license.adjFrom.getMap(this.key));\n  }\n\n  get relParadigms(): MapTap<NParadigm[\"key\"], EParadigm> {\n    return new MapTap(this.graph.edges.paradigm.adjFrom.getMap(this.key));\n  }\n\n  get relPlBundles(): MapTap<NBundle[\"key\"], EPlBundle> {\n    return new MapTap(this.graph.edges.plBundle.adjFrom.getMap(this.key));\n  }\n\n  get relPlatforms(): MapTap<NPlatform[\"key\"], EPlat> {\n    return new MapTap(this.graph.edges.plat.adjFrom.getMap(this.key));\n  }\n\n  get relTags(): MapTap<NTag[\"key\"], ETag> {\n    return new MapTap(this.graph.edges.tag.adjFrom.getMap(this.key));\n  }\n\n  get relTools(): MapTap<NTool[\"key\"], ETool> {\n    return new MapTap(this.graph.edges.tool.adjFrom.getMap(this.key));\n  }\n\n  get relTsys(): MapTap<NTsys[\"key\"], ETsys> {\n    return new MapTap(this.graph.edges.tsys.adjFrom.getMap(this.key));\n  }\n\n  get relWrittenIn(): MapTap<NPlang[\"key\"], EWrittenIn> {\n    return new MapTap(this.graph.edges.writtenIn.adjFrom.getMap(this.key));\n  }\n\n  get relPosts(): MapTap<NPost[\"key\"], EPost> {\n    return new MapTap(this.graph.edges.post.adjFrom.getMap(this.key));\n  }\n}\n\n/** A library Node, for software libraries or frameworks, like jQuery, Rails, etc. */\nexport class NLibrary extends NBase<\"lib\", CommonNodeData> {\n  override kind: N = \"lib\";\n\n  addPls(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.lib.connect(other, this.key);\n    return this;\n  }\n}\n\n/** A License Node, e.g., MIT, GPL, etc. */\nexport class NLicense extends NBase<\n  \"license\",\n  CommonNodeData & {\n    /** spdx: The SPDX identifier from https://spdx.org/licenses/. */\n    spdx?: string;\n\n    /** Wether the license is recognized as Free/Libre by the Free Software Foundation (FSF). */\n    isFSFLibre?: boolean;\n\n    /** Wether the license is approved by the Open Source Initiative (OSI).*/\n    isOSIApproved?: boolean;\n  }\n> {\n  override kind: N = \"license\";\n\n  get spdx(): string | undefined {\n    return this.data.spdx;\n  }\n\n  get isFSFLibre(): boolean {\n    return this.data.isFSFLibre === true;\n  }\n\n  get isOSIApproved(): boolean {\n    return this.data.isOSIApproved === true;\n  }\n}\n\n/** A Paradigm Node, e.g., Functional, Imperative, etc. */\nexport class NParadigm extends NBase<\"paradigm\", CommonNodeData> {\n  override kind: N = \"paradigm\";\n}\n\n/** A Platform Node for operating systems or architectures, e.g., Linux, Windows, ARM etc. */\nexport class NPlatform extends NBase<\"plat\", CommonNodeData> {\n  override kind: N = \"plat\";\n}\n\n/** A generic tag. */\nexport class NTag extends NBase<\"tag\", CommonNodeData> {\n  override kind: N = \"tag\";\n}\n\n/** A tool Node, e.g., Version Manager, Linter, Formatter,  etc. */\nexport class NTool extends NBase<\"tool\", CommonNodeData> {\n  override kind: N = \"tool\";\n\n  addPls(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.tool.connect(other, this.key);\n    return this;\n  }\n}\n\n/** A Type System Node, e.g., OOP, Duck, Dynamic, etc. */\nexport class NTsys extends NBase<\"tsys\", CommonNodeData> {\n  override kind: N = \"tsys\";\n}\n\n/** An app Node, for any sort of application. */\nexport class NApp extends NBase<\"app\", CommonNodeData> {\n  override kind: N = \"app\";\n\n  addPls(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.app.connect(other, this.key);\n    return this;\n  }\n}\n\n/** Bundle of tools. */\nexport class NBundle extends NBase<\"bundle\", CommonNodeData> {\n  override kind: N = \"bundle\";\n\n  addTools(others: `tool+${string}`[]): this {\n    for (const other of others) this.graph.edges.bundle.connect(this.key, other);\n    return this;\n  }\n\n  addPls(others: NPlang[\"key\"][]): this {\n    for (const other of others) this.graph.edges.plBundle.connect(other, this.key);\n    return this;\n  }\n\n  get relTools(): MapTap<NTool[\"key\"], EBundle> {\n    return new MapTap(this.graph.edges.bundle.adjFrom.getMap(this.key));\n  }\n\n  get relPls(): MapTap<NPlang[\"key\"], EPlBundle> {\n    return new MapTap(this.graph.edges.plBundle.adjTo.getMap(this.key));\n  }\n}\n\n/**\n * A blog post entry.\n * Repurposes the `websites` field to point to plangs blog posts.\n * The blog posts are scanned at build time and added to the graph.\n */\nexport class NPost extends NBase<\"post\", CommonNodeData & { path: string; title: string; author: string; date: StrDate }> {\n  override kind: N = \"post\";\n\n  get author(): string | undefined {\n    return this.data.author;\n  }\n\n  get path(): string | undefined {\n    return this.data.path;\n  }\n\n  get title(): string | undefined {\n    return this.data.title;\n  }\n\n  get date(): StrDate | undefined {\n    return this.data.date;\n  }\n\n  set link(link: Link) {\n    this.data.websites = [link];\n  }\n\n  get link(): Link | undefined {\n    return this.websites.first;\n  }\n\n  addPls(others: `pl+${string}`[]) {\n    for (const other of others) this.graph.edges.post.connect(other, this.key);\n    return this;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Edge Types\n////////////////////////////////////////////////////////////////////////////////\n\nexport interface CommonEdgeData {\n  refs: Link[];\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: we use any for the generic types... sory biome.\ntype Any = any;\n\n/** Base type for data on all edges. */\nexport abstract class EBase<T_From extends NBase<Any, Any>, T_To extends NBase<Any, Any>, T_Data extends CommonEdgeData> extends Edge<\n  PlangsGraph,\n  T_From,\n  T_To,\n  T_Data\n> {\n  addRefs(links: Link[]): this {\n    arrayMerge((this.data.refs ??= []), links, (l1, l2) => l1.href === l2.href);\n    return this;\n  }\n}\n\nexport class EApp extends EBase<NPlang, NApp, CommonEdgeData> {\n  override kind: E = \"bundle\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get app(): NApp | undefined {\n    return this.graph.nodes.app.get(this.to);\n  }\n}\n\n/** Edge from a tool to a bundle. */\nexport class EBundle extends EBase<NBundle, NTool, CommonEdgeData> {\n  override kind: E = \"bundle\";\n\n  get bundle(): NBundle | undefined {\n    return this.graph.nodes.bundle.get(this.from);\n  }\n\n  get tool(): NTool | undefined {\n    return this.graph.nodes.tool.get(this.to);\n  }\n}\n\nexport class EDialect extends EBase<NPlang, NPlang, CommonEdgeData> {\n  override kind: E = \"dialect\";\n\n  get fromPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get toPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.to);\n  }\n}\n\nexport class ELicense extends EBase<NPlang, NLicense, CommonEdgeData> {\n  override kind: E = \"license\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get license(): NLicense | undefined {\n    return this.graph.nodes.license.get(this.to);\n  }\n}\n\nexport class EImpl extends EBase<NPlang, NPlang, CommonEdgeData> {\n  override kind: E = \"impl\";\n\n  get fromPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get toPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.to);\n  }\n}\n\nexport class EInfluence extends EBase<NPlang, NPlang, CommonEdgeData> {\n  override kind: E = \"influence\";\n\n  get fromPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get toPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.to);\n  }\n}\n\nexport class EParadigm extends EBase<NPlang, NParadigm, CommonEdgeData> {\n  override kind: E = \"paradigm\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get paradigm(): NParadigm | undefined {\n    return this.graph.nodes.paradigm.get(this.to);\n  }\n}\n\nexport class ETsys extends EBase<NPlang, NTsys, CommonEdgeData> {\n  override kind: E = \"tsys\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get tsys(): NTsys | undefined {\n    return this.graph.nodes.tsys.get(this.to);\n  }\n}\n\n/** Edge from a PLang to a Bundle. */\nexport class EPlBundle extends EBase<NPlang, NBundle, CommonEdgeData> {\n  override kind: E = \"plBundle\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get bundle(): NBundle | undefined {\n    return this.graph.nodes.bundle.get(this.to);\n  }\n}\n\nexport class EPlat extends EBase<NPlang, NPlatform, CommonEdgeData> {\n  override kind: E = \"plat\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get plat(): NPlatform | undefined {\n    return this.graph.nodes.plat.get(this.to);\n  }\n}\n\nexport class EPost extends EBase<NPlang, NPost, CommonEdgeData> {\n  override kind: E = \"post\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get post(): NPost | undefined {\n    return this.graph.nodes.post.get(this.to);\n  }\n}\n\nexport class ELib extends EBase<NPlang, NLibrary, CommonEdgeData> {\n  override kind: E = \"lib\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get lib(): NLibrary | undefined {\n    return this.graph.nodes.lib.get(this.to);\n  }\n}\n\nexport class ETag extends EBase<NPlang, NTag, CommonEdgeData> {\n  override kind: E = \"tag\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get tag(): NTag | undefined {\n    return this.graph.nodes.tag.get(this.to);\n  }\n}\n\nexport class ETool extends EBase<NPlang, NTool, CommonEdgeData> {\n  override kind: E = \"tool\";\n\n  get pl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get tool(): NTool | undefined {\n    return this.graph.nodes.tool.get(this.to);\n  }\n}\n\nexport class EWrittenIn extends EBase<NPlang, NPlang, CommonEdgeData> {\n  override kind: E = \"writtenIn\";\n\n  get fromPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.from);\n  }\n\n  get toPl(): NPlang | undefined {\n    return this.graph.nodes.pl.get(this.to);\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Auxiliary Types\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A release of a programming language.\n */\nexport interface Release {\n  version: string;\n  name?: string;\n  date?: StrDate;\n}\n\n/**\n * A reference to a web page.\n */\nexport interface Link {\n  kind?: \"homepage\" | \"repository\" | \"releases\" | \"apidocs\" | \"wikipedia\" | \"plangs\" | \"other\";\n  href: string;\n  title: string;\n}\n\n/**\n * An image, e.g., a logo.\n */\nexport interface Image {\n  kind: \"logo\" | \"screenshot\" | \"other\";\n  title: string;\n  url: string;\n  width?: number;\n  height?: number;\n}\n\n/**\n * A serializable date string.\n */\nexport type year = number;\nexport type month = string; // 0 padded\nexport type day = string; // 0 padded\nexport type StrDate = `${year}-${month}-${day}`;\n", "const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (typeof normalizedProps[i] === 'undefined') {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + str + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities(value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n", "import { type ComponentChildren, h } from \"preact\";\n\nimport { PlThumb } from \"@plangs/frontend/components/misc/pl-thumb\";\nimport { style, tw } from \"@plangs/frontend/utils\";\nimport type { PlangsGraph } from \"@plangs/plangs\";\n\nimport { cssId } from \"./dom\";\n\nexport function Browse({ pg }: { pg: PlangsGraph }) {\n  return (\n    <>\n      <aside\n        id={cssId(\"filters\")}\n        class={tw(\n          \"max-h-[33dvh]\",\n          \"z-10\",\n          \"grid grid-cols-2\",\n          \"gap-3 px-3 pt-2\",\n          \"border-background border-b-4\",\n          \"overflow-hidden overflow-y-auto\",\n          \"shadow-background/75 shadow-md\",\n        )}>\n        {Object.entries(INPUT_GROUPS).map(([key, group]) => (\n          <div key={key}>\n            {group.map(({ title, keys }) => (\n              <InputGroup key={title} title={title} children={keys.map(renderInput)} />\n            ))}\n          </div>\n        ))}\n      </aside>\n      <article\n        id={cssId(\"plGrid\")}\n        class={tw(\"flex-initial\", \"grid grid-cols-[repeat(auto-fit,minmax(5rem,1fr))] gap-3\", \"px-2 pt-1.5 pb-2\", \"overflow-hidden overflow-y-auto\")}>\n        {pg.nodes.pl.batch().map(([key, pl]) => (\n          <PlThumb key={key} pl={pl} />\n        ))}\n      </article>\n\n      {/* Filler */}\n      <div class=\"flex-auto\" />\n\n      <aside class=\"hidden\">{h(\"pl-info\", {})}</aside>\n    </>\n  );\n}\n\nfunction InputGroup({ title, children }: { title: string; children: ComponentChildren }) {\n  return (\n    <details\n      class={tw(\n        \"group\",\n        \"mb-3 p-1 last:mb-1\",\n        \"-skew-y-5 rotate-5\",\n        \"open:-skew-y-1 open:rotate-1\",\n        \"ring-1 ring-secondary\",\n        \"bg-gradient-to-br from-white/95 to-white text-slate-800\",\n      )}>\n      <summary class={tw(\"p-0.5\", \"text-sm\", \"group-open:mb-2\", \"bg-secondary text-foreground\")}>{title}</summary>\n      {children}\n    </details>\n  );\n}\n\nfunction renderInput(key: keyof typeof INPUT_PROPS) {\n  const { label, input } = INPUT_PROPS[key];\n\n  const inputTextColor = \"text-slate-800 placeholder:text-slate-800/50\";\n  const inputProps = {\n    name: key,\n    id: cssId(key),\n    class: tw(inputTextColor, input.kind === \"checkbox\" ? \"-mt-1\" : \"w-full\"),\n  };\n\n  let inputElem = <input {...inputProps} type={input.kind} />;\n  if (input.kind === \"checkbox\") inputElem = <input {...inputProps} type=\"checkbox\" />;\n  if (input.kind === \"compl\") inputElem = h(\"input-compl\", { ...inputProps, \"data-kind\": input.nodeMap } as Record<string, string>);\n\n  const showSel = input.kind === \"compl\" || (input.kind === \"search\" && \"inputSel\" in input && input.inputSel);\n  return (\n    <div class={tw(\"[&_select]:text-center\")}>\n      <label for={inputProps.id} class={tw(\"block h-full pb-1.5\")}>\n        {input.kind === \"checkbox\" ? (\n          <>\n            {inputElem}\n            {label}\n          </>\n        ) : (\n          <>\n            <div>{label}</div>\n            {inputElem}\n          </>\n        )}\n      </label>\n      {showSel &&\n        h(\"input-sel\", {\n          name: key,\n          class: tw(\"w-full text-center\", inputTextColor, \"[&_.item]:text-left\"),\n        })}\n    </div>\n  );\n}\n\n/** Configure for every kind of input: its label, its kind, etc. */\nexport const INPUT_PROPS = {\n  plangName: { label: \"Lang Name\", input: { kind: \"search\" } },\n  extensions: { label: \"File Extension\", input: { kind: \"search\", inputSel: true } },\n\n  appearedAfter: { label: \"Appeared After\", input: { kind: \"month\" } },\n  releasedAfter: { label: \"Released After\", input: { kind: \"month\" } },\n\n  hasLogo: { label: \"Has Logo\", input: { kind: \"checkbox\" } },\n  hasReleases: { label: \"Known Releases\", input: { kind: \"checkbox\" } },\n  hasWikipedia: { label: \"Has Wikipedia\", input: { kind: \"checkbox\" } },\n  isMainstream: { label: \"Is Mainstream\", input: { kind: \"checkbox\" } },\n  isTranspiler: { label: \"Is Transpiler\", input: { kind: \"checkbox\" } },\n\n  dialectOf: { label: \"Dialect Of\", input: { kind: \"compl\", nodeMap: \"pl\" } },\n  implements: { label: \"Implements\", input: { kind: \"compl\", nodeMap: \"pl\" } },\n  influenced: { label: \"Influenced\", input: { kind: \"compl\", nodeMap: \"pl\" } },\n  influencedBy: { label: \"Influenced By\", input: { kind: \"compl\", nodeMap: \"pl\" } },\n  licenses: { label: \"Licenses\", input: { kind: \"compl\", nodeMap: \"license\" } },\n  paradigms: { label: \"Paradigms\", input: { kind: \"compl\", nodeMap: \"paradigm\" } },\n  platforms: { label: \"Platforms\", input: { kind: \"compl\", nodeMap: \"plat\" } },\n  tags: { label: \"Tags\", input: { kind: \"compl\", nodeMap: \"tag\" } },\n  typeSystems: { label: \"Type System\", input: { kind: \"compl\", nodeMap: \"tsys\" } },\n  writtenIn: { label: \"Written In\", input: { kind: \"compl\", nodeMap: \"pl\" } },\n} as const;\n\nconst INPUT_GROUPS = {\n  column1: [\n    { title: \"Name/File Ext.\", keys: [\"plangName\", \"extensions\"] },\n    { title: \"Releases/Dates\", keys: [\"hasReleases\", \"releasedAfter\", \"appearedAfter\"] },\n    { title: \"License\", keys: [\"licenses\"] },\n    { title: \"Logo/Wikipedia\", keys: [\"hasLogo\", \"hasWikipedia\"] },\n  ],\n  column2: [\n    { title: \"Popular/Transp\", keys: [\"isMainstream\", \"isTranspiler\"] },\n    { title: \"Features\", keys: [\"typeSystems\", \"paradigms\", \"platforms\", \"tags\"] },\n    { title: \"Influences\", keys: [\"influenced\", \"influencedBy\"] },\n    { title: \"Lineage\", keys: [\"dialectOf\", \"implements\", \"writtenIn\"] },\n  ],\n} as const;\n", "import { INPUT_PROPS } from \"./browse\";\n\n/**\n * Utilities to type check DOM \"id\" and \"class\" attributes\n * that are used in both the frontend and the backend.\n */\nexport const FILTER_KEY = Object.keys(INPUT_PROPS) as (keyof typeof INPUT_PROPS)[];\nexport const ID_KEYS = [\"todo\", \"plGrid\", \"filterToggle\", \"filters\", ...FILTER_KEY] as const;\nexport const CL_KEYS = [\"todo\", \"plThumb\"] as const;\n\nexport type IDKey = (typeof ID_KEYS)[number];\nexport type CLKey = (typeof CL_KEYS)[number];\n\nexport function cssId(key: IDKey): `id-${IDKey}` {\n  return `id-${key}`;\n}\n\nexport function cssCl(key: CLKey): `cl-${CLKey}` {\n  return `cl-${key}`;\n}\n", "import { type JSX, h } from \"preact\";\n\nimport { type CLKey, type IDKey, cssCl, cssId } from \"@plangs/server/pages/dom\";\n\nexport type Nil = null | undefined;\n\n// SSR compatibility\nconst doc = (typeof document === \"undefined\" ? undefined : document) as Document;\nconst win = (typeof window === \"undefined\" ? undefined : window) as Window;\n\nexport const $ = doc?.querySelector.bind(document);\nexport const $$ = doc?.querySelectorAll.bind(document);\n\nexport const elem = (key: IDKey) => $<HTMLElement>(`#${cssId(key)}`) ?? undefined;\nexport const elems = (key: CLKey) => $$<HTMLElement>(`.${cssCl(key)}`);\n\n/** Adds an event listener to the target, and returns a function to undo the listener. */\nexport function on<T>(target: Element | Nil, type: string, listener: (ev: T) => void, opt?: AddEventListenerOptions): () => void {\n  if (!target) console.warn(\"missing target\", { type, listener, opt });\n  target?.addEventListener(type, listener as EventListener, opt);\n  return target ? () => off(target, type, listener, opt) : () => {};\n}\n\nexport function off<T>(target: Element | Nil, type: string, listener: (ev: T) => void, opt?: AddEventListenerOptions): void {\n  if (!target) console.warn(\"missing target\", { type, listener, opt });\n  target?.removeEventListener(type, listener as EventListener, opt);\n}\n\nexport function send<T extends Event>(target: Element | Nil, ev: T): boolean | undefined {\n  if (!target) console.warn(\"missing target\", ev);\n  return target?.dispatchEvent(ev);\n}\n\nexport function customEvent<T>(type: string, detail: T, options: CustomEventInit<T> = { bubbles: true, composed: true }) {\n  return new CustomEvent(type, { detail, ...options });\n}\n\nexport function size(el: HTMLElement): [number, number] {\n  const style = getComputedStyle(el);\n  return [Number.parseInt(style.width), Number.parseInt(style.height)];\n}\n\n/** Collect tailwind classes. Passing a number adds an outline and bg color. */\nexport const tw = (...classes: (string | undefined | boolean)[]) => classes.filter(s => typeof s === \"string\" && !/^;|;$/.test(s)).join(\" \");\n\n/** Check if the current windows matches TW's md breakpoint. */\nexport const twBreakMd = () => win?.matchMedia(`(min-width: ${TW_md})`).matches ?? false;\nconst TW_md = \"48rem\"; // We could resolve this from TW's config, but this works fine for now.\n\nexport const script = (src: string) => tag(\"script\", src);\nexport const style = (src: string) => tag(\"style\", src);\nexport const tag = (tag: \"script\" | \"style\", __html: string) => h(tag, { dangerouslySetInnerHTML: { __html } });\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "export type State = {\n  inputName: string;\n  cssClass?: string;\n  selected: Item[];\n  onAdd: (item: Item) => void;\n  onRemove: (data: ItemRemoved) => void;\n};\n\nexport type Item = {\n  value: unknown;\n  label: string;\n};\n\nexport type ItemRemoved = {\n  by: \"click\" | \"enterKey\";\n  index: number;\n  inputName: string;\n  item: Item;\n  itemsLeft: number;\n};\n\nexport type ActionUpdate = { kind: \"update\"; inputName: string; cssClass?: string };\nexport type ActionAdd = { kind: \"add\"; item: Item };\nexport type ActionRemove = { kind: \"remove\"; value: Item[\"value\"]; by: ItemRemoved[\"by\"] };\nexport type Actions = ActionAdd | ActionRemove | ActionUpdate;\n\nexport function reducer(state: State, action: Actions): State {\n  const { selected } = state;\n\n  if (action.kind === \"add\") {\n    const existing = selected.find(({ value }) => value === action.item.value);\n    if (existing) return state;\n    state.onAdd(action.item);\n    return { ...state, selected: [...selected, action.item] };\n  }\n\n  if (action.kind === \"remove\") {\n    let idx: number | undefined;\n    const filtered = selected.filter(({ value }, index) => {\n      if (value !== action.value) return true;\n      idx = index;\n      return false;\n    });\n    if (idx === undefined) return state;\n    state.onRemove({\n      index: idx,\n      item: selected[idx],\n      itemsLeft: filtered.length,\n      by: action.by,\n      inputName: state.inputName,\n    });\n    return { ...state, selected: filtered };\n  }\n\n  if (action.kind === \"update\") {\n    return { ...state, inputName: action.inputName, cssClass: action.cssClass };\n  }\n\n  return state;\n}\n", "import type { Ref } from \"preact\";\nimport { useEffect, useReducer, useRef } from \"preact/hooks\";\n\nimport { customEvent, on, send } from \"../../utils\";\n\nimport { type Item, type ItemRemoved, reducer } from \"./reducer\";\n\nexport const TAG_NAME = \"input-sel\";\n\nexport type InputSelProps = {\n  name: string;\n  class?: string;\n};\n\nexport function InputSel({ name, class: cssClass }: InputSelProps) {\n  const self = useRef<HTMLDivElement>();\n  const lastRemoved = useRef<ItemRemoved>();\n\n  const [state, dispatch] = useReducer(reducer, {\n    inputName: name,\n    selected: [],\n    onAdd() {\n      send(self.current?.parentElement, EVENTS.outInput.create());\n    },\n    onRemove(data: ItemRemoved) {\n      lastRemoved.current = data;\n      send(self.current?.parentElement, EVENTS.outRemove.create(data));\n      send(self.current?.parentElement, EVENTS.outInput.create());\n    },\n  });\n\n  useEffect(() => {\n    dispatch({ kind: \"update\", inputName: name, cssClass });\n  }, [name, cssClass]);\n\n  // Setup event listener to add items.\n  useEffect(() => {\n    const root = self.current?.parentElement;\n    if (!root) return;\n    const handler = (ev: CustomEvent) => {\n      if (!EVENTS.inAdd.valid(ev)) return console.warn(\"Invalid event data on:\", ev);\n      dispatch({ kind: \"add\", item: ev.detail as Item });\n    };\n    return on(root, EVENTS.inAdd.type, handler);\n  });\n\n  // Handle focus after removing an item.\n  useEffect(() => {\n    if (!lastRemoved.current || !self.current) return;\n    const { by, index, itemsLeft } = lastRemoved.current;\n    if (by === \"enterKey\" && itemsLeft > 0) {\n      const i = index < itemsLeft ? index : itemsLeft - 1;\n      const div = self.current.querySelector(`.remove-item:nth-child(${i + 1})`) as HTMLDivElement;\n      div?.focus();\n    }\n    lastRemoved.current = undefined;\n  });\n\n  return (\n    <div ref={self as Ref<HTMLDivElement>} class={cssClass}>\n      {state.selected.length > 1 && (\n        <select title=\"Match all or any of the elements\">\n          <option value=\"any\">Any of</option>\n          <option value=\"all\">All of</option>\n        </select>\n      )}\n      {state.selected.map(({ value, label }) => (\n        <div\n          key={value}\n          class=\"item\"\n          tabindex={0}\n          data-value={value}\n          onClick={() => dispatch({ kind: \"remove\", value, by: \"click\" })}\n          onKeyDown={ev => {\n            if (ev.key === \"Enter\") dispatch({ kind: \"remove\", value, by: \"enterKey\" });\n          }}>\n          <span aria-label=\"remove\">\u274C</span>\n          {label}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n/** Catalog of incoming and outgoing events, and factory functions for those events. */\nexport const EVENTS = {\n  /** Incoming event: request to add an item. */\n  inAdd: {\n    type: `${TAG_NAME}:in-add\"`,\n    create: (item: Item) => customEvent(EVENTS.inAdd.type, item),\n    /** Validate data extracted from a CustomEvent detail field. */\n    valid: ({ detail }: CustomEvent) => \"value\" in detail && typeof detail.label === \"string\",\n  },\n\n  /** Outgoing event: an item has been removed. */\n  outRemove: {\n    type: `${TAG_NAME}:out-item-removed\"`,\n    create: (detail: ItemRemoved) => customEvent(EVENTS.outRemove.type, detail),\n  },\n\n  outInput: {\n    /** Emits an standard \"input\" event on input change. */\n    type: \"input\",\n    create: () => new Event(EVENTS.outInput.type, { bubbles: true, composed: true }),\n  },\n};\n", "/**\n * <input-sel> Custom Element: keeps track of selected items.\n */\n\nimport register from \"preact-custom-element\";\n\nimport { $, on, send } from \"../../utils\";\nimport { EVENTS, InputSel, type InputSelProps, TAG_NAME } from \"./input-sel\";\nimport type { Item, ItemRemoved } from \"./reducer\";\n\nexport { TAG_NAME };\nexport type { Item, ItemRemoved };\n\n/** Additional methods for the custom element. */\nconst ELEMENT_API = {\n  /** Send an event request the item to be added. */\n  addItem(this: HTMLElement, item: Item): void {\n    send(this, EVENTS.inAdd.create(item));\n  },\n\n  /** Add a handler to do something when an item is removed. */\n  onRemove(this: HTMLElement, cb: (item: ItemRemoved) => void) {\n    on(this, EVENTS.outRemove.type, ({ detail }: CustomEvent) => cb(detail as ItemRemoved));\n  },\n\n  /** Get the values/keys of the selected items. */\n  values(this: HTMLElement): { mode: \"all\" | \"any\"; values: Set<string> } {\n    const mode = this.querySelector(\"select\")?.value === \"any\" ? \"any\" : \"all\";\n    const values = [...this.querySelectorAll(\".remove-item\")].map(el => el.getAttribute(\"data-value\")).filter(v => v) as string[];\n    return { mode, values: new Set(values) };\n  },\n};\n\n/** Convention: both <input-sel/> and it's source input element should have matching \"name\" attribute. */\nexport function matchingInputSelByName(elem: HTMLElement): InputSelElement | null {\n  const name = elem.getAttribute(\"name\");\n  const inputSel = $<InputSelElement>(`input-sel[name=${name}]`);\n  if (!name || !inputSel) {\n    console.warn(\"Coud not find a matching <input-sel/> by name\", elem, name);\n  }\n  return inputSel;\n}\n\nexport type InputSelElement = HTMLElement & typeof ELEMENT_API & InputSelProps;\n\n/** Register the Custom Element. */\nexport function registerInputSel() {\n  const keys: (keyof InputSelProps)[] = [\"name\"];\n  register(InputSel, TAG_NAME, keys);\n  Object.assign(window.customElements.get(TAG_NAME)?.prototype, ELEMENT_API);\n}\n", "/** Data for an `onSelect` callback. */\nexport type ItemSelected = {\n  /** Name attribute of the `<input-compl/>` element. */\n  inputName: string;\n  value: unknown;\n  label: string;\n};\n\nexport type CompletionItem = {\n  value: unknown;\n  label: string;\n  /** Pattern to match on keypress, typically the lower-case version of the label. */\n  pattern: string;\n};\n\n/**\n * State for InputCompl component.\n */\nexport type State = {\n  /** The candidates will be an array of indices into completions. */\n  candidates: number[];\n  /** Built from the provided completions props. */\n  completions: CompletionItem[];\n  /** Name assigned to the `<input-compl/>` element. */\n  name: string;\n  cssClass?: string;\n  onSelect: (data: ItemSelected) => void;\n  query: string;\n  selected: number;\n  showPopup: boolean;\n};\n\nexport type ActionKeyPress = { kind: \"keypress\"; from: \"input\" | \"list\" | \"item\"; key: string };\nexport type ActionPopup = { kind: \"popup\"; show: boolean };\nexport type ActionQuery = { kind: \"updateQuery\"; query: string };\nexport type ActionSelectIndex = { kind: \"selectIndex\"; index: number };\nexport type ActionUpdate = { kind: \"update\"; state: Partial<State> };\nexport type Actions = ActionKeyPress | ActionPopup | ActionQuery | ActionSelectIndex | ActionUpdate;\n\n// biome-ignore format: do not add new lines.\nexport function reducer(state: State, action: Actions): State {\n  switch (action.kind) {\n    case \"keypress\": return handleKeypress(state, action);\n    case \"popup\": return handlePopup(state, action);\n    case \"selectIndex\": return handleSelectIndex(state, action);\n    case \"update\": return handleUpdate(state, action);\n    case \"updateQuery\": return handleUpdateQuery(state, action);\n    default: return state;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/** Update anything: mostly used to update state from `props` changes. */\nfunction handleUpdate(state: State, { state: newState }: ActionUpdate): State {\n  // The dummy query ensures the candidates are updated.\n  return handleUpdateQuery({ ...state, query: \"[DUMMY]\", ...newState }, { kind: \"updateQuery\", query: \"\" });\n}\n\nfunction handleKeypress(state: State, { from, key }: ActionKeyPress): State {\n  const { showPopup, candidates } = state;\n\n  if (key === \"Escape\") {\n    if (showPopup) return handlePopup(state, { kind: \"popup\", show: false });\n    return state;\n  }\n\n  if (key === \"ArrowDown\" || key === \"ArrowUp\") {\n    if (from === \"input\" && !showPopup && candidates.length > 0) {\n      return handlePopup({ ...state, selected: 0 }, { kind: \"popup\", show: true });\n    }\n\n    const offset = key === \"ArrowDown\" ? 1 : -1;\n    const newSelected = (state.selected + candidates.length + offset) % candidates.length;\n    if (state.selected !== newSelected) return { ...state, selected: newSelected };\n    return state;\n  }\n\n  if (key !== \"Enter\") return state;\n\n  if (!state.showPopup) return handlePopup(state, { kind: \"popup\", show: true });\n\n  const elem = state.completions[state.candidates[state.selected]];\n  state.onSelect({ inputName: state.name, value: elem.value, label: elem.label });\n\n  const queryLess = handleUpdateQuery(state, { kind: \"updateQuery\", query: \"\" });\n  return handlePopup(queryLess, { kind: \"popup\", show: false });\n}\n\nfunction handlePopup(state: State, { show }: ActionPopup): State {\n  const { candidates, showPopup } = state;\n  const popupShowable = candidates.length > 0;\n  if (!popupShowable) {\n    if (showPopup) return { ...state, showPopup: false };\n    return state;\n  }\n  if (showPopup === show) return state;\n  return { ...state, showPopup: show };\n}\n\nfunction handleUpdateQuery(state: State, { query }: ActionQuery): State {\n  const { query: prevQuery } = state;\n  if (query === prevQuery) return state;\n\n  const candidates: number[] = [];\n\n  const q = query.trim().toLowerCase();\n  state.completions.forEach(({ pattern }, idx) => {\n    if (q.length === 0 || pattern.includes(q)) candidates.push(idx);\n  });\n\n  candidates.sort((a, b) => {\n    const aLabel = state.completions[a].pattern;\n    const bLabel = state.completions[b].pattern;\n\n    const aMatchStart = aLabel.startsWith(q);\n    const bMatchStart = bLabel.startsWith(q);\n\n    if (aMatchStart && bMatchStart) return aLabel.localeCompare(bLabel);\n    if (aMatchStart) return -1;\n    if (bMatchStart) return 1;\n    if (aLabel.length < bLabel.length) return -1;\n    return aLabel.localeCompare(bLabel);\n  });\n\n  return {\n    ...state,\n    candidates,\n    query,\n    selected: 0,\n    showPopup: query.length > 0,\n  };\n}\n\nfunction handleSelectIndex(state: State, { index }: ActionSelectIndex): State {\n  const { candidates, selected } = state;\n  if (!candidates) {\n    if (selected !== 0) return { ...state, selected: 0 };\n    return state;\n  }\n  if (index < 0 || index >= candidates.length || index === selected) return state;\n  return { ...state, selected: index };\n}\n", "import type { Ref } from \"preact\";\nimport { useEffect, useReducer, useRef } from \"preact/hooks\";\n\nimport { customEvent, send } from \"../../utils\";\n\nimport { type CompletionItem, type ItemSelected, reducer } from \"./reducer\";\n\n/** HTML tag name for the CustomElement */\nexport const TAG_NAME = \"input-compl\";\n\nexport type InputComplProps = {\n  name: string;\n  class?: string;\n  completions?: CompletionItem[];\n};\n\nexport function InputCompl({ name, class: cssClass, completions }: InputComplProps) {\n  const inputRef = useRef<HTMLInputElement>();\n  const popupRef = useRef<HTMLDivElement>();\n  const selRef = useRef<HTMLDivElement>();\n\n  const [state, dispatch] = useReducer(reducer, {\n    candidates: [],\n    completions: [],\n    name: name,\n    cssClass: cssClass,\n    query: \"\",\n    selected: 0,\n    showPopup: false,\n    onSelect: (data: ItemSelected) => send(inputRef.current, EVENTS.outSelect.create(data)),\n  });\n\n  useEffect(() => {\n    dispatch({ kind: \"update\", state: { completions: completions ?? [], name, cssClass } });\n  }, [completions, cssClass, name]);\n\n  useEffect(() => {\n    if (inputRef.current) inputRef.current.value = state.query;\n  }, [state.query]);\n\n  useEffect(() => {\n    if (popupRef.current && inputRef.current) {\n      popupRef.current.style.width = `${inputRef.current.offsetWidth}px`;\n    }\n    selRef.current?.scrollIntoView({ block: \"nearest\" });\n  });\n\n  const showPopup = state.candidates.length > 0 && state.showPopup;\n\n  return (\n    <>\n      <input\n        autocomplete=\"off\"\n        class={`${showPopup ? \"focused\" : \"\"} relative block ${state.cssClass ?? \"\"}`}\n        name={name}\n        onBlur={({ relatedTarget }) => {\n          if (relatedTarget === popupRef.current) return;\n          dispatch({ kind: \"popup\", show: false });\n        }}\n        onClick={() => dispatch({ kind: \"popup\", show: true })}\n        onInput={() => dispatch({ kind: \"updateQuery\", query: inputRef.current?.value ?? \"\" })}\n        onKeyDown={({ key }) => dispatch({ kind: \"keypress\", from: \"input\", key })}\n        placeholder=\"Search\"\n        ref={inputRef as Ref<HTMLInputElement>}\n        tabIndex={0}\n        type=\"search\"\n      />\n      <div\n        class={`popup ${showPopup ? \"\" : \"hidden\"} absolute z-10 mt-1 max-h-80 max-w-[15rem] overflow-y-auto overflow-x-hidden border border-solid bg-[white] p-1 text-[#333]`}\n        onBlur={({ relatedTarget }) => {\n          if (relatedTarget === inputRef.current) return;\n          dispatch({ kind: \"popup\", show: false });\n        }}\n        onKeyDown={({ key }) => dispatch({ kind: \"keypress\", from: \"list\", key })}\n        ref={popupRef as Ref<HTMLDivElement>}\n        tabindex={0}>\n        {state.candidates.map((complIdx, idx) => (\n          <div\n            class={`item ${idx === state.selected ? \"selected\" : \"\"} min-w-[8rem]`}\n            key={state.completions[complIdx].value}\n            onClick={() => dispatch({ kind: \"selectIndex\", index: idx })}\n            onDblClick={() => dispatch({ kind: \"keypress\", from: \"item\", key: \"Enter\" })}\n            onKeyDown={({ key }) => dispatch({ kind: \"keypress\", from: \"item\", key })}\n            ref={(idx === state.selected ? selRef : undefined) as Ref<HTMLDivElement>}>\n            {state.completions[complIdx].label}\n          </div>\n        ))}\n      </div>\n    </>\n  );\n}\n\n/** Catalog of incoming and outgoing events, and factory functions for those events. */\nexport const EVENTS = {\n  /** Outgoing event: an item has been selected. */\n  outSelect: {\n    type: `${TAG_NAME}:select`,\n    create: (detail: ItemSelected) => customEvent(EVENTS.outSelect.type, detail),\n  },\n};\n", "/**\n * <input-compl> Custom Element: provides an input field with autocompletion.\n */\n\nimport register from \"preact-custom-element\";\n\nimport { on } from \"../../utils\";\n\nimport { type InputSelElement, matchingInputSelByName } from \"../input-sel\";\n\nimport { EVENTS, InputCompl, type InputComplProps, TAG_NAME } from \"./input-compl\";\nimport type { CompletionItem, ItemSelected } from \"./reducer\";\n\nexport { TAG_NAME };\nexport type { CompletionItem, ItemSelected };\n\n/** Additional methods for the custom element. */\nconst ELEMENT_API = {\n  /** Register a handler for selection. */\n  onSelect(this: HTMLElement & InputComplProps, cb: (data: ItemSelected) => void) {\n    on(this, EVENTS.outSelect.type, ({ detail }: CustomEvent) => cb(detail as ItemSelected));\n  },\n\n  /** Redefine focus. */\n  focus(this: HTMLElement & InputComplProps) {\n    this.querySelector(\"input\")?.focus();\n  },\n\n  matchingInputSel(this: HTMLElement & InputComplProps): InputSelElement | null {\n    return matchingInputSelByName(this);\n  },\n};\n\nexport type InputComplElement = HTMLElement & InputComplProps & typeof ELEMENT_API;\n\n/** Register the Custom Element. */\nexport function registerInputCompl(): void {\n  const keys: (keyof InputComplProps)[] = [\"name\", \"completions\"];\n  register(InputCompl, TAG_NAME, keys);\n  Object.assign(window.customElements.get(TAG_NAME)?.prototype, ELEMENT_API);\n}\n", "import type { ComponentChildren, JSX, Ref } from \"preact\";\nimport { useEffect, useRef } from \"preact/hooks\";\n\nimport type { NPlang, PlangsGraph } from \"@plangs/plangs\";\n\nimport { customEvent, twBreakMd } from \"../../utils\";\n\nexport const TAG_NAME = \"pl-info\";\n\nexport type PlInfoProps = {\n  pg?: PlangsGraph;\n  pl?: NPlang;\n};\n\n/** Display a PL information, if the key is known. */\nexport function PlInfo({ pg, pl }: PlInfoProps) {\n  const self = useRef<HTMLDivElement>();\n\n  useEffect(() => {\n    const root = self.current?.parentElement as HTMLElement;\n    if (!root) return;\n\n    const div = root.parentElement;\n    if (div) {\n      const height = div.offsetHeight;\n      const viewportHeight = window.innerHeight;\n\n      if (height > viewportHeight) {\n        div.classList.remove(\"stick-to-top\");\n        div.classList.add(\"stick-to-bottom\");\n      } else {\n        div.classList.add(\"stick-to-top\");\n        div.classList.remove(\"stick-to-bottom\");\n      }\n    }\n\n    // return on(root, EVENTS.inSetData.type, ({ detail: pg }: CustomEvent) => setPg(pg as PlangsGraph));\n  });\n\n  let content: JSX.Element;\n\n  if (!pl) {\n    content = <p>Select a language to show more information.</p>;\n  } else if (!pg) {\n    content = <p>Loading graph ...</p>;\n  } else if (!pl) {\n    content = <p>Loading language ...</p>;\n  } else {\n    content = (\n      <>\n        <h1>{pl.name}</h1>\n        <p>{pl.description}</p>\n        <details class=\"-mb-4 mt-8\" open={twBreakMd()}>\n          <summary class=\"font-bold text-xl\">Details</summary>\n          {pl.relTsys.tap(rel => (\n            <Entry title=\"Type Systems\">{rel.values.map(({ tsys }) => tsys && Pill(tsys))}</Entry>\n          ))}\n          {pl.relTags.tap(rel => (\n            <Entry title=\"Tags\">{rel.values.map(({ tag }) => tag && Pill(tag))}</Entry>\n          ))}\n          {pl.relPlatforms.tap(rel => (\n            <Entry title=\"Platforms\">{rel.values.map(({ plat }) => plat && Pill(plat))}</Entry>\n          ))}\n          {pl.relInfluencedBy.tap(rel => (\n            <Entry title=\"Influenced By\">{rel.values.map(({ toPl }) => toPl && Pill(toPl))}</Entry>\n          ))}\n          {pl.relInfluenced.tap(rel => (\n            <Entry title=\"Influenced\">{rel.values.map(({ fromPl }) => fromPl && Pill(fromPl))}</Entry>\n          ))}\n          {pl.relDialectOf.tap(rel => (\n            <Entry title=\"Dialect Of\">{rel.values.map(({ toPl }) => toPl && Pill(toPl))}</Entry>\n          ))}\n          {pl.relImplements.tap(rel => (\n            <Entry title=\"Standard For\">{rel.values.map(({ toPl }) => toPl && Pill(toPl))}</Entry>\n          ))}\n          {pl.relLicenses.tap(rel => (\n            <Entry title=\"Licenses\">{rel.values.map(({ license }) => license && Pill(license))}</Entry>\n          ))}\n          {pl.extensions.tap(extensions => (\n            <Entry title=\"Extensions\">{extensions.map(name => Pill({ key: name, name, kind: \"ext\" }))}</Entry>\n          ))}\n        </details>\n      </>\n    );\n  }\n\n  return (\n    <div class=\"readable dark:prose-invert\" ref={self as Ref<HTMLDivElement>}>\n      {content}\n    </div>\n  );\n}\n\nfunction Entry({ title, children }: { title: string; children: ComponentChildren }) {\n  return (\n    <>\n      <h3>{title}</h3>\n      <p>{children}</p>\n    </>\n  );\n}\n\nfunction Pill({ key, kind, name }: { key: string; name: string; kind: string }) {\n  return (\n    <div\n      key={key}\n      data-key={key}\n      data-kind={kind}\n      class=\"-skew-y-2 mr-1 mb-3 inline-block bg-primary p-1.5 font-bold font-bold text-background text-sm shadow-lg shadow-secondary outline-2 outline-secondary\">\n      {name}\n    </div>\n  );\n}\n\nexport const EVENTS = {\n  /** Incoming event: setup the component with a PlangsGraph. */\n  inSetData: {\n    type: `${TAG_NAME}:set-data`,\n    create: (pg: PlangsGraph) => customEvent(EVENTS.inSetData.type, pg),\n  },\n};\n", "/**\n * <plang-info> element: displays information about a programming language.\n */\n\nimport register from \"preact-custom-element\";\n\nimport type { PlangsGraph } from \"@plangs/plangs\";\n\nimport { send } from \"../../utils\";\nimport { EVENTS, PlInfo, type PlInfoProps, TAG_NAME } from \"./pl-info\";\n\n/** Additional methods for the custom element. */\nconst ELEMENT_API = {\n  setDataSource(this: HTMLElement & PlInfoProps, pg: PlangsGraph): void {\n    send(this, EVENTS.inSetData.create(pg));\n  },\n};\n\nexport type PlInfoElement = HTMLElement & PlInfoProps & typeof ELEMENT_API;\n\nexport function registerPlangInfo() {\n  const keys: (keyof PlInfoProps)[] = [\"header\", \"pg\", \"pl\"];\n  register(PlInfo, TAG_NAME, keys);\n  Object.assign(window.customElements.get(TAG_NAME)?.prototype, ELEMENT_API);\n}\n", "import type { Filter } from \"@plangs/graph/auxiliar\";\n\nimport type { NLicense, NParadigm, NPlang, NPlatform, NTag, NTsys, StrDate } from \".\";\n\ntype Predicate<T> = (pl: NPlang, value: T) => boolean;\n\nconst filter = <T>(predicate: Predicate<T>) => ({ value: undefined as T | undefined, predicate });\n\n/**\n * Criteria to filter programming languages.\n */\nexport class PlangFilters {\n  filters = {\n    plangName: filter((pl, regexp: RegExp) => regexp.test(pl.name)),\n\n    appearedAfter: filter((pl, date: StrDate) => pl.firstAppearedAfter(date)),\n    releasedAfter: filter((pl, date: StrDate) => pl.releases.some(rel => !!rel.date && rel.date > date)),\n\n    hasLogo: filter((pl, val: boolean) => val === pl.images.some(img => img.kind === \"logo\")),\n    hasReleases: filter((pl, val: boolean) => val !== pl.releases.isEmpty),\n    hasWikipedia: filter((pl, val: boolean) => val === pl.websites.some(site => site.kind === \"wikipedia\")),\n    isMainstream: filter((pl, val: boolean) => val === pl.isMainstream),\n    isTranspiler: filter((pl, val: boolean) => val === pl.isTranspiler),\n\n    extensions: filter(({ extensions }, flt: Filter<string>) => flt.matches(key => extensions.includes(key))),\n\n    dialectOf: filter(({ relDialectOf }, flt: Filter<NPlang[\"key\"]>) => flt.matches(key => relDialectOf.has(key))),\n    implements: filter(({ relImplements }, flt: Filter<NPlang[\"key\"]>) => flt.matches(key => relImplements.has(key))),\n    influenced: filter(({ relInfluenced }, flt: Filter<NPlang[\"key\"]>) => flt.matches(key => relInfluenced.has(key))),\n    influencedBy: filter(({ relInfluencedBy }, flt: Filter<NPlang[\"key\"]>) => flt.matches(key => relInfluencedBy.has(key))),\n    licenses: filter(({ relLicenses }, flt: Filter<NLicense[\"key\"]>) => flt.matches(key => relLicenses.has(key))),\n    paradigms: filter(({ relParadigms }, flt: Filter<NParadigm[\"key\"]>) => flt.matches(key => relParadigms.has(key))),\n    platforms: filter(({ relPlatforms }, flt: Filter<NPlatform[\"key\"]>) => flt.matches(key => relPlatforms.has(key))),\n    tags: filter(({ relTags }, flt: Filter<NTag[\"key\"]>) => flt.matches(key => relTags.has(key))),\n    typeSystems: filter(({ relTsys }, flt: Filter<NTsys[\"key\"]>) => flt.matches(key => relTsys.has(key))),\n    writtenIn: filter(({ relWrittenIn }, flt: Filter<NPlang[\"key\"]>) => flt.matches(key => relWrittenIn.has(key))),\n  } as const;\n\n  matches(key: PlangFiltersKey, pl: NPlang): boolean {\n    const { value, predicate } = this.filters[key];\n    return value === undefined || (predicate as Predicate<typeof value>)(pl, value);\n  }\n\n  matchesAll(pl: NPlang): boolean {\n    for (const key of Object.keys(this.filters)) {\n      if (!this.matches(key as PlangFiltersKey, pl)) return false;\n    }\n    return true;\n  }\n}\n\nexport type PlangFiltersKey = keyof PlangFilters[\"filters\"];\n", "import { Filter } from \"@plangs/graph/auxiliar\";\nimport type { NLicense, NParadigm, NPlang, NPlatform, NTag, NTsys, StrDate } from \"@plangs/plangs\";\nimport { PlangFilters } from \"@plangs/plangs/filter\";\nimport type { IDKey } from \"@plangs/server/pages/dom\";\n\nimport { matchingInputSelByName } from \"../components/input-sel\";\nimport { elem } from \"../utils\";\n\n/** Create a plan filter from the inputs values. */\nexport function getFilters(): PlangFilters {\n  const filters = new PlangFilters();\n  const flt = filters.filters;\n\n  function collect<I, V>(key: IDKey, getValue: (input: I) => V, callback: (value: V) => void) {\n    const input = elem(key);\n    if (!input) {\n      console.warn(\"Missing input\", key);\n      return;\n    }\n    const value = getValue(input as I);\n    if (value) callback(value);\n  }\n\n  const trimVal = (input: HTMLElement) => (input as HTMLInputElement).value.trim();\n\n  collect(\"plangName\", trimVal, val => (flt.plangName.value = new RegExp(val, \"i\")));\n\n  collect(\"appearedAfter\", trimVal, val => (flt.appearedAfter.value = val as StrDate));\n  collect(\"releasedAfter\", trimVal, val => (flt.releasedAfter.value = val as StrDate));\n\n  const getChecked = (input: HTMLElement) => (input as HTMLInputElement).checked;\n\n  collect(\"hasLogo\", getChecked, val => (flt.hasLogo.value = val));\n  collect(\"hasReleases\", getChecked, val => (flt.hasReleases.value = val));\n  collect(\"hasWikipedia\", getChecked, val => (flt.hasWikipedia.value = val));\n  collect(\"isTranspiler\", getChecked, val => (flt.isTranspiler.value = val));\n  collect(\"isMainstream\", getChecked, val => (flt.isMainstream.value = val));\n\n  function getFilter<T>(input: HTMLElement): Filter<T> | undefined {\n    const filter = matchingInputSelByName(input)?.values();\n    return filter ? new Filter<T>(filter.mode, filter.values as Set<T>) : undefined;\n  }\n\n  collect(\"dialectOf\", getFilter<NPlang[\"key\"]>, val => (flt.dialectOf.value = val));\n  collect(\"extensions\", getFilter<string>, val => (flt.extensions.value = val));\n  collect(\"implements\", getFilter<NPlang[\"key\"]>, val => (flt.implements.value = val));\n  collect(\"influenced\", getFilter<NPlang[\"key\"]>, val => (flt.influenced.value = val));\n  collect(\"influencedBy\", getFilter<NPlang[\"key\"]>, val => (flt.influencedBy.value = val));\n  collect(\"licenses\", getFilter<NLicense[\"key\"]>, val => (flt.licenses.value = val));\n  collect(\"paradigms\", getFilter<NParadigm[\"key\"]>, val => (flt.paradigms.value = val));\n  collect(\"platforms\", getFilter<NPlatform[\"key\"]>, val => (flt.platforms.value = val));\n  collect(\"tags\", getFilter<NTag[\"key\"]>, val => (flt.tags.value = val));\n  collect(\"typeSystems\", getFilter<NTsys[\"key\"]>, val => (flt.typeSystems.value = val));\n  collect(\"writtenIn\", getFilter<NPlang[\"key\"]>, val => (flt.writtenIn.value = val));\n\n  return filters;\n}\n", "let pingTimer: Timer | undefined;\n\nconst INITIAL_TIMEOUT_MS = 10;\nconst PING_FREQ_MS = 10;\nconst RELOAD_LATENCY_MS = 10;\n\n/**\n * Setup a liverelaod connection. Attempts to reconnect if necessary.\n */\nexport function connectLivereload(timeout = INITIAL_TIMEOUT_MS, lifecycle: \"start\" | \"error\" = \"start\") {\n  if (pingTimer) {\n    clearInterval(pingTimer);\n    pingTimer = undefined;\n  }\n\n  const reconnect = () => {\n    console.info(\"attempting livereload reconnect in\", timeout, \"ms\");\n    setTimeout(() => connectLivereload(timeout * 1.5, \"error\"), timeout);\n  };\n\n  const reload = () => {\n    setTimeout(() => window.location.reload(), RELOAD_LATENCY_MS);\n  };\n\n  const socket = new WebSocket(\"/livereload\");\n  socket.addEventListener(\"open\", () => {\n    // If we needed to reconnect, reload so we can see any server side changes.\n    if (lifecycle === \"error\") return reload();\n    socket.send(\"CONNECT\");\n    pingTimer = setInterval(() => socket.readyState === WebSocket.OPEN && socket.send(\"PING\"), PING_FREQ_MS);\n  });\n\n  socket.addEventListener(\"message\", event => {\n    if (event.data === \"ACK\") console.info(\"livereload connected\", new Date());\n    if (event.data === \"RELOAD\") reload();\n  });\n\n  socket.addEventListener(\"close\", event => {\n    reconnect();\n  });\n}\n", "import { debounce, max } from \"lodash-es\";\nimport \"preact/debug\";\n\nimport { type N, type NPlang, PlangsGraph } from \"@plangs/plangs\";\n\nimport { type CompletionItem, type InputComplElement, registerInputCompl } from \"../components/input-compl\";\nimport { matchingInputSelByName, registerInputSel } from \"../components/input-sel\";\nimport { type PlInfoElement, registerPlangInfo } from \"../components/pl-info\";\n\nimport { $, $$, elem, elems, on, size } from \"../utils\";\n\nimport { getFilters } from \"./filters\";\nimport { connectLivereload } from \"./livereload\";\n\nconst CSS_COLS_KEY = \"grid-template-columns\";\n\n/** Adjusts the number of columns in the grid to stop the gap from growing too large. */\nfunction adjusutGrid(plGrid: HTMLElement, widthThumb: number, visibleThumbs: number) {\n  const widthRow = window.innerWidth;\n  const numCols = Math.min(Math.floor(widthRow / widthThumb), visibleThumbs);\n  const maxCols = Math.floor(widthRow / (5 * 16));\n\n  if (numCols < maxCols && visibleThumbs < maxCols) {\n    plGrid.style.setProperty(CSS_COLS_KEY, `repeat(${maxCols}, minmax(5.35rem, 0fr))`);\n  } else {\n    plGrid.style.removeProperty(CSS_COLS_KEY);\n  }\n}\n\nfunction startBrowseNav(pg: PlangsGraph) {\n  console.info(\"Starting PL browser.\");\n\n  const plGrid = elem(\"plGrid\");\n  const thumbs = elems(\"plThumb\");\n\n  function updatePlangs() {\n    if (thumbs.length === 0 || plGrid === undefined) return;\n\n    const plKeys = pg.plangs(getFilters());\n    let widthThumb: number | undefined;\n    for (const div of thumbs) {\n      const plKey = div.dataset.key as NPlang[\"key\"];\n      const visible = plKeys.has(plKey);\n      div.classList.toggle(\"hidden\", !visible);\n      if (visible) widthThumb ??= size(div)[0];\n    }\n\n    if (widthThumb !== undefined) adjusutGrid(plGrid, widthThumb, plKeys.size);\n    // if (status) status.innerText = `Displaying ${keys.size} languages of ${pg.n_plang.size}.`;\n  }\n\n  updatePlangs();\n\n  const debouncedUpdatePlangs = debounce(updatePlangs, 30);\n\n  // Release data.\n\n  on(elem(\"hasReleases\"), \"input\", ({ target }: InputEvent) => {\n    const checked = (target as HTMLInputElement).checked;\n    elem(\"releasedAfter\")?.closest(\"label\")?.classList.toggle(\"hide\", !checked);\n  });\n\n  // Completions.\n\n  function completions(nodeKind: N): CompletionItem[] {\n    const data: CompletionItem[] = [];\n    for (const [key, node] of pg.nodes[nodeKind]) {\n      data.push({ value: key, label: node.data.name ?? key, pattern: (node.data.name ?? key).toLowerCase() });\n    }\n    return data;\n  }\n\n  for (const compl of $$<InputComplElement>(\"input-compl\")) {\n    const [inputSel, source] = [matchingInputSelByName(compl), compl.dataset.kind as N];\n    if (!inputSel) continue;\n    if (!pg.nodes[source]) {\n      continue;\n    }\n    compl.completions = completions(source);\n    compl.onSelect(item => inputSel.addItem(item));\n    inputSel.onRemove(({ by, itemsLeft }) => {\n      if (by === \"enterKey\" && itemsLeft === 0) compl.focus();\n    });\n  }\n\n  // File Extension\n\n  const extensions = elem(\"extensions\") as HTMLInputElement;\n  const extensionsSel = matchingInputSelByName(extensions);\n\n  if (extensions && extensionsSel) {\n    on(extensions, \"keypress\", ({ key }: KeyboardEvent) => {\n      if (key !== \"Enter\") return;\n      const value = extensions.value.trim();\n      if (value === \"\") return;\n      const name = (value[0] === \".\" ? value : `.${value}`).toLowerCase();\n      extensionsSel.addItem({ value: name, label: name });\n      extensions.value = \"\";\n    });\n    extensionsSel.onRemove(({ by, itemsLeft }) => {\n      if (by !== \"enterKey\" || itemsLeft !== 0) return;\n      extensions.focus();\n    });\n  }\n\n  // On input change, re-filter the list of languages.\n\n  on(elem(\"filters\"), \"input\", ({ target }: InputEvent) => {\n    if ((target as HTMLInputElement)?.matches(\"input[name=plang-ext]\")) return;\n    debouncedUpdatePlangs();\n  });\n\n  // On lang click, display more information.\n\n  function getPl(target: EventTarget | null): NPlang | undefined {\n    const keyHolder = (target as Element).closest(\"[data-key]\") as HTMLElement;\n    if (!keyHolder || !keyHolder.dataset.key) return;\n    return pg.nodes.pl.get(keyHolder.dataset.key as NPlang[\"key\"]);\n  }\n\n  const plInfo = elem(\"todo\") as PlInfoElement;\n  const langTab = document.querySelector(\"#top-nav .lang\") as HTMLDivElement;\n  if (plInfo) {\n    on(elem(\"todo\"), \"click\", ({ target }: MouseEvent) => {\n      const pl = getPl(target);\n      if (!pl) return;\n      plInfo.pl = pl;\n      if (!langTab) return;\n      langTab.classList.toggle(\"hide\", false);\n      langTab.setAttribute(\"href\", `/pl/${pl.plainKey}`);\n      langTab.innerText = pl.name;\n    });\n  }\n\n  // On double-click, open the language page.\n\n  on(elem(\"todo\"), \"dblclick\", ({ target }: MouseEvent) => {\n    const pl = getPl(target);\n    if (pl) window.location.href = `/pl/${pl.plainKey}`;\n  });\n\n  // On click on a pl-pill in the infobox, update the infobox.\n\n  on(elem(\"todo\"), \"click\", ({ target }: MouseEvent) => {\n    const pl = getPl(target);\n    if (pl) plInfo.pl = pl;\n  });\n}\n\n// Do not use top level await.\n(async () => {\n  connectLivereload();\n\n  // Register the web components.\n  registerPlangInfo();\n  registerInputCompl();\n  registerInputSel();\n\n  const data = await (await fetch(\"/plangs.json\")).json();\n  const pg = new PlangsGraph().loadJSON(data);\n\n  $<PlInfoElement>(\"pl-info\")?.setDataSource(pg);\n\n  const [toggle, filters] = [elem(\"filterToggle\"), elem(\"filters\")];\n  if (toggle && filters) {\n    const updateToggle = () => {\n      const hidden = filters.classList.contains(\"hidden\");\n      toggle.classList.toggle(\"bg-background/75\", !hidden);\n    };\n\n    on(toggle, \"click\", () => {\n      filters.classList.toggle(\"hidden\");\n      updateToggle();\n    });\n\n    updateToggle();\n  }\n  if (elem(\"plangName\")) startBrowseNav(pg);\n})();\n"],
  "mappings": "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",
  "names": ["Symbol", "unmasked", "e", "objectProto", "nativeObjectToString", "symToStringTag", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__d", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "__i", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "__r", "prevDebounce", "options", "debounceRendering", "defer", "renderQueueLength", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "sort", "depthSort", "shift", "__v", "__P", "assign", "diff", "__n", "namespaceURI", "__u", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "constructor", "String", "createVNode", "isArray", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "contains", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "key", "type", "x", "y", "oldVNode", "__u", "shouldSearch", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "o", "cssText", "replace", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "forEach", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "diffChildren", "isArray", "Fragment", "children", "base", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "diffElementNodes", "diffed", "commitRoot", "root", "applyRef", "some", "cb", "call", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "getDomSibling", "removeNode", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "createElement", "namespaceURI", "firstChild", "hydrate", "cloneElement", "defaultProps", "normalizedProps", "arguments", "createVNode", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "globalVar", "globalVar", "globalThis", "window", "__PREACT_DEVTOOLS__", "attachPreact", "options", "Fragment", "Component", "loggedTypeFailures", "getDisplayName", "vnode", "type", "Fragment", "displayName", "name", "renderStack", "ownerStack", "getCurrentVNode", "length", "showJsxSourcePluginWarning", "isPossibleOwner", "getOwnerStack", "stack", "next", "__o", "push", "reduce", "acc", "owner", "source", "__source", "fileName", "lineNumber", "console", "warn", "isWeakMapSupported", "WeakMap", "getDomChildren", "domChildren", "__k", "forEach", "child", "apply", "getClosestDomNodeParentName", "parent", "__", "__e", "parentNode", "localName", "setState", "Component", "prototype", "isTableElement", "update", "callback", "this", "__v", "state", "call", "ILLEGAL_PARAGRAPH_CHILD_ELEMENTS", "forceUpdate", "serializeVNode", "props", "attrs", "prop", "hasOwnProperty", "value", "Object", "toString", "JSON", "stringify", "children", "__P", "oldDiff", "options", "__b", "oldDiffed", "diffed", "oldRoot", "oldVNode", "oldRender", "__r", "pop", "setupComponentStack", "hooksAllowed", "oldBeforeDiff", "oldVnode", "oldCatchError", "oldHook", "__h", "warnedComponents", "useEffect", "useLayoutEffect", "lazyPropTypes", "deprecations", "error", "errorInfo", "__c", "then", "promise", "Error", "componentStack", "setTimeout", "e", "isValid", "nodeType", "componentName", "Array", "isArray", "ref", "key", "propTypes", "has", "m", "lazyVNode", "set", "values", "__f", "obj", "i", "typeSpecs", "location", "getStack", "keys", "typeSpecName", "message", "loggedTypeFailures", "currentComponent", "renderCount", "nextComponent", "comp", "index", "property", "get", "indexOf", "deprecatedAttributes", "nodeName", "attributes", "deprecatedProto", "create", "newProps", "v", "__self", "__proto__", "join", "domParentName", "log", "illegalDomChildrenTypes", "filter", "childType", "test", "__H", "hooks", "hook", "j", "initDebug", "k2", "v", "m2", "size", "_", "l2", "elem", "n", "_", "m", "data", "f", "k", "l2", "i2", "r2", "vnodeId", "isArray", "Array", "createVNode", "type", "props", "key", "isStaticChildren", "__source", "__self", "ref", "i", "normalizedProps", "vnode", "__k", "__", "__b", "__e", "__d", "__c", "constructor", "__v", "__i", "__u", "defaultProps", "options", "$", "style", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useReducer", "reducer", "initialState", "init", "hookState", "getHookState", "currentIndex", "_reducer", "__c", "__", "invokeOrReturn", "action", "currentValue", "__N", "nextValue", "setState", "currentComponent", "_hasScuFromHooks", "updateHookState", "p", "s", "c", "__H", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "forEach", "hookItem", "props", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "options", "__s", "argsChanged", "_pendingArgs", "__h", "push", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "self", "A", "p", "y", "root", "i", "u", "v", "elem", "$", "reducer", "elem", "q", "a", "b", "TAG_NAME", "A", "p", "reducer", "EVENTS", "y", "u", "ELEMENT_API", "EVENTS", "TAG_NAME", "TAG_NAME", "self", "A", "y", "root", "u", "EVENTS", "ELEMENT_API", "EVENTS", "TAG_NAME", "filter", "$"]
}
